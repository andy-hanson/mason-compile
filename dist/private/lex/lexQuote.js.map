{"version":3,"sources":["private/lex/lexQuote.js"],"names":[],"mappings":"AAAA,CAAC,UAAU,OAAO,EAAE;AAChB,QAAI,OAAO,MAAM,KAAK,QAAQ,IAAI,OAAO,MAAM,CAAC,OAAO,KAAK,QAAQ,EAAE;AAClE,YAAI,CAAC,GAAG,OAAO,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC,AAAC,IAAI,CAAC,KAAK,SAAS,EAAE,MAAM,CAAC,OAAO,GAAG,CAAC,CAAC;KAC9E,MACI,IAAI,OAAO,MAAM,KAAK,UAAU,IAAI,MAAM,CAAC,GAAG,EAAE;AACjD,cAAM,CAAC,CAAC,SAAS,EAAE,SAAS,EAAE,eAAe,EAAE,YAAY,EAAE,UAAU,EAAE,SAAS,EAAE,SAAS,EAAE,gBAAgB,EAAE,WAAW,EAAE,YAAY,EAAE,iBAAiB,CAAC,EAAE,OAAO,CAAC,CAAC;KAC5K;CACJ,CAAA,CAAE,UAAU,OAAO,EAAE,OAAO,EAAE;AAC3B,gBAAY,CAAC;;AACb,QAAI,KAAK,GAAG,OAAO,CAAC,eAAe,CAAC,CAAC;AACrC,QAAI,SAAS,GAAG,OAAO,CAAC,YAAY,CAAC,CAAC;AACtC,QAAI,OAAO,GAAG,OAAO,CAAC,UAAU,CAAC,CAAC;AAClC,QAAI,MAAM,GAAG,OAAO,CAAC,SAAS,CAAC,CAAC;AAChC,QAAI,OAAO,GAAG,OAAO,CAAC,SAAS,CAAC,CAAC;AACjC,QAAI,cAAc,GAAG,OAAO,CAAC,gBAAgB,CAAC,CAAC;AAC/C,QAAI,SAAS,GAAG,OAAO,CAAC,WAAW,CAAC,CAAC;AACrC,QAAI,UAAU,GAAG,OAAO,CAAC,YAAY,CAAC,CAAC;AACvC,QAAI,eAAe,GAAG,OAAO,CAAC,iBAAiB,CAAC,CAAC;AACjD,aAAS,QAAQ,CAAC,MAAM,EAAE,QAAQ,EAAE;AAChC,cAAM,WAAW,GAAG,MAAM,GAAG,CAAC,CAAC;AAC/B,cAAM,UAAU,GAAG,eAAe,CAAC,aAAa,EAAE,CAAC;AACnD,YAAI,UAAU,EAAE;AACZ,kBAAM,YAAY,GAAG,eAAe,CAAC,eAAe,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AACvE,qBAAS,CAAC,KAAK,CAAC,YAAY,KAAK,WAAW,EAAE,eAAe,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,CAAC,kBAAkB,CAAC,CAAC;SACjG;AACD,YAAI,IAAI,GAAG,EAAE,CAAC;AACd,iBAAS,GAAG,CAAC,GAAG,EAAE;AACd,gBAAI,GAAG,CAAC,GAAE,IAAI,EAAC,GAAE,GAAG,EAAC,CAAC,CAAC;SAC1B;AACD,iBAAS,OAAO,CAAC,IAAI,EAAE;AACnB,eAAG,CAAC,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC;SAClC;AACD,iBAAS,eAAe,GAAG;AACvB,gBAAI,IAAI,KAAK,EAAE,EAAE;AACb,8BAAc,CAAC,iBAAiB,CAAC,IAAI,OAAO,CAAC,WAAW,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;AACtE,oBAAI,GAAG,EAAE,CAAC;aACb;SACJ;AACD,iBAAS,SAAS,GAAG;AACjB,mBAAO,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,eAAe,CAAC,GAAG,EAAE,CAAC,CAAC;SAC1D;AACD,cAAM,SAAS,GAAG,QAAQ,GAAG,OAAO,CAAC,WAAW,GAAG,OAAO,CAAC,UAAU,CAAC;AACtE,sBAAc,CAAC,SAAS,CAAC,SAAS,EAAE,CAAC,KAAK,EAAE,SAAS,CAAC,CAAC;AACvD,gBAAQ,EAAE,SAAS;AACf,kBAAM,IAAI,GAAG,eAAe,CAAC,GAAG,EAAE,CAAC;AACnC,oBAAQ,IAAI;AACR,qBAAK,OAAO,CAAC,IAAI,CAAC,SAAS;AAAE;AACzB,8BAAM,IAAI,GAAG,eAAe,CAAC,GAAG,EAAE,CAAC;AACnC,4BAAI,IAAI,KAAK,OAAO,CAAC,IAAI,CAAC,IAAI,IAAI,IAAI,MAAM,QAAQ,GAAG,OAAO,CAAC,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC,IAAI,CAAC,KAAK,CAAA,AAAC,EAC9F,OAAO,CAAC,IAAI,CAAC,CAAC,KAEd,GAAG,CAAC,CAAC,EAAE,GAAE,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,EAAC,CAAC,CAAC,CAAC;AAC1C,8BAAM;qBACT;AAAA,AACD,qBAAK,OAAO,CAAC,IAAI,CAAC,IAAI;AAClB,mCAAe,EAAE,CAAC;AAClB,wBAAI,eAAe,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,eAAe,CAAC,EAAE;AACtD,8BAAM,CAAC,GAAG,SAAS,EAAE,CAAC;AACtB,sCAAc,CAAC,iBAAiB,CAAC,CAAC,CAAC,CAAC;AACpC,kCAAU,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;qBAC5B,MACI;AACD,8BAAM,QAAQ,GAAG,eAAe,CAAC,GAAG,EAAE,CAAC;AACvC,8BAAM,SAAS,GAAG,eAAe,CAAC,GAAG,EAAE,CAAC;AACxC,iCAAS,CAAC,KAAK,CAAC,OAAO,CAAC,eAAe,CAAC,SAAS,CAAC,EAAE,eAAe,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,CAAC,gBAAgB,CAAC,CAAC;AAClG,iCAAS,CAAC,OAAO,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;qBACrC;AACD,0BAAM;AAAA,AACV,qBAAK,OAAO,CAAC,IAAI,CAAC,OAAO;AAAE;AACvB,8BAAM,WAAW,GAAG,eAAe,CAAC,GAAG,EAAE,CAAC;AAC1C,mCAAW,CAAC,MAAM,GAAG,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC;AAC5C,iCAAS,CAAC,KAAK,CAAC,UAAU,EAAE,eAAe,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,CAAC,aAAa,CAAC,CAAC;AACvE,8BAAM,WAAW,GAAG,eAAe,CAAC,YAAY,EAAE,CAAC;AACnD,8BAAM,SAAS,GAAG,eAAe,CAAC,eAAe,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AACpE,4BAAI,SAAS,GAAG,WAAW,EAAE;AACzB,2CAAe,CAAC,YAAY,CAAC,WAAW,EAAE,WAAW,GAAG,SAAS,CAAC,CAAC;AACnE,kCAAM,CAAC,MAAM,CAAC,eAAe,CAAC,IAAI,EAAE,KAAK,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;AAC/D,kCAAM,QAAQ,CAAC;yBAClB,MAEG,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS,GAAG,WAAW,CAAC,CAAC,CAAC;AACzE,8BAAM;qBACT;AAAA,AACD,qBAAK,OAAO,CAAC,IAAI,CAAC,QAAQ;AACtB,wBAAI,QAAQ;AACR,4BAAI,UAAU,EACV,OAAO,CAAC,IAAI,CAAC,CAAC,KAEd,MAAM,QAAQ,CAAC;2BAEnB,GAAG,CAAC,MAAM,CAAC,CAAC;AAChB,0BAAM;AAAA,AACV,qBAAK,OAAO,CAAC,IAAI,CAAC,KAAK;AACnB,wBAAI,CAAC,QAAQ,IAAI,CAAC,UAAU,EACxB,MAAM,QAAQ,CAAC,KAEf,OAAO,CAAC,IAAI,CAAC,CAAC;AAClB,0BAAM;AAAA,AACV;AACI,2BAAO,CAAC,IAAI,CAAC,CAAC;AAAA,aACrB;SACJ;AACD,uBAAe,EAAE,CAAC;AAClB,YAAI,QAAQ,EACR,cAAc,CAAC,QAAQ,CAAC,KAAK,GAAG,cAAc,EAAE,CAAC,KAEjD,kBAAkB,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;AAChD,sBAAc,CAAC,UAAU,CAAC,eAAe,CAAC,GAAG,EAAE,EAAE,SAAS,CAAC,CAAC;KAC/D;AACD,UAAM,CAAC,cAAc,CAAC,OAAO,EAAE,YAAY,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC,CAAC;AAC9D,WAAO,CAAC,OAAO,GAAG,QAAQ,CAAC;AAC3B,aAAS,kBAAkB,CAAC,UAAU,EAAE;AACpC,cAAM,MAAM,GAAG,UAAU,CAAC,SAAS,CAAC;AACpC,YAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;AACrB,kBAAM,IAAI,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;AACvB,gBAAI,IAAI,YAAY,OAAO,CAAC,WAAW,IAAI,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,EACzD,SAAS,CAAC,IAAI,CAAC,eAAe,CAAC,GAAG,EAAE,EAAE,CAAC,IAAI,CAAC,CAAC,kBAAkB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;SACpF;KACJ;AACD,aAAS,MAAM,CAAC,GAAG,EAAE;AACjB,cAAM,GAAG,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;AAC9B,YAAI,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,GAAG,KAAK,OAAO,CAAC,IAAI,CAAC,KAAK,EAClD,OAAO,KAAK,CAAC;AACjB,aAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,EACrC,IAAI,CAAC,OAAO,CAAC,eAAe,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,EAC3C,OAAO,KAAK,CAAC;AACrB,eAAO,IAAI,CAAC;KACf;AACD,aAAS,cAAc,GAAG;AACtB,YAAI,KAAK,GAAG,EAAE,CAAC;AACf,aAAK,MAAM,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,EAC7E,IAAI,eAAe,CAAC,MAAM,CAAC,EAAE,CAAC,EAC1B,KAAK,GAAG,KAAK,GAAG,MAAM,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC;AAChD,eAAO,KAAK,CAAC;KAChB;CACJ,CAAC,CAAC","file":"private/lex/lexQuote.js","sourcesContent":["(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", 'esast/lib/Loc', '../context', '../Token', '../util', './chars', './groupContext', './lexName', './lexPlain', './sourceContext'], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    var Loc_1 = require('esast/lib/Loc');\n    var context_1 = require('../context');\n    var Token_1 = require('../Token');\n    var util_1 = require('../util');\n    var chars_1 = require('./chars');\n    var groupContext_1 = require('./groupContext');\n    var lexName_1 = require('./lexName');\n    var lexPlain_1 = require('./lexPlain');\n    var sourceContext_1 = require('./sourceContext');\n    function lexQuote(indent, isRegExp) {\n        const quoteIndent = indent + 1;\n        const isIndented = sourceContext_1.tryEatNewline();\n        if (isIndented) {\n            const actualIndent = sourceContext_1.skipWhileEquals(chars_1.Char.Tab);\n            context_1.check(actualIndent === quoteIndent, sourceContext_1.pos, _ => _.tooMuchIndentQuote);\n        }\n        let read = '';\n        function add(str) {\n            read = `${read}${str}`;\n        }\n        function addChar(char) {\n            add(String.fromCharCode(char));\n        }\n        function maybeOutputRead() {\n            if (read !== '') {\n                groupContext_1.addToCurrentGroup(new Token_1.StringToken(null, read));\n                read = '';\n            }\n        }\n        function locSingle() {\n            return Loc_1.default.singleChar(sourceContext_1.pos());\n        }\n        const groupType = isRegExp ? Token_1.GroupRegExp : Token_1.GroupQuote;\n        groupContext_1.openGroup(locSingle().start, groupType);\n        eatChars: for (;;) {\n            const char = sourceContext_1.eat();\n            switch (char) {\n                case chars_1.Char.Backslash: {\n                    const next = sourceContext_1.eat();\n                    if (next === chars_1.Char.Hash || next === (isRegExp ? chars_1.Char.Backtick : chars_1.Char.Quote))\n                        addChar(next);\n                    else\n                        add(`\\\\${String.fromCharCode(next)}`);\n                    break;\n                }\n                case chars_1.Char.Hash:\n                    maybeOutputRead();\n                    if (sourceContext_1.tryEat(chars_1.Char.OpenParenthesis)) {\n                        const l = locSingle();\n                        groupContext_1.openInterpolation(l);\n                        lexPlain_1.default(true);\n                    }\n                    else {\n                        const startPos = sourceContext_1.pos();\n                        const firstChar = sourceContext_1.eat();\n                        context_1.check(chars_1.isNameCharacter(firstChar), sourceContext_1.pos, _ => _.badInterpolation);\n                        lexName_1.default(startPos, true);\n                    }\n                    break;\n                case chars_1.Char.Newline: {\n                    const originalPos = sourceContext_1.pos();\n                    originalPos.column = originalPos.column - 1;\n                    context_1.check(isIndented, sourceContext_1.pos, _ => _.unclosedQuote);\n                    const numNewlines = sourceContext_1.skipNewlines();\n                    const newIndent = sourceContext_1.skipWhileEquals(chars_1.Char.Tab);\n                    if (newIndent < quoteIndent) {\n                        sourceContext_1.stepBackMany(originalPos, numNewlines + newIndent);\n                        util_1.assert(sourceContext_1.peek() === chars_1.Char.Newline);\n                        break eatChars;\n                    }\n                    else\n                        add('\\n'.repeat(numNewlines) + '\\t'.repeat(newIndent - quoteIndent));\n                    break;\n                }\n                case chars_1.Char.Backtick:\n                    if (isRegExp)\n                        if (isIndented)\n                            addChar(char);\n                        else\n                            break eatChars;\n                    else\n                        add('\\\\\\`');\n                    break;\n                case chars_1.Char.Quote:\n                    if (!isRegExp && !isIndented)\n                        break eatChars;\n                    else\n                        addChar(char);\n                    break;\n                default:\n                    addChar(char);\n            }\n        }\n        maybeOutputRead();\n        if (isRegExp)\n            groupContext_1.curGroup.flags = lexRegExpFlags();\n        else\n            warnForSimpleQuote(groupContext_1.curGroup);\n        groupContext_1.closeGroup(sourceContext_1.pos(), groupType);\n    }\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = lexQuote;\n    function warnForSimpleQuote(quoteGroup) {\n        const tokens = quoteGroup.subTokens;\n        if (tokens.length === 1) {\n            const name = tokens[0];\n            if (name instanceof Token_1.StringToken && isName(name.value))\n                context_1.warn(sourceContext_1.pos(), _ => _.suggestSimpleQuote(name.value));\n        }\n    }\n    function isName(str) {\n        const cc0 = str.charCodeAt(0);\n        if (chars_1.isDigit(cc0) || cc0 === chars_1.Char.Tilde)\n            return false;\n        for (let i = 0; i < str.length; i = i + 1)\n            if (!chars_1.isNameCharacter(str.charCodeAt(i)))\n                return false;\n        return true;\n    }\n    function lexRegExpFlags() {\n        let flags = '';\n        for (const ch of [chars_1.Char.G, chars_1.Char.I, chars_1.Char.M, chars_1.Char.Y])\n            if (sourceContext_1.tryEat(ch))\n                flags = flags + String.fromCharCode(ch);\n        return flags;\n    }\n});\n"],"sourceRoot":"/source/"}