if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports', '../MsAst', '../Token', '../util', './context', './parseBlock', './parseCase', './parseExcept', './parseFor', './parseLine', './parseLocalDeclares', './parse*', './Slice'], function (exports, _MsAst, _Token, _util, _context, _parseBlock, _parseCase, _parseExcept, _parseFor, _parseLine, _parseLocalDeclares, _parse, _Slice) {
	'use strict';

	Object.defineProperty(exports, '__esModule', {
		value: true
	});

	var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _parseCase2 = _interopRequireDefault(_parseCase);

	var _parseExcept2 = _interopRequireDefault(_parseExcept);

	var _parseLine2 = _interopRequireDefault(_parseLine);

	var _parseLocalDeclares2 = _interopRequireDefault(_parseLocalDeclares);

	var _Slice2 = _interopRequireDefault(_Slice);

	exports.default = tokens => {
		const head = tokens.head();
		const rest = tokens.tail();

		const noRest = () => (0, _context.checkEmpty)(rest, () => `Did not expect anything after ${ head }`);

		// We only deal with mutable expressions here, otherwise we fall back to parseExpr.
		if (head instanceof _Token.Keyword) switch (head.kind) {
			case _Token.KW_Assert:case _Token.KW_AssertNot:
				return parseAssert(head.kind === _Token.KW_AssertNot, rest);
			case _Token.KW_ExceptDo:
				return (0, _parseExcept2.default)(_Token.KW_ExceptDo, rest);
			case _Token.KW_Break:
				noRest();
				return new _MsAst.Break(tokens.loc);
			case _Token.KW_BreakWithVal:
				return new _MsAst.BreakWithVal(tokens.loc, (0, _parse.parseExpr)(rest));
			case _Token.KW_CaseDo:
				return (0, _parseCase2.default)(false, false, rest);
			case _Token.KW_Debug:
				return new _MsAst.Debug(tokens.loc, (0, _Token.isGroup)(_Token.G_Block, tokens.second()) ?
				// `debug`, then indented block
				(0, _parseBlock.parseLinesFromBlock)() :
				// `debug`, then single line
				parseLineOrLines(rest));
			case _Token.KW_Debugger:
				noRest();
				return new _MsAst.SpecialDo(tokens.loc, _MsAst.SD_Debugger);
			case _Token.KW_Ellipsis:
				return new _MsAst.BagEntryMany(tokens.loc, (0, _parse.parseExpr)(rest));
			case _Token.KW_ForDo:
				return (0, _parseFor.parseForDo)(rest);
			case _Token.KW_Ignore:
				return parseIgnore(rest);
			case _Token.KW_IfDo:case _Token.KW_UnlessDo:
				{
					var _beforeAndBlock = (0, _parseBlock.beforeAndBlock)(rest);

					var _beforeAndBlock2 = _slicedToArray(_beforeAndBlock, 2);

					const before = _beforeAndBlock2[0];
					const block = _beforeAndBlock2[1];

					return new _MsAst.ConditionalDo(tokens.loc, (0, _parse.parseExpr)(before), (0, _parseBlock.parseBlockDo)(block), head.kind === _Token.KW_UnlessDo);
				}
			case _Token.KW_ObjAssign:
				return new _MsAst.BagEntry(tokens.loc, (0, _parse.parseExpr)(rest));
			case _Token.KW_Pass:
				noRest();
				return [];
			case _Token.KW_Region:
				return (0, _parseBlock.parseLinesFromBlock)(tokens);
			case _Token.KW_SuperDo:
				return new _MsAst.SuperCallDo(tokens.loc, (0, _parse.parseExprParts)(rest));
			case _Token.KW_SwitchDo:
				return (0, _parse.parseSwitch)(false, false, rest);
			case _Token.KW_Throw:
				return new _MsAst.Throw(tokens.loc, (0, _util.opIf)(!rest.isEmpty(), () => (0, _parse.parseExpr)(rest)));
			case _Token.KW_Name:
				if ((0, _Token.isKeyword)(_Token.KW_ObjAssign, rest.head())) {
					const r = rest.tail();
					const val = r.isEmpty() ? new _MsAst.SpecialVal(tokens.loc, _MsAst.SV_Name) : (0, _parse.parseExpr)(r);
					return _MsAst.ObjEntryComputed.name(tokens.loc, val);
				}
			// else fallthrough
			default:
			// fall through
		}

		return (0, _util.ifElse)(tokens.opSplitOnceWhere(isLineSplitKeyword), _ref => {
			let before = _ref.before;
			let at = _ref.at;
			let after = _ref.after;
			return parseAssignLike(before, at, after, tokens.loc);
		}, () => (0, _parse.parseExpr)(tokens));
	};

	const parseLineOrLines = tokens => {
		const _ = (0, _parseLine2.default)(tokens);
		return _ instanceof Array ? _ : [_];
	};

	exports.parseLineOrLines = parseLineOrLines;
	const isLineSplitKeyword = token => {
		if (token instanceof _Token.Keyword) switch (token.kind) {
			case _Token.KW_Assign:case _Token.KW_AssignMutable:case _Token.KW_LocalMutate:
			case _Token.KW_MapEntry:case _Token.KW_ObjAssign:case _Token.KW_Yield:case _Token.KW_YieldTo:
				return true;
			default:
				return false;
		} else return false;
	},
	      parseAssignLike = (before, at, after, loc) => {
		if (at.kind === _Token.KW_MapEntry) return new _MsAst.MapEntry(loc, (0, _parse.parseExpr)(before), (0, _parse.parseExpr)(after));

		// TODO: This code is kind of ugly.
		// It parses `x.y = z` and the like.
		if (before.size() === 1) {
			const token = before.head();
			if (token instanceof _Token.DotName) return parseMemberSet(_MsAst.LocalAccess.this(token.loc), token.name, at, after, loc);
			if ((0, _Token.isGroup)(_Token.G_Space, token)) {
				const spaced = _Slice2.default.group(token);
				const dot = spaced.last();
				if (dot instanceof _Token.DotName) {
					_context.context.check(dot.nDots === 1, dot.loc, 'Must have only 1 `.`.');
					return parseMemberSet((0, _parse.parseSpaced)(spaced.rtail()), dot.name, at, after, loc);
				}
			}
		}

		return at.kind === _Token.KW_LocalMutate ? parseLocalMutate(before, after, loc) : parseAssign(before, at, after, loc);
	},
	      parseMemberSet = (object, name, at, after, loc) => new _MsAst.MemberSet(loc, object, name, memberSetKind(at), (0, _parse.parseExpr)(after)),
	      memberSetKind = at => {
		switch (at.kind) {
			case _Token.KW_Assign:
				return _MsAst.MS_New;
			case _Token.KW_AssignMutable:
				return _MsAst.MS_NewMutable;
			case _Token.KW_LocalMutate:
				return _MsAst.MS_Mutate;
			default:
				throw new Error();
		}
	},
	      parseLocalMutate = (localsTokens, valueTokens, loc) => {
		const locals = (0, _parseLocalDeclares.parseLocalDeclaresJustNames)(localsTokens);
		_context.context.check(locals.length === 1, loc, 'TODO: LocalDestructureMutate');
		const name = locals[0].name;
		const value = (0, _parse.parseExpr)(valueTokens);
		return new _MsAst.LocalMutate(loc, name, value);
	},
	      parseAssign = (localsTokens, assigner, valueTokens, loc) => {
		const kind = assigner.kind;
		const locals = (0, _parseLocalDeclares2.default)(localsTokens);
		const opName = (0, _util.opIf)(locals.length === 1, () => locals[0].name);
		const value = parseAssignValue(kind, opName, valueTokens);

		const isYield = kind === _Token.KW_Yield || kind === _Token.KW_YieldTo;
		if ((0, _util.isEmpty)(locals)) {
			_context.context.check(isYield, localsTokens.loc, 'Assignment to nothing');
			return value;
		} else {
			if (isYield) for (const _ of locals) _context.context.check(!_.isLazy(), _.loc, 'Can not yield to lazy variable.');

			const isObjAssign = kind === _Token.KW_ObjAssign;

			if (kind === _Token.KW_AssignMutable) for (let _ of locals) {
				_context.context.check(!_.isLazy(), _.loc, 'Lazy local can not be mutable.');
				_.kind = _MsAst.LD_Mutable;
			}

			const wrap = _ => isObjAssign ? new _MsAst.ObjEntryAssign(loc, _) : _;

			if (locals.length === 1) {
				const assignee = locals[0];
				const assign = new _MsAst.AssignSingle(loc, assignee, value);
				const isTest = isObjAssign && assignee.name.endsWith('test');
				return isTest ? new _MsAst.Debug(loc, [wrap(assign)]) : wrap(assign);
			} else {
				const kind = locals[0].kind;
				for (const _ of locals) _context.context.check(_.kind === kind, _.loc, 'All locals of destructuring assignment must be of the same kind.');
				return wrap(new _MsAst.AssignDestructure(loc, locals, value, kind));
			}
		}
	},
	      parseAssignValue = (kind, opName, valueTokens) => {
		const value = valueTokens.isEmpty() && kind === _Token.KW_ObjAssign ? new _MsAst.SpecialVal(valueTokens.loc, _MsAst.SV_Null) : (0, _parse.parseExpr)(valueTokens);
		switch (kind) {
			case _Token.KW_Yield:
				return new _MsAst.Yield(value.loc, value);
			case _Token.KW_YieldTo:
				return new _MsAst.YieldTo(value.loc, value);
			default:
				return value;
		}
	},
	      parseAssert = (negate, tokens) => {
		(0, _context.checkNonEmpty)(tokens, () => `Expected something after ${ (0, _Token.keywordName)(_Token.KW_Assert) }.`);

		var _ifElse = (0, _util.ifElse)(tokens.opSplitOnceWhere(_ => (0, _Token.isKeyword)(_Token.KW_Throw, _)), _ref2 => {
			let before = _ref2.before;
			let after = _ref2.after;
			return [before, (0, _parse.parseExpr)(after)];
		}, () => [tokens, null]);

		var _ifElse2 = _slicedToArray(_ifElse, 2);

		const condTokens = _ifElse2[0];
		const opThrown = _ifElse2[1];

		const parts = (0, _parse.parseExprParts)(condTokens);
		const cond = parts.length === 1 ? parts[0] : new _MsAst.Call(condTokens.loc, parts[0], (0, _util.tail)(parts));
		return new _MsAst.Assert(tokens.loc, negate, cond, opThrown);
	},
	      parseIgnore = tokens => {
		const ignored = tokens.map(_ => {
			if ((0, _Token.isKeyword)(_Token.KW_Focus, _)) return '_';else {
				_context.context.check(_ instanceof _Token.Name, _.loc, () => `Expected local name, not ${ _ }.`);
				return _.name;
			}
		});
		return new _MsAst.Ignore(tokens.loc, ignored);
	};
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhcnNlTGluZS5qcyIsInByaXZhdGUvcGFyc2UvcGFyc2VMaW5lLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bUJDb0JlLE1BQU0sSUFBSTtBQUN4QixRQUFNLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUE7QUFDMUIsUUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFBOztBQUUxQixRQUFNLE1BQU0sR0FBRyxNQUNkLGFBZk0sVUFBVSxFQWVMLElBQUksRUFBRSxNQUFNLENBQUMsOEJBQThCLEdBQUUsSUFBSSxFQUFDLENBQUMsQ0FBQyxDQUFBOzs7QUFHaEUsTUFBSSxJQUFJLG1CQXhCOEMsT0FBTyxBQXdCbEMsRUFDMUIsUUFBUSxJQUFJLENBQUMsSUFBSTtBQUNoQixlQTFCMEUsU0FBUyxDQTBCcEUsQUFBQyxZQXpCbEIsWUFBWTtBQTBCVCxXQUFPLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxZQTFCL0IsWUFBWSxBQTBCb0MsRUFBRSxJQUFJLENBQUMsQ0FBQTtBQUFBLEFBQ3JELGVBMUJ3QixXQUFXO0FBMkJsQyxXQUFPLGtDQTNCZ0IsV0FBVyxFQTJCRixJQUFJLENBQUMsQ0FBQTtBQUFBLEFBQ3RDLGVBN0J5QyxRQUFRO0FBOEJoRCxVQUFNLEVBQUUsQ0FBQTtBQUNSLFdBQU8sV0FwQzhELEtBQUssQ0FvQ3pELE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQTtBQUFBLEFBQzdCLGVBaENtRCxlQUFlO0FBaUNqRSxXQUFPLFdBdENxRSxZQUFZLENBc0NoRSxNQUFNLENBQUMsR0FBRyxFQUFFLFdBckJoQyxTQUFTLEVBcUJpQyxJQUFJLENBQUMsQ0FBQyxDQUFBO0FBQUEsQUFDckQsZUFsQ29FLFNBQVM7QUFtQzVFLFdBQU8seUJBQVUsS0FBSyxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQTtBQUFBLEFBQ3JDLGVBcEMrRSxRQUFRO0FBcUN0RixXQUFPLFdB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LENBQUMsR0FBRyxXQTNOK0MsSUFBSSxDQTJOMUMsVUFBVSxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsVUFsTm5ELElBQUksRUFrTm9ELEtBQUssQ0FBQyxDQUFDLENBQUE7QUFDNUYsU0FBTyxXQTVORCxNQUFNLENBNE5NLE1BQU0sQ0FBQyxHQUFHLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQTtFQUNyRDtPQUVELFdBQVcsR0FBRyxNQUFNLElBQUk7QUFDdkIsUUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUk7QUFDL0IsT0FBSSxXQTdOcUMsU0FBUyxTQUViLFFBQVEsRUEyTnJCLENBQUMsQ0FBQyxFQUN6QixPQUFPLEdBQUcsQ0FBQSxLQUNOO0FBQ0osYUExTitCLE9BQU8sQ0EwTjlCLEtBQUssQ0FBQyxDQUFDLG1CQTVOaUIsSUFBSSxBQTROTCxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLHlCQUF5QixHQUFFLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQyxDQUFBO0FBQy9FLFdBQU8sQ0FBQyxDQUFDLElBQUksQ0FBQTtJQUNiO0dBQ0QsQ0FBQyxDQUFBO0FBQ0YsU0FBTyxXQXZPYyxNQUFNLENBdU9ULE1BQU0sQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLENBQUE7RUFDdEMsQ0FBQSIsImZpbGUiOiJwcml2YXRlL3BhcnNlL3BhcnNlTGluZS5qcyIsInNvdXJjZXNDb250ZW50IjpbbnVsbCwiaW1wb3J0IHtBc3NlcnQsIEFzc2lnblNpbmdsZSwgQXNzaWduRGVzdHJ1Y3R1cmUsIEJhZ0VudHJ5LCBCYWdFbnRyeU1hbnksIEJyZWFrLCBCcmVha1dpdGhWYWwsIENhbGwsXG5cdENvbmRpdGlvbmFsRG8sIERlYnVnLCBJZ25vcmUsIExEX011dGFibGUsIExvY2FsQWNjZXNzLCBMb2NhbE11dGF0ZSwgTWFwRW50cnksIE1lbWJlclNldCxcblx0TVNfTmV3LCBNU19OZXdNdXRhYmxlLCBNU19NdXRhdGUsIE9iakVudHJ5QXNzaWduLCBPYmpFbnRyeUNvbXB1dGVkLCBTRF9EZWJ1Z2dlciwgU3BlY2lhbERvLFxuXHRTcGVjaWFsVmFsLCBTdXBlckNhbGxEbywgU1ZfTmFtZSwgU1ZfTnVsbCwgVGhyb3csIFlpZWxkLCBZaWVsZFRvfSBmcm9tICcuLi9Nc0FzdCdcbmltcG9ydCB7RG90TmFtZSwgR19CbG9jaywgR19TcGFjZSwgaXNHcm91cCwgaXNLZXl3b3JkLCBLZXl3b3JkLCBrZXl3b3JkTmFtZSwgS1dfQXNzZXJ0LFxuXHRLV19Bc3NlcnROb3QsIEtXX0Fzc2lnbiwgS1dfQXNzaWduTXV0YWJsZSwgS1dfQnJlYWssIEtXX0JyZWFrV2l0aFZhbCwgS1dfQ2FzZURvLCBLV19EZWJ1Zyxcblx0S1dfRGVidWdnZXIsIEtXX0VsbGlwc2lzLCBLV19FeGNlcHREbywgS1dfRm9jdXMsIEtXX0ZvckRvLCBLV19JZkRvLCBLV19JZ25vcmUsIEtXX0xvY2FsTXV0YXRlLFxuXHRLV19NYXBFbnRyeSwgS1dfTmFtZSwgS1dfT2JqQXNzaWduLCBLV19QYXNzLCBLV19SZWdpb24sIEtXX1N1cGVyRG8sIEtXX1N3aXRjaERvLCBLV19UaHJvdyxcblx0S1dfVW5sZXNzRG8sIEtXX1lpZWxkLCBLV19ZaWVsZFRvLCBOYW1lfSBmcm9tICcuLi9Ub2tlbidcbmltcG9ydCB7aWZFbHNlLCBpc0VtcHR5LCBvcElmLCB0YWlsfSBmcm9tICcuLi91dGlsJ1xuaW1wb3J0IHtjaGVja0VtcHR5LCBjaGVja05vbkVtcHR5LCBjb250ZXh0fSBmcm9tICcuL2NvbnRleHQnXG5pbXBvcnQge2JlZm9yZUFuZEJsb2NrLCBwYXJzZUJsb2NrRG8sIHBhcnNlTGluZXNGcm9tQmxvY2t9IGZyb20gJy4vcGFyc2VCbG9jaydcbmltcG9ydCBwYXJzZUNhc2UgZnJvbSAnLi9wYXJzZUNhc2UnXG5pbXBvcnQgcGFyc2VFeGNlcHQgZnJvbSAnLi9wYXJzZUV4Y2VwdCdcbmltcG9ydCB7cGFyc2VGb3JEb30gZnJvbSAnLi9wYXJzZUZvcidcbmltcG9ydCBwYXJzZUxpbmUgZnJvbSAnLi9wYXJzZUxpbmUnXG5pbXBvcnQgcGFyc2VMb2NhbERlY2xhcmVzLCB7cGFyc2VMb2NhbERlY2xhcmVzSnVzdE5hbWVzfSBmcm9tICcuL3BhcnNlTG9jYWxEZWNsYXJlcydcbmltcG9ydCB7cGFyc2VFeHByLCBwYXJzZUV4cHJQYXJ0cywgcGFyc2VTcGFjZWQsIHBhcnNlU3dpdGNofSBmcm9tICcuL3BhcnNlKidcbmltcG9ydCBTbGljZSBmcm9tICcuL1NsaWNlJ1xuXG5leHBvcnQgZGVmYXVsdCB0b2tlbnMgPT4ge1xuXHRjb25zdCBoZWFkID0gdG9rZW5zLmhlYWQoKVxuXHRjb25zdCByZXN0ID0gdG9rZW5zLnRhaWwoKVxuXG5cdGNvbnN0IG5vUmVzdCA9ICgpID0+XG5cdFx0Y2hlY2tFbXB0eShyZXN0LCAoKSA9PiBgRGlkIG5vdCBleHBlY3QgYW55dGhpbmcgYWZ0ZXIgJHtoZWFkfWApXG5cblx0Ly8gV2Ugb25seSBkZWFsIHdpdGggbXV0YWJsZSBleHByZXNzaW9ucyBoZXJlLCBvdGhlcndpc2Ugd2UgZmFsbCBiYWNrIHRvIHBhcnNlRXhwci5cblx0aWYgKGhlYWQgaW5zdGFuY2VvZiBLZXl3b3JkKVxuXHRcdHN3aXRjaCAoaGVhZC5raW5kKSB7XG5cdFx0XHRjYXNlIEtXX0Fzc2VydDogY2FzZSBLV19Bc3NlcnROb3Q6XG5cdFx0XHRcdHJldHVybiBwYXJzZUFzc2VydChoZWFkLmtpbmQgPT09IEtXX0Fzc2VydE5vdCwgcmVzdClcblx0XHRcdGNhc2UgS1dfRXhjZXB0RG86XG5cdFx0XHRcdHJldHVybiBwYXJzZUV4Y2VwdChLV19FeGNlcHREbywgcmVzdClcblx0XHRcdGNhc2UgS1dfQnJlYWs6XG5cdFx0XHRcdG5vUmVzdCgpXG5cdFx0XHRcdHJldHVybiBuZXcgQnJlYWsodG9rZW5zLmxvYylcblx0XHRcdGNhc2UgS1dfQnJlYWtXaXRoVmFsOlxuXHRcdFx0XHRyZXR1cm4gbmV3IEJyZWFrV2l0aFZhbCh0b2tlbnMubG9jLCBwYXJzZUV4cHIocmVzdCkpXG5cdFx0XHRjYXNlIEtXX0Nhc2VEbzpcblx0XHRcdFx0cmV0dXJuIHBhcnNlQ2FzZShmYWxzZSwgZmFsc2UsIHJlc3QpXG5cdFx0XHRjYXNlIEtXX0RlYnVnOlxuXHRcdFx0XHRyZXR1cm4gbmV3IERlYnVnKHRva2Vucy5sb2MsXG5cdFx0XHRcdFx0aXNHcm91cChHX0Jsb2NrLCB0b2tlbnMuc2Vjb25kKCkpID9cblx0XHRcdFx0XHQvLyBgZGVidWdgLCB0aGVuIGluZGVudGVkIGJsb2NrXG5cdFx0XHRcdFx0cGFyc2VMaW5lc0Zyb21CbG9jaygpIDpcblx0XHRcdFx0XHQvLyBgZGVidWdgLCB0aGVuIHNpbmdsZSBsaW5lXG5cdFx0XHRcdFx0cGFyc2VMaW5lT3JMaW5lcyhyZXN0KSlcblx0XHRcdGNhc2UgS1dfRGVidWdnZXI6XG5cdFx0XHRcdG5vUmVzdCgpXG5cdFx0XHRcdHJldHVybiBuZXcgU3BlY2lhbERvKHRva2Vucy5sb2MsIFNEX0RlYnVnZ2VyKVxuXHRcdFx0Y2FzZSBLV19FbGxpcHNpczpcblx0XHRcdFx0cmV0dXJuIG5ldyBCYWdFbnRyeU1hbnkodG9rZW5zLmxvYywgcGFyc2VFeHByKHJlc3QpKVxuXHRcdFx0Y2FzZSBLV19Gb3JEbzpcblx0XHRcdFx0cmV0dXJuIHBhcnNlRm9yRG8ocmVzdClcblx0XHRcdGNhc2UgS1dfSWdub3JlOlxuXHRcdFx0XHRyZXR1cm4gcGFyc2VJZ25vcmUocmVzdClcblx0XHRcdGNhc2UgS1dfSWZEbzogY2FzZSBLV19Vbmxlc3NEbzoge1xuXHRcdFx0XHRjb25zdCBbYmVmb3JlLCBibG9ja10gPSBiZWZvcmVBbmRCbG9jayhyZXN0KVxuXHRcdFx0XHRyZXR1cm4gbmV3IENvbmRpdGlvbmFsRG8odG9rZW5zLmxvYyxcblx0XHRcdFx0XHRwYXJzZUV4cHIoYmVmb3JlKSxcblx0XHRcdFx0XHRwYXJzZUJsb2NrRG8oYmxvY2spLFxuXHRcdFx0XHRcdGhlYWQua2luZCA9PT0gS1dfVW5sZXNzRG8pXG5cdFx0XHR9XG5cdFx0XHRjYXNlIEtXX09iakFzc2lnbjpcblx0XHRcdFx0cmV0dXJuIG5ldyBCYWdFbnRyeSh0b2tlbnMubG9jLCBwYXJzZUV4cHIocmVzdCkpXG5cdFx0XHRjYXNlIEtXX1Bhc3M6XG5cdFx0XHRcdG5vUmVzdCgpXG5cdFx0XHRcdHJldHVybiBbXVxuXHRcdFx0Y2FzZSBLV19SZWdpb246XG5cdFx0XHRcdHJldHVybiBwYXJzZUxpbmVzRnJvbUJsb2NrKHRva2Vucylcblx0XHRcdGNhc2UgS1dfU3VwZXJEbzpcblx0XHRcdFx0cmV0dXJuIG5ldyBTdXBlckNhbGxEbyh0b2tlbnMubG9jLCBwYXJzZUV4cHJQYXJ0cyhyZXN0KSlcblx0XHRcdGNhc2UgS1dfU3dpdGNoRG86XG5cdFx0XHRcdHJldHVybiBwYXJzZVN3aXRjaChmYWxzZSwgZmFsc2UsIHJlc3QpXG5cdFx0XHRjYXNlIEtXX1Rocm93OlxuXHRcdFx0XHRyZXR1cm4gbmV3IFRocm93KHRva2Vucy5sb2MsIG9wSWYoIXJlc3QuaXNFbXB0eSgpLCAoKSA9PiBwYXJzZUV4cHIocmVzdCkpKVxuXHRcdFx0Y2FzZSBLV19OYW1lOlxuXHRcdFx0XHRpZiAoaXNLZXl3b3JkKEtXX09iakFzc2lnbiwgcmVzdC5oZWFkKCkpKSB7XG5cdFx0XHRcdFx0Y29uc3QgciA9IHJlc3QudGFpbCgpXG5cdFx0XHRcdFx0Y29uc3QgdmFsID0gci5pc0VtcHR5KCkgPyBuZXcgU3BlY2lhbFZhbCh0b2tlbnMubG9jLCBTVl9OYW1lKSA6IHBhcnNlRXhwcihyKVxuXHRcdFx0XHRcdHJldHVybiBPYmpFbnRyeUNvbXB1dGVkLm5hbWUodG9rZW5zLmxvYywgdmFsKVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGVsc2UgZmFsbHRocm91Z2hcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdC8vIGZhbGwgdGhyb3VnaFxuXHRcdH1cblxuXHRyZXR1cm4gaWZFbHNlKHRva2Vucy5vcFNwbGl0T25jZVdoZXJlKGlzTGluZVNwbGl0S2V5d29yZCksXG5cdFx0KHtiZWZvcmUsIGF0LCBhZnRlcn0pID0+IHBhcnNlQXNzaWduTGlrZShiZWZvcmUsIGF0LCBhZnRlciwgdG9rZW5zLmxvYyksXG5cdFx0KCkgPT4gcGFyc2VFeHByKHRva2VucykpXG59XG5cbmV4cG9ydCBjb25zdCBwYXJzZUxpbmVPckxpbmVzID0gdG9rZW5zID0+IHtcblx0Y29uc3QgXyA9IHBhcnNlTGluZSh0b2tlbnMpXG5cdHJldHVybiBfIGluc3RhbmNlb2YgQXJyYXkgPyBfIDogW19dXG59XG5cbmNvbnN0XG5cdGlzTGluZVNwbGl0S2V5d29yZCA9IHRva2VuID0+IHtcblx0XHRpZiAodG9rZW4gaW5zdGFuY2VvZiBLZXl3b3JkKVxuXHRcdFx0c3dpdGNoICh0b2tlbi5raW5kKSB7XG5cdFx0XHRcdGNhc2UgS1dfQXNzaWduOiBjYXNlIEtXX0Fzc2lnbk11dGFibGU6IGNhc2UgS1dfTG9jYWxNdXRhdGU6XG5cdFx0XHRcdGNhc2UgS1dfTWFwRW50cnk6IGNhc2UgS1dfT2JqQXNzaWduOiBjYXNlIEtXX1lpZWxkOiBjYXNlIEtXX1lpZWxkVG86XG5cdFx0XHRcdFx0cmV0dXJuIHRydWVcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2Vcblx0XHRcdH1cblx0XHRlbHNlXG5cdFx0XHRyZXR1cm4gZmFsc2Vcblx0fSxcblxuXHRwYXJzZUFzc2lnbkxpa2UgPSAoYmVmb3JlLCBhdCwgYWZ0ZXIsIGxvYykgPT4ge1xuXHRcdGlmIChhdC5raW5kID09PSBLV19NYXBFbnRyeSlcblx0XHRcdHJldHVybiBuZXcgTWFwRW50cnkobG9jLCBwYXJzZUV4cHIoYmVmb3JlKSwgcGFyc2VFeHByKGFmdGVyKSlcblxuXHRcdC8vIFRPRE86IFRoaXMgY29kZSBpcyBraW5kIG9mIHVnbHkuXG5cdFx0Ly8gSXQgcGFyc2VzIGB4LnkgPSB6YCBhbmQgdGhlIGxpa2UuXG5cdFx0aWYgKGJlZm9yZS5zaXplKCkgPT09IDEpIHtcblx0XHRcdGNvbnN0IHRva2VuID0gYmVmb3JlLmhlYWQoKVxuXHRcdFx0aWYgKHRva2VuIGluc3RhbmNlb2YgRG90TmFtZSlcblx0XHRcdFx0cmV0dXJuIHBhcnNlTWVtYmVyU2V0KFx0TG9jYWxBY2Nlc3MudGhpcyh0b2tlbi5sb2MpLCB0b2tlbi5uYW1lLCBhdCwgYWZ0ZXIsIGxvYylcblx0XHRcdGlmIChpc0dyb3VwKEdfU3BhY2UsIHRva2VuKSkge1xuXHRcdFx0XHRjb25zdCBzcGFjZWQgPSBTbGljZS5ncm91cCh0b2tlbilcblx0XHRcdFx0Y29uc3QgZG90ID0gc3BhY2VkLmxhc3QoKVxuXHRcdFx0XHRpZiAoZG90IGluc3RhbmNlb2YgRG90TmFtZSkge1xuXHRcdFx0XHRcdGNvbnRleHQuY2hlY2soZG90Lm5Eb3RzID09PSAxLCBkb3QubG9jLCAnTXVzdCBoYXZlIG9ubHkgMSBgLmAuJylcblx0XHRcdFx0XHRyZXR1cm4gcGFyc2VNZW1iZXJTZXQocGFyc2VTcGFjZWQoc3BhY2VkLnJ0YWlsKCkpLCBkb3QubmFtZSwgYXQsIGFmdGVyLCBsb2MpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gYXQua2luZCA9PT0gS1dfTG9jYWxNdXRhdGUgP1xuXHRcdFx0cGFyc2VMb2NhbE11dGF0ZShiZWZvcmUsIGFmdGVyLCBsb2MpIDpcblx0XHRcdHBhcnNlQXNzaWduKGJlZm9yZSwgYXQsIGFmdGVyLCBsb2MpXG5cdH0sXG5cblx0cGFyc2VNZW1iZXJTZXQgPSAob2JqZWN0LCBuYW1lLCBhdCwgYWZ0ZXIsIGxvYykgPT5cblx0XHRuZXcgTWVtYmVyU2V0KGxvYywgb2JqZWN0LCBuYW1lLCBtZW1iZXJTZXRLaW5kKGF0KSwgcGFyc2VFeHByKGFmdGVyKSksXG5cdG1lbWJlclNldEtpbmQgPSBhdCA9PiB7XG5cdFx0c3dpdGNoIChhdC5raW5kKSB7XG5cdFx0XHRjYXNlIEtXX0Fzc2lnbjogcmV0dXJuIE1TX05ld1xuXHRcdFx0Y2FzZSBLV19Bc3NpZ25NdXRhYmxlOiByZXR1cm4gTVNfTmV3TXV0YWJsZVxuXHRcdFx0Y2FzZSBLV19Mb2NhbE11dGF0ZTogcmV0dXJuIE1TX011dGF0ZVxuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKClcblx0XHR9XG5cdH0sXG5cblx0cGFyc2VMb2NhbE11dGF0ZSA9IChsb2NhbHNUb2tlbnMsIHZhbHVlVG9rZW5zLCBsb2MpID0+IHtcblx0XHRjb25zdCBsb2NhbHMgPSBwYXJzZUxvY2FsRGVjbGFyZXNKdXN0TmFtZXMobG9jYWxzVG9rZW5zKVxuXHRcdGNvbnRleHQuY2hlY2sobG9jYWxzLmxlbmd0aCA9PT0gMSwgbG9jLCAnVE9ETzogTG9jYWxEZXN0cnVjdHVyZU11dGF0ZScpXG5cdFx0Y29uc3QgbmFtZSA9IGxvY2Fsc1swXS5uYW1lXG5cdFx0Y29uc3QgdmFsdWUgPSBwYXJzZUV4cHIodmFsdWVUb2tlbnMpXG5cdFx0cmV0dXJuIG5ldyBMb2NhbE11dGF0ZShsb2MsIG5hbWUsIHZhbHVlKVxuXHR9LFxuXG5cdHBhcnNlQXNzaWduID0gKGxvY2Fsc1Rva2VucywgYXNzaWduZXIsIHZhbHVlVG9rZW5zLCBsb2MpID0+IHtcblx0XHRjb25zdCBraW5kID0gYXNzaWduZXIua2luZFxuXHRcdGNvbnN0IGxvY2FscyA9IHBhcnNlTG9jYWxEZWNsYXJlcyhsb2NhbHNUb2tlbnMpXG5cdFx0Y29uc3Qgb3BOYW1lID0gb3BJZihsb2NhbHMubGVuZ3RoID09PSAxLCAoKSA9PiBsb2NhbHNbMF0ubmFtZSlcblx0XHRjb25zdCB2YWx1ZSA9IHBhcnNlQXNzaWduVmFsdWUoa2luZCwgb3BOYW1lLCB2YWx1ZVRva2VucylcblxuXHRcdGNvbnN0IGlzWWllbGQgPSBraW5kID09PSBLV19ZaWVsZCB8fCBraW5kID09PSBLV19ZaWVsZFRvXG5cdFx0aWYgKGlzRW1wdHkobG9jYWxzKSkge1xuXHRcdFx0Y29udGV4dC5jaGVjayhpc1lpZWxkLCBsb2NhbHNUb2tlbnMubG9jLCAnQXNzaWdubWVudCB0byBub3RoaW5nJylcblx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoaXNZaWVsZClcblx0XHRcdFx0Zm9yIChjb25zdCBfIG9mIGxvY2Fscylcblx0XHRcdFx0XHRjb250ZXh0LmNoZWNrKCFfLmlzTGF6eSgpLCBfLmxvYywgJ0NhbiBub3QgeWllbGQgdG8gbGF6eSB2YXJpYWJsZS4nKVxuXG5cdFx0XHRjb25zdCBpc09iakFzc2lnbiA9IGtpbmQgPT09IEtXX09iakFzc2lnblxuXG5cdFx0XHRpZiAoa2luZCA9PT0gS1dfQXNzaWduTXV0YWJsZSlcblx0XHRcdFx0Zm9yIChsZXQgXyBvZiBsb2NhbHMpIHtcblx0XHRcdFx0XHRjb250ZXh0LmNoZWNrKCFfLmlzTGF6eSgpLCBfLmxvYywgJ0xhenkgbG9jYWwgY2FuIG5vdCBiZSBtdXRhYmxlLicpXG5cdFx0XHRcdFx0Xy5raW5kID0gTERfTXV0YWJsZVxuXHRcdFx0XHR9XG5cblx0XHRcdGNvbnN0IHdyYXAgPSBfID0+IGlzT2JqQXNzaWduID8gbmV3IE9iakVudHJ5QXNzaWduKGxvYywgXykgOiBfXG5cblx0XHRcdGlmIChsb2NhbHMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdGNvbnN0IGFzc2lnbmVlID0gbG9jYWxzWzBdXG5cdFx0XHRcdGNvbnN0IGFzc2lnbiA9IG5ldyBBc3NpZ25TaW5nbGUobG9jLCBhc3NpZ25lZSwgdmFsdWUpXG5cdFx0XHRcdGNvbnN0IGlzVGVzdCA9IGlzT2JqQXNzaWduICYmIGFzc2lnbmVlLm5hbWUuZW5kc1dpdGgoJ3Rlc3QnKVxuXHRcdFx0XHRyZXR1cm4gaXNUZXN0ID8gbmV3IERlYnVnKGxvYywgW3dyYXAoYXNzaWduKV0pIDogd3JhcChhc3NpZ24pXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCBraW5kID0gbG9jYWxzWzBdLmtpbmRcblx0XHRcdFx0Zm9yIChjb25zdCBfIG9mIGxvY2Fscylcblx0XHRcdFx0XHRjb250ZXh0LmNoZWNrKF8ua2luZCA9PT0ga2luZCwgXy5sb2MsXG5cdFx0XHRcdFx0XHQnQWxsIGxvY2FscyBvZiBkZXN0cnVjdHVyaW5nIGFzc2lnbm1lbnQgbXVzdCBiZSBvZiB0aGUgc2FtZSBraW5kLicpXG5cdFx0XHRcdHJldHVybiB3cmFwKG5ldyBBc3NpZ25EZXN0cnVjdHVyZShsb2MsIGxvY2FscywgdmFsdWUsIGtpbmQpKVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwYXJzZUFzc2lnblZhbHVlID0gKGtpbmQsIG9wTmFtZSwgdmFsdWVUb2tlbnMpID0+IHtcblx0XHRjb25zdCB2YWx1ZSA9IHZhbHVlVG9rZW5zLmlzRW1wdHkoKSAmJiBraW5kID09PSBLV19PYmpBc3NpZ24gP1xuXHRcdFx0bmV3IFNwZWNpYWxWYWwodmFsdWVUb2tlbnMubG9jLCBTVl9OdWxsKSA6XG5cdFx0XHRwYXJzZUV4cHIodmFsdWVUb2tlbnMpXG5cdFx0c3dpdGNoIChraW5kKSB7XG5cdFx0XHRjYXNlIEtXX1lpZWxkOlxuXHRcdFx0XHRyZXR1cm4gbmV3IFlpZWxkKHZhbHVlLmxvYywgdmFsdWUpXG5cdFx0XHRjYXNlIEtXX1lpZWxkVG86XG5cdFx0XHRcdHJldHVybiBuZXcgWWllbGRUbyh2YWx1ZS5sb2MsIHZhbHVlKVxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIHZhbHVlXG5cdFx0fVxuXHR9LFxuXG5cdHBhcnNlQXNzZXJ0ID0gKG5lZ2F0ZSwgdG9rZW5zKSA9PiB7XG5cdFx0Y2hlY2tOb25FbXB0eSh0b2tlbnMsICgpID0+IGBFeHBlY3RlZCBzb21ldGhpbmcgYWZ0ZXIgJHtrZXl3b3JkTmFtZShLV19Bc3NlcnQpfS5gKVxuXG5cdFx0Y29uc3QgW2NvbmRUb2tlbnMsIG9wVGhyb3duXSA9XG5cdFx0XHRpZkVsc2UodG9rZW5zLm9wU3BsaXRPbmNlV2hlcmUoXyA9PiBpc0tleXdvcmQoS1dfVGhyb3csIF8pKSxcblx0XHRcdFx0KHtiZWZvcmUsIGFmdGVyfSkgPT4gW2JlZm9yZSwgcGFyc2VFeHByKGFmdGVyKV0sXG5cdFx0XHRcdCgpID0+IFt0b2tlbnMsIG51bGxdKVxuXG5cdFx0Y29uc3QgcGFydHMgPSBwYXJzZUV4cHJQYXJ0cyhjb25kVG9rZW5zKVxuXHRcdGNvbnN0IGNvbmQgPSBwYXJ0cy5sZW5ndGggPT09IDEgPyBwYXJ0c1swXSA6IG5ldyBDYWxsKGNvbmRUb2tlbnMubG9jLCBwYXJ0c1swXSwgdGFpbChwYXJ0cykpXG5cdFx0cmV0dXJuIG5ldyBBc3NlcnQodG9rZW5zLmxvYywgbmVnYXRlLCBjb25kLCBvcFRocm93bilcblx0fSxcblxuXHRwYXJzZUlnbm9yZSA9IHRva2VucyA9PiB7XG5cdFx0Y29uc3QgaWdub3JlZCA9IHRva2Vucy5tYXAoXyA9PiB7XG5cdFx0XHRpZiAoaXNLZXl3b3JkKEtXX0ZvY3VzLCBfKSlcblx0XHRcdFx0cmV0dXJuICdfJ1xuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGNvbnRleHQuY2hlY2soXyBpbnN0YW5jZW9mIE5hbWUsIF8ubG9jLCAoKSA9PiBgRXhwZWN0ZWQgbG9jYWwgbmFtZSwgbm90ICR7X30uYClcblx0XHRcdFx0cmV0dXJuIF8ubmFtZVxuXHRcdFx0fVxuXHRcdH0pXG5cdFx0cmV0dXJuIG5ldyBJZ25vcmUodG9rZW5zLmxvYywgaWdub3JlZClcblx0fSJdLCJzb3VyY2VSb290IjoiL3NyYyJ9
