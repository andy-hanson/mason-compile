{"version":3,"sources":["private/lex/util.js","private/lex/util.ts"],"names":[],"mappings":"AAAA,CAAC,UAAU,OAAV,EAAmB;AAChB,QAAI,OAAO,MAAP,KAAkB,QAAlB,IAA8B,OAAO,OAAO,OAAP,KAAmB,QAA1B,EAAoC;AAClE,YAAI,IAAI,QAAQ,OAAR,EAAiB,OAAjB,CAAJ,CAD8D,IAC3B,MAAM,SAAN,EAAiB,OAAO,OAAP,GAAiB,CAAjB,CAArB;KADvC,MAGK,IAAI,OAAO,MAAP,KAAkB,UAAlB,IAAgC,OAAO,GAAP,EAAY;AACjD,eAAO,CAAC,SAAD,EAAY,SAAZ,EAAuB,eAAvB,EAAwC,kBAAxC,EAA4D,gBAA5D,EAA8E,iBAA9E,CAAP,EAAyG,OAAzG,EADiD;KAAhD;CAJR,CAAD,CAOG,UAAU,OAAV,EAAmB,OAAnB,EAA4B;AAC3B,iBAD2B;;ACP/B,UAAA,QAAA,QAAuB,eAAvB,CAAA,CDO+B;ACL/B,UAAA,YAAA,QAA2C,kBAA3C,CAAA,CDK+B;ACJ/B,UAAA,iBAAA,QAAuC,gBAAvC,CAAA,CDI+B;ACH/B,UAAA,kBAAA,QAAkB,iBAAlB,CAAA,CDG+B;ACD/B,aAAA,aAAA,CACC,QADD,EAEC,IAFD,EAEyD;AAExD,cAAM,UAAU;AACf,kBAAM,QAAQ,KAAK,IAAL,CAAd;AACA,uBAAW,QAAQ,KAAK,SAAL,CAAnB;AACA,kBAAM,UAAU,IAAV,GAAiB,KAAK,IAAL,GAAY,CAA7B;SAHD,CAFkD;AAOxD,cAAM,MAAM,IAAI,MAAA,OAAA,CAAI,QAAR,EAAkB,gBAAA,GAAA,EAAlB,CAAN,CAPkD;AAQxD,uBAAA,iBAAA,CAAkB,IAAI,UAAA,UAAA,CAAW,GAAf,EAAoB,OAApB,CAAlB,EARwD;AAUxD,uBAAA,KAAA,CAAM,GAAN,EAVwD;KAFzD;AAAgB,YAAA,aAAA,GAAa,aAAb,CDCe;ACc/B,aAAA,eAAA,CAAgC,QAAhC,EAA+C,IAA/C,EAAuD;AACtD,uBAAA,iBAAA,CAAkB,IAAI,UAAA,YAAA,CAAa,IAAI,MAAA,OAAA,CAAI,QAAR,EAAkB,gBAAA,GAAA,EAAlB,CAAjB,EAA2C,IAA3C,CAAlB,EADsD;KAAvD;AAAgB,YAAA,eAAA,GAAe,eAAf,CDde;CAA5B,CAPH","file":"private/lex/util.js","sourcesContent":["(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", 'esast/lib/Loc', '../token/Keyword', './groupContext', './sourceContext'], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    const Loc_1 = require('esast/lib/Loc');\n    const Keyword_1 = require('../token/Keyword');\n    const groupContext_1 = require('./groupContext');\n    const sourceContext_1 = require('./sourceContext');\n    function addKeywordFun(startPos, opts) {\n        const options = {\n            isDo: Boolean(opts.isDo),\n            isThisFun: Boolean(opts.isThisFun),\n            kind: 'kind' in opts ? opts.kind : 0\n        };\n        const loc = new Loc_1.default(startPos, sourceContext_1.pos());\n        groupContext_1.addToCurrentGroup(new Keyword_1.KeywordFun(loc, options));\n        groupContext_1.space(loc);\n    }\n    exports.addKeywordFun = addKeywordFun;\n    function addKeywordPlain(startPos, kind) {\n        groupContext_1.addToCurrentGroup(new Keyword_1.KeywordPlain(new Loc_1.default(startPos, sourceContext_1.pos()), kind));\n    }\n    exports.addKeywordPlain = addKeywordPlain;\n});\n","import Loc, {Pos} from 'esast/lib/Loc'\nimport {Funs} from '../ast/Fun'\nimport {KeywordFun, KeywordPlain, Kw} from '../token/Keyword'\nimport {addToCurrentGroup, space} from './groupContext'\nimport {pos} from './sourceContext'\n\nexport function addKeywordFun(\n\tstartPos: Pos,\n\topts: {isDo?: boolean, isThisFun?: boolean, kind?: Funs}\n\t): void {\n\tconst options = {\n\t\tisDo: Boolean(opts.isDo),\n\t\tisThisFun: Boolean(opts.isThisFun),\n\t\tkind: 'kind' in opts ? opts.kind : Funs.Plain\n\t}\n\tconst loc = new Loc(startPos, pos())\n\taddToCurrentGroup(new KeywordFun(loc, options))\n\t// First arg (`a` in `\\a`) goes its own spaced group, despite no space between the `\\` and it.\n\tspace(loc)\n}\n\nexport function addKeywordPlain(startPos: Pos, kind: Kw): void {\n\taddToCurrentGroup(new KeywordPlain(new Loc(startPos, pos()), kind))\n}\n"],"sourceRoot":"/source/"}