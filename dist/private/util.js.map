{"version":3,"sources":["private/util.js","private/util.ts"],"names":[],"mappings":"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","file":"private/util.js","sourcesContent":["(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", 'op/Op'], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    var Op_1 = require('op/Op');\n    function allSame(array, mapper) {\n        if (isEmpty(array))\n            return true;\n        const val = mapper(array[0]);\n        for (let i = 1; i < array.length; i = i + 1)\n            if (mapper(array[i]) !== val)\n                return false;\n        return true;\n    }\n    exports.allSame = allSame;\n    function assert(cond) {\n        if (!cond)\n            throw new Error('Assertion failed.');\n    }\n    exports.assert = assert;\n    function cat(...parts) {\n        const out = [];\n        for (const _ of parts)\n            if (_ instanceof Array)\n                out.push(..._);\n            else if (Op_1.nonNull(_))\n                out.push(_);\n        return out;\n    }\n    exports.cat = cat;\n    function flatMap(mapped, mapper) {\n        const out = [];\n        for (let i = 0; i < mapped.length; i = i + 1)\n            out.push(...mapper(mapped[i], i));\n        return out;\n    }\n    exports.flatMap = flatMap;\n    function head(array) {\n        assert(!isEmpty(array));\n        return array[0];\n    }\n    exports.head = head;\n    function implementMany(types, methodName, impls) {\n        for (const name in impls)\n            types[name].prototype[methodName] = impls[name];\n    }\n    exports.implementMany = implementMany;\n    function isEmpty(array) {\n        return array.length === 0;\n    }\n    exports.isEmpty = isEmpty;\n    function last(array) {\n        assert(!isEmpty(array));\n        return array[array.length - 1];\n    }\n    exports.last = last;\n    function* reverseIter(array) {\n        for (let i = array.length - 1; i >= 0; i = i - 1)\n            yield array[i];\n    }\n    exports.reverseIter = reverseIter;\n    function rtail(array) {\n        assert(!isEmpty(array));\n        return array.slice(0, array.length - 1);\n    }\n    exports.rtail = rtail;\n    function tail(array) {\n        assert(!isEmpty(array));\n        return array.slice(1);\n    }\n    exports.tail = tail;\n    function toArray(value) {\n        return value instanceof Array ? value : [value];\n    }\n    exports.toArray = toArray;\n    function applyDefaults(provided, defaults) {\n        const out = {};\n        for (const key in provided) {\n            if (!(key in defaults))\n                throw new Error(`No such option ${key}.`);\n            out[key] = provided[key];\n        }\n        for (const key in defaults)\n            if (!(key in out))\n                out[key] = defaults[key];\n        return out;\n    }\n    exports.applyDefaults = applyDefaults;\n});\n","import Op, {nonNull} from 'op/Op'\n\n/** Whether every element in `array` is equal. */\nexport function allSame<A, B>(array: Array<A>, mapper: (a: A) => B): boolean {\n\tif (isEmpty(array))\n\t\treturn true\n\tconst val = mapper(array[0])\n\tfor (let i = 1; i < array.length; i = i + 1)\n\t\tif (mapper(array[i]) !== val)\n\t\t\treturn false\n\treturn true\n}\n\n/**\nUsed to ensure that the compiler is programmed correctly.\nIf an assertion fails, it's a bug in mason-compile.\nFor errors in source code, see [[check]].\n*/\nexport function assert(cond: boolean): void {\n\tif (!cond)\n\t\tthrow new Error('Assertion failed.')\n}\n\n/**\nCombine many values into one array.\nArrays are flattened and nulls are skipped.\nSo `cat([1, 2], null, 3)` is `[1, 2, 3]`.\n*/\nexport function cat<A>(...parts: Array<Array<A> | Op<A> | Op<Array<A>>>): Array<A> {\n\tconst out: Array<A> = []\n\tfor (const _ of parts)\n\t\tif (_ instanceof Array)\n\t\t\tout.push(..._)\n\t\telse if (nonNull<A>(_))\n\t\t\tout.push(_)\n\treturn out\n}\n\n/**\nLike `Array.prototype.map` but `mapper` should return Arrays,\nwhich are flattened to a single Array.\n*/\nexport function flatMap<A, B>(mapped: Array<A>, mapper: (a: A, index?: number) => Array<B>): Array<B> {\n\tconst out: Array<B> = []\n\tfor (let i = 0; i < mapped.length; i = i + 1)\n\t\tout.push(...mapper(mapped[i], i))\n\treturn out\n}\n\n/** First element of an Array. */\nexport function head<A>(array: Array<A>): A {\n\tassert(!isEmpty(array))\n\treturn array[0]\n}\n\n/**\nImplement a method `methodName` on many types at once.\n@param types Object containing many types.\n@param impls\n\tKeys are names of types in `types`.\n\tValues are implementations of the method.\n*/\nexport function implementMany(types: any, methodName: string, impls: {[key: string]: Function}): void {\n\tfor (const name in impls)\n\t\ttypes[name].prototype[methodName] = impls[name]\n}\n\n/** False iff there are any elements in the array. */\nexport function isEmpty<A>(array: Array<A>): boolean {\n\treturn array.length === 0\n}\n\n/** Element at the end of an Array. */\nexport function last<A>(array: Array<A>): A {\n\tassert(!isEmpty(array))\n\treturn array[array.length - 1]\n}\n\n/** Iterate over an Array in reverse. */\nexport function* reverseIter<A>(array: Array<A>): Iterable<A> {\n\tfor (let i = array.length - 1; i >= 0; i = i - 1)\n\t\tyield array[i]\n}\n\n/** All but the last element of an Array. */\nexport function rtail<A>(array: Array<A>): Array<A> {\n\tassert(!isEmpty(array))\n\treturn array.slice(0, array.length - 1)\n}\n\n/** All but the first element of an Array. */\nexport function tail<A>(array: Array<A>): Array<A> {\n\tassert(!isEmpty(array))\n\treturn array.slice(1)\n}\n\n/** Wrap value in an Array if it's not already one. */\nexport function toArray<A>(value: A | Array<A>): Array<A> {\n\treturn value instanceof Array ? value : [value]\n}\n\n/**\nUsed for functions that take an options objects.\nFills in defaults for options not provided.\nThrows errors for provided options that aren't recognized.\nA default value of `undefined` is used to indicate that the option must be provided.\n*/\nexport function applyDefaults<A>(provided: A, defaults: A): A {\n\tconst out: any = {}\n\n\tfor (const key in provided) {\n\t\tif (!(key in defaults))\n\t\t\tthrow new Error(`No such option ${key}.`)\n\t\tout[key] = (<any> provided)[key]\n\t}\n\n\tfor (const key in defaults)\n\t\tif (!(key in out))\n\t\t\tout[key] = (<any> defaults)[key]\n\n\treturn out\n}\n"],"sourceRoot":"/source/"}