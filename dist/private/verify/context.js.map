{"version":3,"sources":["private/verify/context.js","private/verify/context.ts"],"names":[],"mappings":"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","file":"private/verify/context.js","sourcesContent":["(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", '../VerifyResults', './locals'], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    var VerifyResults_1 = require('../VerifyResults');\n    var locals_1 = require('./locals');\n    function setup() {\n        exports.locals = new Map();\n        exports.pendingBlockLocals = [];\n        exports.funKind = 0;\n        exports.okToNotUse = new Set();\n        exports.opLoop = null;\n        exports.method = null;\n        exports.results = new VerifyResults_1.default();\n    }\n    exports.setup = setup;\n    function tearDown() {\n        exports.locals = exports.okToNotUse = exports.opLoop = exports.pendingBlockLocals = exports.method = exports.results = null;\n    }\n    exports.tearDown = tearDown;\n    function withLoop(newLoop, action) {\n        const oldLoop = exports.opLoop;\n        exports.opLoop = newLoop;\n        action();\n        exports.opLoop = oldLoop;\n    }\n    exports.withLoop = withLoop;\n    function withMethod(newMethod, action) {\n        const oldMethod = exports.method;\n        exports.method = newMethod;\n        action();\n        exports.method = oldMethod;\n    }\n    exports.withMethod = withMethod;\n    function withName(newName, action) {\n        const oldName = exports.name;\n        exports.name = newName;\n        action();\n        exports.name = oldName;\n    }\n    exports.withName = withName;\n    function withIife(action) {\n        withLoop(null, () => {\n            withInSwitch(false, action);\n        });\n    }\n    exports.withIife = withIife;\n    function withIifeIf(cond, action) {\n        if (cond)\n            withIife(action);\n        else\n            action();\n    }\n    exports.withIifeIf = withIifeIf;\n    function withIifeIfVal(sk, action) {\n        withIifeIf(sk === 1, action);\n    }\n    exports.withIifeIfVal = withIifeIfVal;\n    function setPendingBlockLocals(val) {\n        exports.pendingBlockLocals = val;\n    }\n    exports.setPendingBlockLocals = setPendingBlockLocals;\n    function withInSwitch(newInSwitch, action) {\n        const oldInSwitch = exports.isInSwitch;\n        exports.isInSwitch = newInSwitch;\n        action();\n        exports.isInSwitch = oldInSwitch;\n    }\n    exports.withInSwitch = withInSwitch;\n    function withFun(funKind, action) {\n        locals_1.withBlockLocals(() => {\n            withInFunKind(funKind, () => {\n                withIife(action);\n            });\n        });\n    }\n    exports.withFun = withFun;\n    function withMethods(action) {\n        withFun(0, action);\n    }\n    exports.withMethods = withMethods;\n    function withInFunKind(newFunKind, action) {\n        const oldFunKind = exports.funKind;\n        exports.funKind = newFunKind;\n        action();\n        exports.funKind = oldFunKind;\n    }\n});\n","import Op from 'op/Op'\nimport {Constructor} from '../ast/Class'\nimport {MethodImplLike} from '../ast/classTraitCommon'\nimport {Funs} from '../ast/Fun'\nimport {LocalDeclare} from '../ast/locals'\nimport Loop from '../ast/Loop'\nimport VerifyResults from '../VerifyResults'\nimport {withBlockLocals} from './locals'\nimport SK from './SK'\n\n/** Map from names to LocalDeclares. */\nexport let locals: Map<string, LocalDeclare>\n/** Locals that don't have to be accessed. */\nexport let okToNotUse: Set<LocalDeclare>\nexport let opLoop: Op<Loop>\n/**\nLocals for this block.\nThese are added to locals when entering a Function or lazy evaluation.\nIn:\n\ta = |\n\t\tb\n\tb = 1\n`b` will be a pending local.\nHowever:\n\ta = b\n\tb = 1\nwill fail to verify, because `b` comes after `a` and is not accessed inside a function.\nIt would work for `~a is b`, though.\n*/\nexport let pendingBlockLocals: Array<LocalDeclare>\n/**\nKind of function we are currently in.\n(Funs.Plain if not in a function.)\n*/\nexport let funKind: Funs\n/** Current method we are in, or a Constructor, or null. */\nexport let method: Op<Constructor | MethodImplLike>\nexport let results: VerifyResults\n/** Name of the closest AssignSingle. */\nexport let name: string\n/**\nWhether we're in a `switch` inside of a `for`.\nIf there's a `break` statement, the loop will need a label.\n*/\nexport let isInSwitch: boolean\n\nexport function setup(): void {\n\tlocals = new Map()\n\tpendingBlockLocals = []\n\tfunKind = Funs.Plain\n\tokToNotUse = new Set()\n\topLoop = null\n\tmethod = null\n\tresults = new VerifyResults()\n}\n\n// Release for garbage collection.\nexport function tearDown(): void {\n\tlocals = okToNotUse = opLoop = pendingBlockLocals = method = results = null\n}\n\nexport function withLoop(newLoop: Op<Loop>, action: () => void): void {\n\tconst oldLoop = opLoop\n\topLoop = newLoop\n\taction()\n\topLoop = oldLoop\n}\n\nexport function withMethod(newMethod: Constructor | MethodImplLike, action: () => void): void {\n\tconst oldMethod = method\n\tmethod = newMethod\n\taction()\n\tmethod = oldMethod\n}\n\nexport function withName(newName: string, action: () => void): void {\n\tconst oldName = name\n\tname = newName\n\taction()\n\tname = oldName\n}\n\n/** Can't break out of loop inside of IIFE. */\nexport function withIife(action: () => void): void {\n\twithLoop(null, () => {\n\t\twithInSwitch(false, action)\n\t})\n}\n\nexport function withIifeIf(cond: boolean, action: () => void): void {\n\tif (cond)\n\t\twithIife(action)\n\telse\n\t\taction()\n}\n\n/** The value form of some expressions need to be wrapped in an IIFE. */\nexport function withIifeIfVal(sk: SK, action: () => void): void {\n\twithIifeIf(sk === SK.Val, action)\n}\n\n// TODO:ES6 Shouldn't need this\nexport function setPendingBlockLocals(val: Array<LocalDeclare>): void {\n\tpendingBlockLocals = val\n}\n\nexport function withInSwitch(newInSwitch: boolean, action: () => void): void {\n\tconst oldInSwitch = isInSwitch\n\tisInSwitch = newInSwitch\n\taction()\n\tisInSwitch = oldInSwitch\n}\n\nexport function withFun(funKind: Funs, action: () => void): void {\n\twithBlockLocals(() => {\n\t\twithInFunKind(funKind, () => {\n\t\t\twithIife(action)\n\t\t})\n\t})\n}\n\nexport function withMethods(action: () => void): void {\n\twithFun(Funs.Plain, action)\n}\n\nfunction withInFunKind(newFunKind: Funs, action: () => void): void {\n\tconst oldFunKind = funKind\n\tfunKind = newFunKind\n\taction()\n\tfunKind = oldFunKind\n}\n"],"sourceRoot":"/source/"}