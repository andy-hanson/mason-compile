if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports', '../MsAst', '../Token', '../util', './context', './parseBlock', './parseCase', './parseExcept', './parseFor', './parseLine', './parseName', './parseLocalDeclares', './parseQuote', './parse*', './Slice'], function (exports, _MsAst, _Token, _util, _context, _parseBlock, _parseCase, _parseExcept, _parseFor, _parseLine, _parseName, _parseLocalDeclares, _parseQuote, _parse, _Slice) {
	'use strict';

	Object.defineProperty(exports, '__esModule', {
		value: true
	});

	var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _parseCase2 = _interopRequireDefault(_parseCase);

	var _parseExcept2 = _interopRequireDefault(_parseExcept);

	var _parseLine2 = _interopRequireDefault(_parseLine);

	var _parseLocalDeclares2 = _interopRequireDefault(_parseLocalDeclares);

	var _parseQuote2 = _interopRequireDefault(_parseQuote);

	var _Slice2 = _interopRequireDefault(_Slice);

	exports.default = tokens => {
		const head = tokens.head();
		const rest = tokens.tail();

		const noRest = () => (0, _context.checkEmpty)(rest, () => `Did not expect anything after ${ head }.`);

		// We only deal with mutable expressions here, otherwise we fall back to parseExpr.
		if (head instanceof _Token.Keyword) switch (head.kind) {
			case _Token.KW_Assert:case _Token.KW_AssertNot:
				return parseAssert(head.kind === _Token.KW_AssertNot, rest);
			case _Token.KW_ExceptDo:
				return (0, _parseExcept2.default)(_Token.KW_ExceptDo, rest);
			case _Token.KW_Break:
				noRest();
				return new _MsAst.Break(tokens.loc);
			case _Token.KW_BreakWithVal:
				return new _MsAst.BreakWithVal(tokens.loc, (0, _parse.parseExpr)(rest));
			case _Token.KW_CaseDo:
				return (0, _parseCase2.default)(false, false, rest);
			case _Token.KW_Debugger:
				noRest();
				return new _MsAst.SpecialDo(tokens.loc, _MsAst.SD_Debugger);
			case _Token.KW_Ellipsis:
				return new _MsAst.BagEntryMany(tokens.loc, (0, _parse.parseExpr)(rest));
			case _Token.KW_ForDo:
				return (0, _parseFor.parseForDo)(rest);
			case _Token.KW_Ignore:
				return parseIgnore(rest);
			case _Token.KW_IfDo:case _Token.KW_UnlessDo:
				{
					var _beforeAndBlock = (0, _parseBlock.beforeAndBlock)(rest);

					var _beforeAndBlock2 = _slicedToArray(_beforeAndBlock, 2);

					const before = _beforeAndBlock2[0];
					const block = _beforeAndBlock2[1];

					return new _MsAst.ConditionalDo(tokens.loc, (0, _parse.parseExpr)(before), (0, _parseBlock.parseBlockDo)(block), head.kind === _Token.KW_UnlessDo);
				}
			case _Token.KW_ObjAssign:
				return new _MsAst.BagEntry(tokens.loc, (0, _parse.parseExpr)(rest));
			case _Token.KW_Pass:
				noRest();
				return [];
			case _Token.KW_Region:
				return (0, _parseBlock.parseLinesFromBlock)(tokens);
			case _Token.KW_SuperDo:
				return new _MsAst.SuperCallDo(tokens.loc, (0, _parse.parseExprParts)(rest));
			case _Token.KW_SwitchDo:
				return (0, _parse.parseSwitch)(false, false, rest);
			case _Token.KW_Throw:
				return new _MsAst.Throw(tokens.loc, (0, _util.opIf)(!rest.isEmpty(), () => (0, _parse.parseExpr)(rest)));
			case _Token.KW_Name:
				if ((0, _Token.isKeyword)(_Token.KW_ObjAssign, rest.head())) {
					const r = rest.tail();
					const val = r.isEmpty() ? new _MsAst.SpecialVal(tokens.loc, _MsAst.SV_Name) : (0, _parse.parseExpr)(r);
					return _MsAst.ObjEntryComputed.name(tokens.loc, val);
				}
			// else fall through
			default:
			// fall through
		}

		return (0, _util.ifElse)(tokens.opSplitOnceWhere(isLineSplitKeyword), _ref => {
			let before = _ref.before;
			let at = _ref.at;
			let after = _ref.after;
			return parseAssignLike(before, at, after, tokens.loc);
		}, () => (0, _parse.parseExpr)(tokens));
	};

	const parseLineOrLines = tokens => {
		const _ = (0, _parseLine2.default)(tokens);
		return _ instanceof Array ? _ : [_];
	};

	exports.parseLineOrLines = parseLineOrLines;
	const isLineSplitKeyword = token => {
		if (token instanceof _Token.Keyword) switch (token.kind) {
			case _Token.KW_Assign:case _Token.KW_AssignMutable:case _Token.KW_LocalMutate:
			case _Token.KW_MapEntry:case _Token.KW_ObjAssign:case _Token.KW_Yield:case _Token.KW_YieldTo:
				return true;
			default:
				return false;
		} else return false;
	},
	      parseAssignLike = (before, at, after, loc) => {
		const kind = at.kind;
		if (kind === _Token.KW_MapEntry) return new _MsAst.MapEntry(loc, (0, _parse.parseExpr)(before), (0, _parse.parseExpr)(after));

		if (before.size() === 1) {
			const token = before.head();
			// `a.b = c`, `.b = c`, `a[b] = c`
			if ((0, _Token.isGroup)(_Token.G_Space, token)) {
				const spaced = _Slice2.default.group(token);

				var _ifElse = (0, _util.ifElse)(spaced.opSplitOnceWhere(_ => (0, _Token.isKeyword)(_Token.KW_Type, _)), _ref2 => {
					let before = _ref2.before;
					let after = _ref2.after;
					return [before, (0, _parse.parseExpr)(after)];
				}, () => [spaced, null]);

				var _ifElse2 = _slicedToArray(_ifElse, 2);

				const value = _ifElse2[0];
				const opType = _ifElse2[1];

				const last = value.last();
				const object = obj => {
					if (obj === undefined) obj = value.rtail();
					return obj.isEmpty() ? _MsAst.LocalAccess.this(obj.loc) : (0, _parse.parseSpaced)(obj);
				};

				if ((0, _Token.isKeyword)(_Token.KW_Dot, value.nextToLast())) {
					const name = (0, _parseName.tryParseName)(last);
					if (name !== null) {
						const set = object(value.rtail().rtail());
						return parseMemberSet(set, name, opType, at, after, loc);
					} else (0, _context.unexpected)(last);
				} else if ((0, _Token.isGroup)(_Token.G_Bracket, last)) return parseSubSet(object(), _Slice2.default.group(last), opType, at, after, loc);
				// `"1". 1`
			} else if ((0, _Token.isGroup)(_Token.G_Quote, token) && kind === _Token.KW_ObjAssign) return new _MsAst.ObjEntryComputed(loc, (0, _parseQuote2.default)(_Slice2.default.group(token)), (0, _parse.parseExpr)(after));
		}

		return kind === _Token.KW_LocalMutate ? parseLocalMutate(before, after, loc) : parseAssign(before, kind, after, loc);
	},
	      parseMemberSet = (object, name, opType, at, after, loc) => new _MsAst.MemberSet(loc, object, name, opType, memberSetKind(at), (0, _parse.parseExpr)(after)),
	      memberSetKind = at => {
		switch (at.kind) {
			case _Token.KW_Assign:
				return _MsAst.SET_Init;
			case _Token.KW_AssignMutable:
				return _MsAst.SET_InitMutable;
			case _Token.KW_LocalMutate:
				return _MsAst.SET_Mutate;
			default:
				(0, _context.unexpected)(at);
		}
	},
	      parseSubSet = (object, subbed, opType, at, after, loc) => {
		const subbeds = (0, _parse.parseExprParts)(subbed);
		return new _MsAst.SetSub(loc, object, subbeds, opType, memberSetKind(at), (0, _parse.parseExpr)(after));
	},
	      parseLocalMutate = (localsTokens, valueTokens, loc) => {
		const locals = (0, _parseLocalDeclares.parseLocalDeclaresJustNames)(localsTokens);
		_context.context.check(locals.length === 1, loc, 'TODO: LocalDestructureMutate');
		const name = locals[0].name;
		const value = (0, _parse.parseExpr)(valueTokens);
		return new _MsAst.LocalMutate(loc, name, value);
	},
	      parseAssign = (localsTokens, kind, valueTokens, loc) => {
		const locals = (0, _parseLocalDeclares2.default)(localsTokens);
		const value = parseAssignValue(kind, valueTokens);

		const isYield = kind === _Token.KW_Yield || kind === _Token.KW_YieldTo;
		if ((0, _util.isEmpty)(locals)) {
			_context.context.check(isYield, localsTokens.loc, 'Assignment to nothing');
			return value;
		} else {
			if (isYield) for (const _ of locals) _context.context.check(!_.isLazy(), _.loc, 'Can not yield to lazy variable.');

			const isObjAssign = kind === _Token.KW_ObjAssign;

			if (kind === _Token.KW_AssignMutable) for (let _ of locals) {
				_context.context.check(!_.isLazy(), _.loc, 'Lazy local can not be mutable.');
				_.kind = _MsAst.LD_Mutable;
			}

			const wrap = _ => isObjAssign ? new _MsAst.ObjEntryAssign(loc, _) : _;

			if (locals.length === 1) {
				const assignee = locals[0];
				const assign = new _MsAst.AssignSingle(loc, assignee, value);
				return wrap(assign);
			} else {
				const kind = locals[0].kind;
				for (const _ of locals) _context.context.check(_.kind === kind, _.loc, 'All locals of destructuring assignment must be of the same kind.');
				return wrap(new _MsAst.AssignDestructure(loc, locals, value, kind));
			}
		}
	},
	      parseAssignValue = (kind, valueTokens) => {
		const value = (0, _parse.parseExpr)(valueTokens);
		switch (kind) {
			case _Token.KW_Yield:
				return new _MsAst.Yield(value.loc, value);
			case _Token.KW_YieldTo:
				return new _MsAst.YieldTo(value.loc, value);
			default:
				return value;
		}
	},
	      parseAssert = (negate, tokens) => {
		(0, _context.checkNonEmpty)(tokens, () => `Expected something after ${ (0, _Token.keywordName)(_Token.KW_Assert) }.`);

		var _ifElse3 = (0, _util.ifElse)(tokens.opSplitOnceWhere(_ => (0, _Token.isKeyword)(_Token.KW_Throw, _)), _ref3 => {
			let before = _ref3.before;
			let after = _ref3.after;
			return [before, (0, _parse.parseExpr)(after)];
		}, () => [tokens, null]);

		var _ifElse32 = _slicedToArray(_ifElse3, 2);

		const condTokens = _ifElse32[0];
		const opThrown = _ifElse32[1];

		const parts = (0, _parse.parseExprParts)(condTokens);
		const cond = parts.length === 1 ? parts[0] : new _MsAst.Call(condTokens.loc, parts[0], (0, _util.tail)(parts));
		return new _MsAst.Assert(tokens.loc, negate, cond, opThrown);
	},
	      parseIgnore = tokens => {
		const ignored = tokens.map(_ => {
			if ((0, _Token.isKeyword)(_Token.KW_Focus, _)) return '_';else {
				_context.context.check(_ instanceof _Token.Name, _.loc, () => `Expected local name, not ${ _ }.`);
				return _.name;
			}
		});
		return new _MsAst.Ignore(tokens.loc, ignored);
	};
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhcnNlTGluZS5qcyIsInByaXZhdGUvcGFyc2UvcGFyc2VMaW5lLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttQkNzQmUsTUFBTSxJQUFJO0FBQ3hCLFFBQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQTtBQUMxQixRQUFNLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUE7O0FBRTFCLFFBQU0sTUFBTSxHQUFHLE1BQ2QsYUFqQk0sVUFBVSxFQWlCTCxJQUFJLEVBQUUsTUFBTSxDQUFDLDhCQUE4QixHQUFFLElBQUksRUFBQyxDQUFDLENBQUMsQ0FBQyxDQUFBOzs7QUFHakUsTUFBSSxJQUFJLG1CQTFCZ0QsT0FBTyxBQTBCcEMsRUFDMUIsUUFBUSxJQUFJLENBQUMsSUFBSTtBQUNoQixlQTVCNEUsU0FBUyxDQTRCdEUsQUFBQyxZQTNCbEIsWUFBWTtBQTRCVCxXQUFPLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxZQTVCL0IsWUFBWSxBQTRCb0MsRUFBRSxJQUFJLENBQUMsQ0FBQTtBQUFBLEFBQ3JELGVBNUJtQixXQUFXO0FBNkI3QixXQUFPLGtDQTdCVyxXQUFXLEVBNkJHLElBQUksQ0FBQyxDQUFBO0FBQUEsQUFDdEMsZUEvQnlDLFFBQVE7QUFnQ2hELFVBQU0sRUFBRSxDQUFBO0FBQ1IsV0FBTyxXQXRDOEQsS0FBSyxDQXNDekQsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFBO0FBQUEsQUFDN0IsZUFsQ21ELGVBQWU7QUFtQ2pFLFdBQU8sV0F4Q3FFLFlBQVksQ0F3Q2hFLE1BQU0sQ0FBQyxHQUFHLEVBQUUsV0FyQmhDLFNBQVMsRUFxQmlDLElBQUksQ0FBQyxDQUFDLENBQUE7QUFBQSxBQUNyRCxlQXBDb0UsU0FBUztBQXFDNUUsV0FBTyx5QkFBVSxLQUFLLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFBO0FBQUEsQUFDckMsZUF0QytFLFdBQVc7QUF1Q3pG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TzlCLEtBQUssQ0FBQyxDQUFDLG1CQTFPMEIsSUFBSSxBQTBPZCxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLHlCQUF5QixHQUFFLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQyxDQUFBO0FBQy9FLFdBQU8sQ0FBQyxDQUFDLElBQUksQ0FBQTtJQUNiO0dBQ0QsQ0FBQyxDQUFBO0FBQ0YsU0FBTyxXQXJQTyxNQUFNLENBcVBGLE1BQU0sQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLENBQUE7RUFDdEMsQ0FBQSIsImZpbGUiOiJwcml2YXRlL3BhcnNlL3BhcnNlTGluZS5qcyIsInNvdXJjZXNDb250ZW50IjpbbnVsbCwiaW1wb3J0IHtBc3NlcnQsIEFzc2lnblNpbmdsZSwgQXNzaWduRGVzdHJ1Y3R1cmUsIEJhZ0VudHJ5LCBCYWdFbnRyeU1hbnksIEJyZWFrLCBCcmVha1dpdGhWYWwsIENhbGwsXG5cdENvbmRpdGlvbmFsRG8sIElnbm9yZSwgTERfTXV0YWJsZSwgTG9jYWxBY2Nlc3MsIExvY2FsTXV0YXRlLCBNYXBFbnRyeSwgTWVtYmVyU2V0LFxuXHRPYmpFbnRyeUFzc2lnbiwgT2JqRW50cnlDb21wdXRlZCwgU0RfRGVidWdnZXIsIFNFVF9Jbml0LCBTRVRfSW5pdE11dGFibGUsIFNFVF9NdXRhdGUsIFNldFN1Yixcblx0U3BlY2lhbERvLCBTcGVjaWFsVmFsLCBTdXBlckNhbGxEbywgU1ZfTmFtZSwgVGhyb3csIFlpZWxkLCBZaWVsZFRvfSBmcm9tICcuLi9Nc0FzdCdcbmltcG9ydCB7R19CcmFja2V0LCBHX1F1b3RlLCBHX1NwYWNlLCBpc0dyb3VwLCBpc0tleXdvcmQsIEtleXdvcmQsIGtleXdvcmROYW1lLCBLV19Bc3NlcnQsXG5cdEtXX0Fzc2VydE5vdCwgS1dfQXNzaWduLCBLV19Bc3NpZ25NdXRhYmxlLCBLV19CcmVhaywgS1dfQnJlYWtXaXRoVmFsLCBLV19DYXNlRG8sIEtXX0RlYnVnZ2VyLFxuXHRLV19Eb3QsIEtXX0VsbGlwc2lzLCBLV19FeGNlcHREbywgS1dfRm9jdXMsIEtXX0ZvckRvLCBLV19JZkRvLCBLV19JZ25vcmUsIEtXX0xvY2FsTXV0YXRlLFxuXHRLV19NYXBFbnRyeSwgS1dfTmFtZSwgS1dfT2JqQXNzaWduLCBLV19QYXNzLCBLV19SZWdpb24sIEtXX1N1cGVyRG8sIEtXX1N3aXRjaERvLCBLV19UaHJvdyxcblx0S1dfVHlwZSwgS1dfVW5sZXNzRG8sIEtXX1lpZWxkLCBLV19ZaWVsZFRvLCBOYW1lfSBmcm9tICcuLi9Ub2tlbidcbmltcG9ydCB7aWZFbHNlLCBpc0VtcHR5LCBvcElmLCB0YWlsfSBmcm9tICcuLi91dGlsJ1xuaW1wb3J0IHtjaGVja0VtcHR5LCBjaGVja05vbkVtcHR5LCBjb250ZXh0LCB1bmV4cGVjdGVkfSBmcm9tICcuL2NvbnRleHQnXG5pbXBvcnQge2JlZm9yZUFuZEJsb2NrLCBwYXJzZUJsb2NrRG8sIHBhcnNlTGluZXNGcm9tQmxvY2t9IGZyb20gJy4vcGFyc2VCbG9jaydcbmltcG9ydCBwYXJzZUNhc2UgZnJvbSAnLi9wYXJzZUNhc2UnXG5pbXBvcnQgcGFyc2VFeGNlcHQgZnJvbSAnLi9wYXJzZUV4Y2VwdCdcbmltcG9ydCB7cGFyc2VGb3JEb30gZnJvbSAnLi9wYXJzZUZvcidcbmltcG9ydCBwYXJzZUxpbmUgZnJvbSAnLi9wYXJzZUxpbmUnXG5pbXBvcnQge3RyeVBhcnNlTmFtZX0gZnJvbSAnLi9wYXJzZU5hbWUnXG5pbXBvcnQgcGFyc2VMb2NhbERlY2xhcmVzLCB7cGFyc2VMb2NhbERlY2xhcmVzSnVzdE5hbWVzfSBmcm9tICcuL3BhcnNlTG9jYWxEZWNsYXJlcydcbmltcG9ydCBwYXJzZVF1b3RlIGZyb20gJy4vcGFyc2VRdW90ZSdcbmltcG9ydCB7cGFyc2VFeHByLCBwYXJzZUV4cHJQYXJ0cywgcGFyc2VTcGFjZWQsIHBhcnNlU3dpdGNofSBmcm9tICcuL3BhcnNlKidcbmltcG9ydCBTbGljZSBmcm9tICcuL1NsaWNlJ1xuXG5leHBvcnQgZGVmYXVsdCB0b2tlbnMgPT4ge1xuXHRjb25zdCBoZWFkID0gdG9rZW5zLmhlYWQoKVxuXHRjb25zdCByZXN0ID0gdG9rZW5zLnRhaWwoKVxuXG5cdGNvbnN0IG5vUmVzdCA9ICgpID0+XG5cdFx0Y2hlY2tFbXB0eShyZXN0LCAoKSA9PiBgRGlkIG5vdCBleHBlY3QgYW55dGhpbmcgYWZ0ZXIgJHtoZWFkfS5gKVxuXG5cdC8vIFdlIG9ubHkgZGVhbCB3aXRoIG11dGFibGUgZXhwcmVzc2lvbnMgaGVyZSwgb3RoZXJ3aXNlIHdlIGZhbGwgYmFjayB0byBwYXJzZUV4cHIuXG5cdGlmIChoZWFkIGluc3RhbmNlb2YgS2V5d29yZClcblx0XHRzd2l0Y2ggKGhlYWQua2luZCkge1xuXHRcdFx0Y2FzZSBLV19Bc3NlcnQ6IGNhc2UgS1dfQXNzZXJ0Tm90OlxuXHRcdFx0XHRyZXR1cm4gcGFyc2VBc3NlcnQoaGVhZC5raW5kID09PSBLV19Bc3NlcnROb3QsIHJlc3QpXG5cdFx0XHRjYXNlIEtXX0V4Y2VwdERvOlxuXHRcdFx0XHRyZXR1cm4gcGFyc2VFeGNlcHQoS1dfRXhjZXB0RG8sIHJlc3QpXG5cdFx0XHRjYXNlIEtXX0JyZWFrOlxuXHRcdFx0XHRub1Jlc3QoKVxuXHRcdFx0XHRyZXR1cm4gbmV3IEJyZWFrKHRva2Vucy5sb2MpXG5cdFx0XHRjYXNlIEtXX0JyZWFrV2l0aFZhbDpcblx0XHRcdFx0cmV0dXJuIG5ldyBCcmVha1dpdGhWYWwodG9rZW5zLmxvYywgcGFyc2VFeHByKHJlc3QpKVxuXHRcdFx0Y2FzZSBLV19DYXNlRG86XG5cdFx0XHRcdHJldHVybiBwYXJzZUNhc2UoZmFsc2UsIGZhbHNlLCByZXN0KVxuXHRcdFx0Y2FzZSBLV19EZWJ1Z2dlcjpcblx0XHRcdFx0bm9SZXN0KClcblx0XHRcdFx0cmV0dXJuIG5ldyBTcGVjaWFsRG8odG9rZW5zLmxvYywgU0RfRGVidWdnZXIpXG5cdFx0XHRjYXNlIEtXX0VsbGlwc2lzOlxuXHRcdFx0XHRyZXR1cm4gbmV3IEJhZ0VudHJ5TWFueSh0b2tlbnMubG9jLCBwYXJzZUV4cHIocmVzdCkpXG5cdFx0XHRjYXNlIEtXX0ZvckRvOlxuXHRcdFx0XHRyZXR1cm4gcGFyc2VGb3JEbyhyZXN0KVxuXHRcdFx0Y2FzZSBLV19JZ25vcmU6XG5cdFx0XHRcdHJldHVybiBwYXJzZUlnbm9yZShyZXN0KVxuXHRcdFx0Y2FzZSBLV19JZkRvOiBjYXNlIEtXX1VubGVzc0RvOiB7XG5cdFx0XHRcdGNvbnN0IFtiZWZvcmUsIGJsb2NrXSA9IGJlZm9yZUFuZEJsb2NrKHJlc3QpXG5cdFx0XHRcdHJldHVybiBuZXcgQ29uZGl0aW9uYWxEbyh0b2tlbnMubG9jLFxuXHRcdFx0XHRcdHBhcnNlRXhwcihiZWZvcmUpLFxuXHRcdFx0XHRcdHBhcnNlQmxvY2tEbyhibG9jayksXG5cdFx0XHRcdFx0aGVhZC5raW5kID09PSBLV19Vbmxlc3NEbylcblx0XHRcdH1cblx0XHRcdGNhc2UgS1dfT2JqQXNzaWduOlxuXHRcdFx0XHRyZXR1cm4gbmV3IEJhZ0VudHJ5KHRva2Vucy5sb2MsIHBhcnNlRXhwcihyZXN0KSlcblx0XHRcdGNhc2UgS1dfUGFzczpcblx0XHRcdFx0bm9SZXN0KClcblx0XHRcdFx0cmV0dXJuIFtdXG5cdFx0XHRjYXNlIEtXX1JlZ2lvbjpcblx0XHRcdFx0cmV0dXJuIHBhcnNlTGluZXNGcm9tQmxvY2sodG9rZW5zKVxuXHRcdFx0Y2FzZSBLV19TdXBlckRvOlxuXHRcdFx0XHRyZXR1cm4gbmV3IFN1cGVyQ2FsbERvKHRva2Vucy5sb2MsIHBhcnNlRXhwclBhcnRzKHJlc3QpKVxuXHRcdFx0Y2FzZSBLV19Td2l0Y2hEbzpcblx0XHRcdFx0cmV0dXJuIHBhcnNlU3dpdGNoKGZhbHNlLCBmYWxzZSwgcmVzdClcblx0XHRcdGNhc2UgS1dfVGhyb3c6XG5cdFx0XHRcdHJldHVybiBuZXcgVGhyb3codG9rZW5zLmxvYywgb3BJZighcmVzdC5pc0VtcHR5KCksICgpID0+IHBhcnNlRXhwcihyZXN0KSkpXG5cdFx0XHRjYXNlIEtXX05hbWU6XG5cdFx0XHRcdGlmIChpc0tleXdvcmQoS1dfT2JqQXNzaWduLCByZXN0LmhlYWQoKSkpIHtcblx0XHRcdFx0XHRjb25zdCByID0gcmVzdC50YWlsKClcblx0XHRcdFx0XHRjb25zdCB2YWwgPSByLmlzRW1wdHkoKSA/IG5ldyBTcGVjaWFsVmFsKHRva2Vucy5sb2MsIFNWX05hbWUpIDogcGFyc2VFeHByKHIpXG5cdFx0XHRcdFx0cmV0dXJuIE9iakVudHJ5Q29tcHV0ZWQubmFtZSh0b2tlbnMubG9jLCB2YWwpXG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gZWxzZSBmYWxsIHRocm91Z2hcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdC8vIGZhbGwgdGhyb3VnaFxuXHRcdH1cblxuXHRyZXR1cm4gaWZFbHNlKHRva2Vucy5vcFNwbGl0T25jZVdoZXJlKGlzTGluZVNwbGl0S2V5d29yZCksXG5cdFx0KHtiZWZvcmUsIGF0LCBhZnRlcn0pID0+IHBhcnNlQXNzaWduTGlrZShiZWZvcmUsIGF0LCBhZnRlciwgdG9rZW5zLmxvYyksXG5cdFx0KCkgPT4gcGFyc2VFeHByKHRva2VucykpXG59XG5cbmV4cG9ydCBjb25zdCBwYXJzZUxpbmVPckxpbmVzID0gdG9rZW5zID0+IHtcblx0Y29uc3QgXyA9IHBhcnNlTGluZSh0b2tlbnMpXG5cdHJldHVybiBfIGluc3RhbmNlb2YgQXJyYXkgPyBfIDogW19dXG59XG5cbmNvbnN0XG5cdGlzTGluZVNwbGl0S2V5d29yZCA9IHRva2VuID0+IHtcblx0XHRpZiAodG9rZW4gaW5zdGFuY2VvZiBLZXl3b3JkKVxuXHRcdFx0c3dpdGNoICh0b2tlbi5raW5kKSB7XG5cdFx0XHRcdGNhc2UgS1dfQXNzaWduOiBjYXNlIEtXX0Fzc2lnbk11dGFibGU6IGNhc2UgS1dfTG9jYWxNdXRhdGU6XG5cdFx0XHRcdGNhc2UgS1dfTWFwRW50cnk6IGNhc2UgS1dfT2JqQXNzaWduOiBjYXNlIEtXX1lpZWxkOiBjYXNlIEtXX1lpZWxkVG86XG5cdFx0XHRcdFx0cmV0dXJuIHRydWVcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2Vcblx0XHRcdH1cblx0XHRlbHNlXG5cdFx0XHRyZXR1cm4gZmFsc2Vcblx0fSxcblxuXHRwYXJzZUFzc2lnbkxpa2UgPSAoYmVmb3JlLCBhdCwgYWZ0ZXIsIGxvYykgPT4ge1xuXHRcdGNvbnN0IGtpbmQgPSBhdC5raW5kXG5cdFx0aWYgKGtpbmQgPT09IEtXX01hcEVudHJ5KVxuXHRcdFx0cmV0dXJuIG5ldyBNYXBFbnRyeShsb2MsIHBhcnNlRXhwcihiZWZvcmUpLCBwYXJzZUV4cHIoYWZ0ZXIpKVxuXG5cdFx0aWYgKGJlZm9yZS5zaXplKCkgPT09IDEpIHtcblx0XHRcdGNvbnN0IHRva2VuID0gYmVmb3JlLmhlYWQoKVxuXHRcdFx0Ly8gYGEuYiA9IGNgLCBgLmIgPSBjYCwgYGFbYl0gPSBjYFxuXHRcdFx0aWYgKGlzR3JvdXAoR19TcGFjZSwgdG9rZW4pKSB7XG5cdFx0XHRcdGNvbnN0IHNwYWNlZCA9IFNsaWNlLmdyb3VwKHRva2VuKVxuXHRcdFx0XHRjb25zdCBbdmFsdWUsIG9wVHlwZV0gPSBpZkVsc2Uoc3BhY2VkLm9wU3BsaXRPbmNlV2hlcmUoXyA9PiBpc0tleXdvcmQoS1dfVHlwZSwgXykpLFxuXHRcdFx0XHRcdCh7YmVmb3JlLCBhZnRlcn0pID0+IFtiZWZvcmUsIHBhcnNlRXhwcihhZnRlcildLFxuXHRcdFx0XHRcdCgpID0+IFtzcGFjZWQsIG51bGxdKVxuXG5cdFx0XHRcdGNvbnN0IGxhc3QgPSB2YWx1ZS5sYXN0KClcblx0XHRcdFx0Y29uc3Qgb2JqZWN0ID0gb2JqID0+IHtcblx0XHRcdFx0XHRpZiAob2JqID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0XHRvYmogPSB2YWx1ZS5ydGFpbCgpXG5cdFx0XHRcdFx0cmV0dXJuIG9iai5pc0VtcHR5KCkgPyBMb2NhbEFjY2Vzcy50aGlzKG9iai5sb2MpIDogcGFyc2VTcGFjZWQob2JqKVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGlzS2V5d29yZChLV19Eb3QsIHZhbHVlLm5leHRUb0xhc3QoKSkpIHtcblx0XHRcdFx0XHRjb25zdCBuYW1lID0gdHJ5UGFyc2VOYW1lKGxhc3QpXG5cdFx0XHRcdFx0aWYgKG5hbWUgIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHNldCA9IG9iamVjdCh2YWx1ZS5ydGFpbCgpLnJ0YWlsKCkpXG5cdFx0XHRcdFx0XHRyZXR1cm4gcGFyc2VNZW1iZXJTZXQoc2V0LCBuYW1lLCBvcFR5cGUsIGF0LCBhZnRlciwgbG9jKVxuXHRcdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdFx0dW5leHBlY3RlZChsYXN0KVxuXHRcdFx0XHR9IGVsc2UgaWYgKGlzR3JvdXAoR19CcmFja2V0LCBsYXN0KSlcblx0XHRcdFx0XHRyZXR1cm4gcGFyc2VTdWJTZXQob2JqZWN0KCksIFNsaWNlLmdyb3VwKGxhc3QpLCBvcFR5cGUsIGF0LCBhZnRlciwgbG9jKVxuXHRcdFx0Ly8gYFwiMVwiLiAxYFxuXHRcdFx0fSBlbHNlIGlmIChpc0dyb3VwKEdfUXVvdGUsIHRva2VuKSAmJiBraW5kID09PSBLV19PYmpBc3NpZ24pXG5cdFx0XHRcdHJldHVybiBuZXcgT2JqRW50cnlDb21wdXRlZChsb2MsIHBhcnNlUXVvdGUoU2xpY2UuZ3JvdXAodG9rZW4pKSwgcGFyc2VFeHByKGFmdGVyKSlcblx0XHR9XG5cblx0XHRyZXR1cm4ga2luZCA9PT0gS1dfTG9jYWxNdXRhdGUgP1xuXHRcdFx0cGFyc2VMb2NhbE11dGF0ZShiZWZvcmUsIGFmdGVyLCBsb2MpIDpcblx0XHRcdHBhcnNlQXNzaWduKGJlZm9yZSwga2luZCwgYWZ0ZXIsIGxvYylcblx0fSxcblxuXHRwYXJzZU1lbWJlclNldCA9IChvYmplY3QsIG5hbWUsIG9wVHlwZSwgYXQsIGFmdGVyLCBsb2MpID0+XG5cdFx0bmV3IE1lbWJlclNldChsb2MsIG9iamVjdCwgbmFtZSwgb3BUeXBlLCBtZW1iZXJTZXRLaW5kKGF0KSwgcGFyc2VFeHByKGFmdGVyKSksXG5cdG1lbWJlclNldEtpbmQgPSBhdCA9PiB7XG5cdFx0c3dpdGNoIChhdC5raW5kKSB7XG5cdFx0XHRjYXNlIEtXX0Fzc2lnbjpcblx0XHRcdFx0cmV0dXJuIFNFVF9Jbml0XG5cdFx0XHRjYXNlIEtXX0Fzc2lnbk11dGFibGU6XG5cdFx0XHRcdHJldHVybiBTRVRfSW5pdE11dGFibGVcblx0XHRcdGNhc2UgS1dfTG9jYWxNdXRhdGU6XG5cdFx0XHRcdHJldHVybiBTRVRfTXV0YXRlXG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR1bmV4cGVjdGVkKGF0KVxuXHRcdH1cblx0fSxcblxuXHRwYXJzZVN1YlNldCA9IChvYmplY3QsIHN1YmJlZCwgb3BUeXBlLCBhdCwgYWZ0ZXIsIGxvYykgPT4ge1xuXHRcdGNvbnN0IHN1YmJlZHMgPSBwYXJzZUV4cHJQYXJ0cyhzdWJiZWQpXG5cdFx0cmV0dXJuIG5ldyBTZXRTdWIobG9jLCBvYmplY3QsIHN1YmJlZHMsIG9wVHlwZSwgbWVtYmVyU2V0S2luZChhdCksIHBhcnNlRXhwcihhZnRlcikpXG5cdH0sXG5cblx0cGFyc2VMb2NhbE11dGF0ZSA9IChsb2NhbHNUb2tlbnMsIHZhbHVlVG9rZW5zLCBsb2MpID0+IHtcblx0XHRjb25zdCBsb2NhbHMgPSBwYXJzZUxvY2FsRGVjbGFyZXNKdXN0TmFtZXMobG9jYWxzVG9rZW5zKVxuXHRcdGNvbnRleHQuY2hlY2sobG9jYWxzLmxlbmd0aCA9PT0gMSwgbG9jLCAnVE9ETzogTG9jYWxEZXN0cnVjdHVyZU11dGF0ZScpXG5cdFx0Y29uc3QgbmFtZSA9IGxvY2Fsc1swXS5uYW1lXG5cdFx0Y29uc3QgdmFsdWUgPSBwYXJzZUV4cHIodmFsdWVUb2tlbnMpXG5cdFx0cmV0dXJuIG5ldyBMb2NhbE11dGF0ZShsb2MsIG5hbWUsIHZhbHVlKVxuXHR9LFxuXG5cdHBhcnNlQXNzaWduID0gKGxvY2Fsc1Rva2Vucywga2luZCwgdmFsdWVUb2tlbnMsIGxvYykgPT4ge1xuXHRcdGNvbnN0IGxvY2FscyA9IHBhcnNlTG9jYWxEZWNsYXJlcyhsb2NhbHNUb2tlbnMpXG5cdFx0Y29uc3QgdmFsdWUgPSBwYXJzZUFzc2lnblZhbHVlKGtpbmQsIHZhbHVlVG9rZW5zKVxuXG5cdFx0Y29uc3QgaXNZaWVsZCA9IGtpbmQgPT09IEtXX1lpZWxkIHx8IGtpbmQgPT09IEtXX1lpZWxkVG9cblx0XHRpZiAoaXNFbXB0eShsb2NhbHMpKSB7XG5cdFx0XHRjb250ZXh0LmNoZWNrKGlzWWllbGQsIGxvY2Fsc1Rva2Vucy5sb2MsICdBc3NpZ25tZW50IHRvIG5vdGhpbmcnKVxuXHRcdFx0cmV0dXJuIHZhbHVlXG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChpc1lpZWxkKVxuXHRcdFx0XHRmb3IgKGNvbnN0IF8gb2YgbG9jYWxzKVxuXHRcdFx0XHRcdGNvbnRleHQuY2hlY2soIV8uaXNMYXp5KCksIF8ubG9jLCAnQ2FuIG5vdCB5aWVsZCB0byBsYXp5IHZhcmlhYmxlLicpXG5cblx0XHRcdGNvbnN0IGlzT2JqQXNzaWduID0ga2luZCA9PT0gS1dfT2JqQXNzaWduXG5cblx0XHRcdGlmIChraW5kID09PSBLV19Bc3NpZ25NdXRhYmxlKVxuXHRcdFx0XHRmb3IgKGxldCBfIG9mIGxvY2Fscykge1xuXHRcdFx0XHRcdGNvbnRleHQuY2hlY2soIV8uaXNMYXp5KCksIF8ubG9jLCAnTGF6eSBsb2NhbCBjYW4gbm90IGJlIG11dGFibGUuJylcblx0XHRcdFx0XHRfLmtpbmQgPSBMRF9NdXRhYmxlXG5cdFx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgd3JhcCA9IF8gPT4gaXNPYmpBc3NpZ24gPyBuZXcgT2JqRW50cnlBc3NpZ24obG9jLCBfKSA6IF9cblxuXHRcdFx0aWYgKGxvY2Fscy5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0Y29uc3QgYXNzaWduZWUgPSBsb2NhbHNbMF1cblx0XHRcdFx0Y29uc3QgYXNzaWduID0gbmV3IEFzc2lnblNpbmdsZShsb2MsIGFzc2lnbmVlLCB2YWx1ZSlcblx0XHRcdFx0cmV0dXJuIHdyYXAoYXNzaWduKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3Qga2luZCA9IGxvY2Fsc1swXS5raW5kXG5cdFx0XHRcdGZvciAoY29uc3QgXyBvZiBsb2NhbHMpXG5cdFx0XHRcdFx0Y29udGV4dC5jaGVjayhfLmtpbmQgPT09IGtpbmQsIF8ubG9jLFxuXHRcdFx0XHRcdFx0J0FsbCBsb2NhbHMgb2YgZGVzdHJ1Y3R1cmluZyBhc3NpZ25tZW50IG11c3QgYmUgb2YgdGhlIHNhbWUga2luZC4nKVxuXHRcdFx0XHRyZXR1cm4gd3JhcChuZXcgQXNzaWduRGVzdHJ1Y3R1cmUobG9jLCBsb2NhbHMsIHZhbHVlLCBraW5kKSlcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cGFyc2VBc3NpZ25WYWx1ZSA9IChraW5kLCB2YWx1ZVRva2VucykgPT4ge1xuXHRcdGNvbnN0IHZhbHVlID0gcGFyc2VFeHByKHZhbHVlVG9rZW5zKVxuXHRcdHN3aXRjaCAoa2luZCkge1xuXHRcdFx0Y2FzZSBLV19ZaWVsZDpcblx0XHRcdFx0cmV0dXJuIG5ldyBZaWVsZCh2YWx1ZS5sb2MsIHZhbHVlKVxuXHRcdFx0Y2FzZSBLV19ZaWVsZFRvOlxuXHRcdFx0XHRyZXR1cm4gbmV3IFlpZWxkVG8odmFsdWUubG9jLCB2YWx1ZSlcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdH1cblx0fSxcblxuXHRwYXJzZUFzc2VydCA9IChuZWdhdGUsIHRva2VucykgPT4ge1xuXHRcdGNoZWNrTm9uRW1wdHkodG9rZW5zLCAoKSA9PiBgRXhwZWN0ZWQgc29tZXRoaW5nIGFmdGVyICR7a2V5d29yZE5hbWUoS1dfQXNzZXJ0KX0uYClcblxuXHRcdGNvbnN0IFtjb25kVG9rZW5zLCBvcFRocm93bl0gPVxuXHRcdFx0aWZFbHNlKHRva2Vucy5vcFNwbGl0T25jZVdoZXJlKF8gPT4gaXNLZXl3b3JkKEtXX1Rocm93LCBfKSksXG5cdFx0XHRcdCh7YmVmb3JlLCBhZnRlcn0pID0+IFtiZWZvcmUsIHBhcnNlRXhwcihhZnRlcildLFxuXHRcdFx0XHQoKSA9PiBbdG9rZW5zLCBudWxsXSlcblxuXHRcdGNvbnN0IHBhcnRzID0gcGFyc2VFeHByUGFydHMoY29uZFRva2Vucylcblx0XHRjb25zdCBjb25kID0gcGFydHMubGVuZ3RoID09PSAxID8gcGFydHNbMF0gOiBuZXcgQ2FsbChjb25kVG9rZW5zLmxvYywgcGFydHNbMF0sIHRhaWwocGFydHMpKVxuXHRcdHJldHVybiBuZXcgQXNzZXJ0KHRva2Vucy5sb2MsIG5lZ2F0ZSwgY29uZCwgb3BUaHJvd24pXG5cdH0sXG5cblx0cGFyc2VJZ25vcmUgPSB0b2tlbnMgPT4ge1xuXHRcdGNvbnN0IGlnbm9yZWQgPSB0b2tlbnMubWFwKF8gPT4ge1xuXHRcdFx0aWYgKGlzS2V5d29yZChLV19Gb2N1cywgXykpXG5cdFx0XHRcdHJldHVybiAnXydcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRjb250ZXh0LmNoZWNrKF8gaW5zdGFuY2VvZiBOYW1lLCBfLmxvYywgKCkgPT4gYEV4cGVjdGVkIGxvY2FsIG5hbWUsIG5vdCAke199LmApXG5cdFx0XHRcdHJldHVybiBfLm5hbWVcblx0XHRcdH1cblx0XHR9KVxuXHRcdHJldHVybiBuZXcgSWdub3JlKHRva2Vucy5sb2MsIGlnbm9yZWQpXG5cdH0iXSwic291cmNlUm9vdCI6Ii9zcmMifQ==
