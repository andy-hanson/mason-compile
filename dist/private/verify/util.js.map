{"version":3,"sources":["private/verify/util.js","private/verify/util.ts"],"names":[],"mappings":"AAAA,CAAC,UAAU,OAAO,EAAE;AAChB,QAAI,OAAO,MAAM,KAAK,QAAQ,IAAI,OAAO,MAAM,CAAC,OAAO,KAAK,QAAQ,EAAE;AAClE,YAAI,CAAC,GAAG,OAAO,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC,AAAC,IAAI,CAAC,KAAK,SAAS,EAAE,MAAM,CAAC,OAAO,GAAG,CAAC,CAAC;KAC9E,MACI,IAAI,OAAO,MAAM,KAAK,UAAU,IAAI,MAAM,CAAC,GAAG,EAAE;AACjD,cAAM,CAAC,CAAC,SAAS,EAAE,SAAS,EAAE,OAAO,EAAE,YAAY,EAAE,UAAU,EAAE,WAAW,CAAC,EAAE,OAAO,CAAC,CAAC;KAC3F;CACJ,CAAA,CAAE,UAAU,OAAO,EAAE,OAAO,EAAE;AAC3B,gBAAY,CAAC;;ACRjB,QAAA,IAAA,GAAA,OAAA,CAA0B,OAC1B,CAAC,CADgC;AAEjC,QAAA,SAAA,GAAA,OAAA,CAAoB,YACpB,CAAC,CAD+B;AAChC,QAAA,OAAA,GAAA,OAAA,CAA4D,UAC5D,CAAC,CADqE;AACtE,QAAA,SAAA,GAAA,OAAA,CAAwC,WACxC,CAAC,CADkD;AAInD,aAAA,eAAA,CAAgC,YAA0B,EAAA;AACzD,iBAAA,CAAA,UAAU,CAAC,GAAG,CAAC,YAAY,CAAC,CAAA;KAC5B;AAFe,WAAA,CAAA,eAAe,GAAA,eAE9B,CAAA;AAMD,aAAA,sBAAA,CAAuC,YAA0B,EAAA;AAChE,YAAI,YAAY,CAAC,IAAI,KAAK,GAAG,EAC5B,eAAe,CAAC,YAAY,CAAC,CAAA;KAC9B;AAHe,WAAA,CAAA,sBAAsB,GAAA,sBAGrC,CAAA;AAED,aAAA,UAAA,CAA2B,IAAkB,EAAE,EAAM,EAAA;AACpD,aAAK,MAAM,CAAC,IAAI,IAAI,EACnB,CAAC,CAAC,MAAM,CAAC,EAAE,CAAC,CAAA;KACb;AAHe,WAAA,CAAA,UAAU,GAAA,UAGzB,CAAA;AAGD,aAAA,qBAAA,CAAsC,IAAyB,EAAA;AAC9D,aAAK,MAAM,CAAC,IAAI,IAAI,EAGnB,CAAC,CAAC,MAAM,CAAC,CAAC,YAAY,OAAA,CAAA,MAAM,GAAG,IAAI,GAAG,CAAM,CAAC,CAAA;KAC9C;AALe,WAAA,CAAA,qBAAqB,GAAA,qBAKpC,CAAA;AAOD,aAAA,QAAA,CAAyB,KAAgB,EAAE,EAAM,EAAA;AAChD,YAAI,IAAA,CAAA,OAAO,CAAC,KAAK,CAAC,EACjB,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC,CAAA;KACjB;AAHe,WAAA,CAAA,QAAQ,GAAA,QAGvB,CAAA;AAGD,aAAA,UAAA,CAA2B,CAAO,EAAA;AACjC,YAAI,OAAO,CAAC,KAAK,QAAQ,EACxB,CAAC,CAAC,MAAM,CAAC,CAAM,CAAC,CAAA;KACjB;AAHe,WAAA,CAAA,UAAU,GAAA,UAGzB,CAAA;AAED,aAAA,OAAA,CAAwB,IAAW,EAAA;AAClC,iBAAA,CAAA,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,SAAA,CAAA,IAAI,CAAC,CAAA;KAC7B;AAFe,WAAA,CAAA,OAAO,GAAA,OAEtB,CAAA;AAED,aAAA,aAAA,CAA8B,YAA0B,EAAE,YAAqC,EAAA;AAC9F,iBAAA,CAAA,KAAK,CAAC,CAAC,YAAY,CAAC,MAAM,EAAE,YAAY,CAAC,GAAG,EAAE,YAAY,CAAC,CAAA;KAC3D;AAFe,WAAA,CAAA,aAAa,GAAA,aAE5B,CAAA;CDNA,CAAC,CAAC","file":"private/verify/util.js","sourcesContent":["(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", 'op/Op', '../context', '../MsAst', './context'], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    var Op_1 = require('op/Op');\n    var context_1 = require('../context');\n    var MsAst_1 = require('../MsAst');\n    var context_2 = require('./context');\n    function makeUseOptional(localDeclare) {\n        context_2.okToNotUse.add(localDeclare);\n    }\n    exports.makeUseOptional = makeUseOptional;\n    function makeUseOptionalIfFocus(localDeclare) {\n        if (localDeclare.name === '_')\n            makeUseOptional(localDeclare);\n    }\n    exports.makeUseOptionalIfFocus = makeUseOptionalIfFocus;\n    function verifyEach(asts, sk) {\n        for (const _ of asts)\n            _.verify(sk);\n    }\n    exports.verifyEach = verifyEach;\n    function verifyEachValOrSpread(asts) {\n        for (const _ of asts)\n            _.verify(_ instanceof MsAst_1.Spread ? null : 1);\n    }\n    exports.verifyEachValOrSpread = verifyEachValOrSpread;\n    function verifyOp(opAst, sk) {\n        if (Op_1.nonNull(opAst))\n            opAst.verify(sk);\n    }\n    exports.verifyOp = verifyOp;\n    function verifyName(_) {\n        if (typeof _ !== 'string')\n            _.verify(1);\n    }\n    exports.verifyName = verifyName;\n    function setName(expr) {\n        context_2.results.names.set(expr, context_2.name);\n    }\n    exports.setName = setName;\n    function verifyNotLazy(localDeclare, errorMessage) {\n        context_1.check(!localDeclare.isLazy, localDeclare.loc, errorMessage);\n    }\n    exports.verifyNotLazy = verifyNotLazy;\n});\n","import Op, {nonNull} from 'op/Op'\nimport Language from '../languages/Language'\nimport {check} from '../context'\nimport MsAst, {Val, LocalDeclare, Name, Named, Spread} from '../MsAst'\nimport {name, okToNotUse, results} from './context'\nimport SK from './SK'\n\n/** Mark a LocalDeclare as OK to not use. */\nexport function makeUseOptional(localDeclare: LocalDeclare): void {\n\tokToNotUse.add(localDeclare)\n}\n\n/**\nFor Asts that use the focus by default, make it OK to not use the variable when it's the focus.\n(If the user specified a name, they intended to use it.)\n*/\nexport function makeUseOptionalIfFocus(localDeclare: LocalDeclare): void {\n\tif (localDeclare.name === '_')\n\t\tmakeUseOptional(localDeclare)\n}\n\nexport function verifyEach(asts: Array<MsAst>, sk: SK): void {\n\tfor (const _ of asts)\n\t\t_.verify(sk)\n}\n\n/** Verify values, accepting Spreads. */\nexport function verifyEachValOrSpread(asts: Array<Val | Spread>) {\n\tfor (const _ of asts)\n\t\t// `null` signifies to Spread that we recognize it\n\t\t// todo: just have special function for verify spread\n\t\t_.verify(_ instanceof Spread ? null : SK.Val)\n}\n\n/**\nVerify opAst if it exists.\n@param opAst\n@param [arg] Argument to pass to _.verify. Usually an [[SK]].\n*/\nexport function verifyOp(opAst: Op<MsAst>, sk: SK): void {\n\tif (nonNull(opAst))\n\t\topAst.verify(sk)\n}\n\n/** Verify if it's not a string. */\nexport function verifyName(_: Name): void {\n\tif (typeof _ !== 'string')\n\t\t_.verify(SK.Val)\n}\n\nexport function setName(expr: Named): void {\n\tresults.names.set(expr, name)\n}\n\nexport function verifyNotLazy(localDeclare: LocalDeclare, errorMessage: (_: Language) => string): void {\n\tcheck(!localDeclare.isLazy, localDeclare.loc, errorMessage)\n}\n"],"sourceRoot":"/source/"}