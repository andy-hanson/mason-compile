if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports', 'module', './util'], function (exports, module, _util) {
	'use strict';

	class VerifyResults {
		constructor() {
			// LocalAccess -> LocalDeclare.
			// Needed because lazy accesses must be compiled differently.
			this.localAccessToDeclare = new Map();
			// LocalDeclare -> Array[LocalAccess].
			// Debug locals will not be output if not in debug mode.
			this.localDeclareToAccesses = new Map();
			// Maps Class/Fun to name if one is appropriate.
			// Maps *every* SV_Name to the nearest name.
			this.names = new Map();
			// String -> Set.
			// For each path, the names of each builtin imported.
			// Like the inverse of context.opts.builtinNameToPath,
			// but only includes names actually used.
			this.builtinPathToNames = new Map();
			// Values are either MethodImpl or the string 'constructor'
			this.superCallToMethod = new Map();
			// Links a constructor to its super! call.
			this.constructorToSuper = new Map();
		}

		isDebugLocal(localDeclare) {
			return this.localDeclareToInfo.get(localDeclare).isInDebug;
		}

		isAccessed(localDeclare) {
			const info = this.localDeclareToInfo.get(localDeclare);
			return !((0, _util.isEmpty)(info.debugAccesses) && (0, _util.isEmpty)(info.nonDebugAccesses));
		}

		localDeclareForAccess(localAccess) {
			return this.localAccessToDeclare.get(localAccess);
		}

		name(expr) {
			return this.names.get(expr);
		}

		opName(expr) {
			const x = this.names.get(expr);
			return x === undefined ? null : x;
		}
	}

	module.exports = VerifyResults;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlZlcmlmeVJlc3VsdHMuanMiLCJwcml2YXRlL1ZlcmlmeVJlc3VsdHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQ0VlLE9BQU0sYUFBYSxDQUFDO0FBQ2xDLGFBQVcsR0FBRzs7O0FBR2IsT0FBSSxDQUFDLG9CQUFvQixHQUFHLElBQUksR0FBRyxFQUFFLENBQUE7OztBQUdyQyxPQUFJLENBQUMsc0JBQXNCLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQTs7O0FBR3ZDLE9BQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQTs7Ozs7QUFLdEIsT0FBSSxDQUFDLGtCQUFrQixHQUFHLElBQUksR0FBRyxFQUFFLENBQUE7O0FBRW5DLE9BQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFBOztBQUVsQyxPQUFJLENBQUMsa0JBQWtCLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQTtHQUNuQzs7QUFFRCxjQUFZLENBQUMsWUFBWSxFQUFFO0FBQzFCLFVBQU8sSUFBSSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQyxTQUFTLENBQUE7R0FDMUQ7O0FBRUQsWUFBVSxDQUFDLFlBQVksRUFBRTtBQUN4QixTQUFNLElBQUksR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFBO0FBQ3RELFVBQU8sRUFBRSxVQTlCSCxPQUFPLEVBOEJJLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxVQTlCbEMsT0FBTyxFQThCbUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUEsQUFBQyxDQUFBO0dBQ3ZFOztBQUVELHVCQUFxQixDQUFDLFdBQVcsRUFBRTtBQUNsQyxVQUFPLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUE7R0FDakQ7O0FBRUQsTUFBSSxDQUFDLElBQUksRUFBRTtBQUNWLFVBQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUE7R0FDM0I7O0FBRUQsUUFBTSxDQUFDLElBQUksRUFBRTtBQUNaLFNBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFBO0FBQzlCLFVBQU8sQ0FBQyxLQUFLLFNBQVMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxDQUFBO0dBQ2pDO0VBQ0Q7O2tCQTNDb0IsYUFBYSIsImZpbGUiOiJwcml2YXRlL1ZlcmlmeVJlc3VsdHMuanMiLCJzb3VyY2VzQ29udGVudCI6W251bGwsImltcG9ydCB7aXNFbXB0eX0gZnJvbSAnLi91dGlsJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWZXJpZnlSZXN1bHRzIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0Ly8gTG9jYWxBY2Nlc3MgLT4gTG9jYWxEZWNsYXJlLlxuXHRcdC8vIE5lZWRlZCBiZWNhdXNlIGxhenkgYWNjZXNzZXMgbXVzdCBiZSBjb21waWxlZCBkaWZmZXJlbnRseS5cblx0XHR0aGlzLmxvY2FsQWNjZXNzVG9EZWNsYXJlID0gbmV3IE1hcCgpXG5cdFx0Ly8gTG9jYWxEZWNsYXJlIC0+IEFycmF5W0xvY2FsQWNjZXNzXS5cblx0XHQvLyBEZWJ1ZyBsb2NhbHMgd2lsbCBub3QgYmUgb3V0cHV0IGlmIG5vdCBpbiBkZWJ1ZyBtb2RlLlxuXHRcdHRoaXMubG9jYWxEZWNsYXJlVG9BY2Nlc3NlcyA9IG5ldyBNYXAoKVxuXHRcdC8vIE1hcHMgQ2xhc3MvRnVuIHRvIG5hbWUgaWYgb25lIGlzIGFwcHJvcHJpYXRlLlxuXHRcdC8vIE1hcHMgKmV2ZXJ5KiBTVl9OYW1lIHRvIHRoZSBuZWFyZXN0IG5hbWUuXG5cdFx0dGhpcy5uYW1lcyA9IG5ldyBNYXAoKVxuXHRcdC8vIFN0cmluZyAtPiBTZXQuXG5cdFx0Ly8gRm9yIGVhY2ggcGF0aCwgdGhlIG5hbWVzIG9mIGVhY2ggYnVpbHRpbiBpbXBvcnRlZC5cblx0XHQvLyBMaWtlIHRoZSBpbnZlcnNlIG9mIGNvbnRleHQub3B0cy5idWlsdGluTmFtZVRvUGF0aCxcblx0XHQvLyBidXQgb25seSBpbmNsdWRlcyBuYW1lcyBhY3R1YWxseSB1c2VkLlxuXHRcdHRoaXMuYnVpbHRpblBhdGhUb05hbWVzID0gbmV3IE1hcCgpXG5cdFx0Ly8gVmFsdWVzIGFyZSBlaXRoZXIgTWV0aG9kSW1wbCBvciB0aGUgc3RyaW5nICdjb25zdHJ1Y3Rvcidcblx0XHR0aGlzLnN1cGVyQ2FsbFRvTWV0aG9kID0gbmV3IE1hcCgpXG5cdFx0Ly8gTGlua3MgYSBjb25zdHJ1Y3RvciB0byBpdHMgc3VwZXIhIGNhbGwuXG5cdFx0dGhpcy5jb25zdHJ1Y3RvclRvU3VwZXIgPSBuZXcgTWFwKClcblx0fVxuXG5cdGlzRGVidWdMb2NhbChsb2NhbERlY2xhcmUpIHtcblx0XHRyZXR1cm4gdGhpcy5sb2NhbERlY2xhcmVUb0luZm8uZ2V0KGxvY2FsRGVjbGFyZSkuaXNJbkRlYnVnXG5cdH1cblxuXHRpc0FjY2Vzc2VkKGxvY2FsRGVjbGFyZSkge1xuXHRcdGNvbnN0IGluZm8gPSB0aGlzLmxvY2FsRGVjbGFyZVRvSW5mby5nZXQobG9jYWxEZWNsYXJlKVxuXHRcdHJldHVybiAhKGlzRW1wdHkoaW5mby5kZWJ1Z0FjY2Vzc2VzKSAmJiBpc0VtcHR5KGluZm8ubm9uRGVidWdBY2Nlc3NlcykpXG5cdH1cblxuXHRsb2NhbERlY2xhcmVGb3JBY2Nlc3MobG9jYWxBY2Nlc3MpIHtcblx0XHRyZXR1cm4gdGhpcy5sb2NhbEFjY2Vzc1RvRGVjbGFyZS5nZXQobG9jYWxBY2Nlc3MpXG5cdH1cblxuXHRuYW1lKGV4cHIpIHtcblx0XHRyZXR1cm4gdGhpcy5uYW1lcy5nZXQoZXhwcilcblx0fVxuXG5cdG9wTmFtZShleHByKSB7XG5cdFx0Y29uc3QgeCA9IHRoaXMubmFtZXMuZ2V0KGV4cHIpXG5cdFx0cmV0dXJuIHggPT09IHVuZGVmaW5lZCA/IG51bGwgOiB4XG5cdH1cbn1cbiJdLCJzb3VyY2VSb290IjoiL3NyYyJ9
