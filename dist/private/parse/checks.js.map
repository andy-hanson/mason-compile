{"version":3,"sources":["private/parse/checks.js","private/parse/checks.ts"],"names":[],"mappings":"AAAA,CAAC,UAAU,OAAO,EAAE;AAChB,QAAI,OAAO,MAAM,KAAK,QAAQ,IAAI,OAAO,MAAM,CAAC,OAAO,KAAK,QAAQ,EAAE;AAClE,YAAI,CAAC,GAAG,OAAO,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC,AAAC,IAAI,CAAC,KAAK,SAAS,EAAE,MAAM,CAAC,OAAO,GAAG,CAAC,CAAC;KAC9E,MACI,IAAI,OAAO,MAAM,KAAK,UAAU,IAAI,MAAM,CAAC,GAAG,EAAE;AACjD,cAAM,CAAC,CAAC,SAAS,EAAE,SAAS,EAAE,YAAY,EAAE,UAAU,CAAC,EAAE,OAAO,CAAC,CAAC;KACrE;CACJ,CAAA,CAAE,UAAU,OAAO,EAAE,OAAO,EAAE;AAC3B,gBAAY,CAAC;;ACNjB,QAAA,SAAA,GAAA,OAAA,CAA0B,YAC1B,CAAC,CADqC;AAEtC,QAAA,OAAA,GAAA,OAAA,CAA4D,UAC5D,CAAC,CADqE;AAItE,aAAA,UAAA,CAA2B,MAAoB,EAAE,OAAgC,EAAA;AAChF,iBAAA,CAAA,KAAK,CAAC,MAAM,CAAC,OAAO,EAAE,EAAE,MAAM,CAAC,GAAG,EAAE,OAAO,CAAC,CAAA;KAC5C;AAFe,WAAA,CAAA,UAAU,GAAA,UAEzB,CAAA;AAGD,aAAA,aAAA,CAA8B,MAAoB,EAAE,OAAgC,EAAA;AACnF,iBAAA,CAAA,KAAK,CAAC,CAAC,MAAM,CAAC,OAAO,EAAE,EAAE,MAAM,CAAC,GAAG,EAAE,OAAO,CAAC,CAAA;KAC7C;AAFe,WAAA,CAAA,aAAa,GAAA,aAE5B,CAAA;AAGD,aAAA,YAAA,CAA6B,OAAiB,EAAE,KAAY,EAAA;AAC3D,iBAAA,CAAA,KAAK,CAAC,OAAA,CAAA,SAAS,CAAC,OAAO,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC,CAAA;KAC5E;AAFe,WAAA,CAAA,YAAY,GAAA,YAE3B,CAAA;AAGD,aAAA,UAAA,CAA2B,KAAY,EAAA;AACtC,eAAO,SAAA,CAAA,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,IAAI,OAAA,CAAA,iBAAiB,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,YAAY,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAA;KACnG;AAFe,WAAA,CAAA,UAAU,GAAA,UAEzB,CAAA;CDEA,CAAC,CAAC","file":"private/parse/checks.js","sourcesContent":["(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", '../context', '../Token'], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    var context_1 = require('../context');\n    var Token_1 = require('../Token');\n    function checkEmpty(tokens, message) {\n        context_1.check(tokens.isEmpty(), tokens.loc, message);\n    }\n    exports.checkEmpty = checkEmpty;\n    function checkNonEmpty(tokens, message) {\n        context_1.check(!tokens.isEmpty(), tokens.loc, message);\n    }\n    exports.checkNonEmpty = checkNonEmpty;\n    function checkKeyword(keyword, token) {\n        context_1.check(Token_1.isKeyword(keyword, token), token.loc, _ => _.expectedKeyword(keyword));\n    }\n    exports.checkKeyword = checkKeyword;\n    function unexpected(token) {\n        return context_1.fail(token.loc, _ => Token_1.isReservedKeyword(token) ? _.reservedWord(token) : _.unexpected(token));\n    }\n    exports.unexpected = unexpected;\n});\n","import Op from 'op/Op'\nimport CompileError from '../../CompileError'\nimport {check, fail} from '../context'\nimport Language from '../languages/Language'\nimport Token, {isKeyword, isReservedKeyword, Keywords} from '../Token'\nimport Slice from './Slice'\n\n/** Throw if `tokens` has content. */\nexport function checkEmpty(tokens: Slice<Token>, message: (_: Language) => string): void {\n\tcheck(tokens.isEmpty(), tokens.loc, message)\n}\n\n/** Throw if `tokens` is empty. */\nexport function checkNonEmpty(tokens: Slice<Token>, message: (_: Language) => string): void {\n\tcheck(!tokens.isEmpty(), tokens.loc, message)\n}\n\n/** Throw if the token is not the expected keyword. */\nexport function checkKeyword(keyword: Keywords, token: Token): void {\n\tcheck(isKeyword(keyword, token), token.loc, _ => _.expectedKeyword(keyword))\n}\n\n/** CompileError about encountering an unparseable token. */\nexport function unexpected(token: Token): CompileError {\n\treturn fail(token.loc, _ => isReservedKeyword(token) ? _.reservedWord(token) : _.unexpected(token))\n}\n"],"sourceRoot":"/source/"}