{"version":3,"sources":["private/languages/english.js","private/languages/english.ts"],"names":[],"mappings":"AAAA,CAAC,UAAU,OAAV,EAAmB;AAChB,QAAI,OAAO,MAAP,KAAkB,QAAlB,IAA8B,OAAO,OAAO,OAAP,KAAmB,QAA1B,EAAoC;AAClE,YAAI,IAAI,QAAQ,OAAR,EAAiB,OAAjB,CAAJ,CAD8D,IAC3B,MAAM,SAAN,EAAiB,OAAO,OAAP,GAAiB,CAAjB,CAArB;KADvC,MAGK,IAAI,OAAO,MAAP,KAAkB,UAAlB,IAAgC,OAAO,GAAP,EAAY;AACjD,eAAO,CAAC,SAAD,EAAY,SAAZ,EAAuB,SAAvB,EAAkC,QAAlC,CAAP,EAAoD,OAApD,EADiD;KAAhD;CAJR,CAAD,CAOG,UAAU,OAAV,EAAmB,OAAnB,EAA4B;AAC3B,iBAD2B;;ACF/B,UAAA,SAAA,QAAqB,SAArB,CAAA,CDE+B;ACA/B,UAAA,SAAA,QAAgD,QAAhD,CAAA,CDA+B;ACE/B,UAAM,UAAoB;AAGzB,0BACC,CAAA,GAAG,OAAA,IAAA,CAAK,GAAL,CAAH,EAAY,qBAAZ,GAAoC,OAAA,IAAA,CAAK,GAAL,CAApC,EAA6C,EAA7C,GAAkD,OAAA,IAAA,CAAK,GAAL,CAAlD,EAA2D,YAA3D,CADD;AAEA,yBAAiB,UAChB,CAAA,yCAAA,GAA4C,MAA5C,EAAkD,CAAlD,CADgB;AAEjB,2BACC,6CADD;AAEA,oBACC,cADD;AAEA,oBACC,oBADD;AAEA,8BAAsB,CAAC,MAAD,EAAoB,QAApB,KACrB,CAAA,gBAAA,GAAmB,OAAO,SAAP,CAAiB,QAAjB,EAAnB,EAA8C,kBAA9C,GAAmE,SAAS,QAAT,EAAnE,EAAsF,CAAtF,CADqB;AAEtB,wBACC,wBADD;AAEA,uBACC,gCADD;AAEA,kCACC,6CADD;AAEA,sBAAc,QACb,CAAA,mBAAA,GAAsB,OAAA,QAAA,CAAS,IAAT,CAAtB,EAAoC,CAApC,CADa;AAEd,4BAAoB,QACnB,CAAA,oCAAA,GAAuC,OAAA,IAAA,CAAK,CAAA,CAAA,GAAI,IAAJ,EAAQ,CAAb,CAAvC,EAAuD,CAAvD,CADmB;AAEpB,uBACC,kCADD;AAEA,4BACC,sEADD;AAEA,4BACC,CAAA,kDAAA,GAAqD,OAAA,IAAA,CAAK,IAAL,CAArD,EAA+D,CAA/D,CADD;AAEA,uBACC,uBADD;AAEA,uBACC,iBADD;AAKA,kBACC,CAAA,GAAG,OAAA,WAAA,CAAG,EAAH,CAAH,EAAoB,2BAApB,CADD;AAEA,yBAAiB,QAChB,CAAA,GAAG,OAAA,WAAA,CAAG,IAAH,CAAH,EAAW,yCAAX,CADgB;AAEjB,iBACC,CAAA,GAAG,OAAA,WAAA,CAAG,GAAH,CAAH,EAAmB,yBAAnB,CADD;AAEA,qBACC,CAAA,GAAG,OAAA,WAAA,CAAG,GAAH,CAAH,EAAuB,0CAAvB,CADD;AAEA,uBACC,wBADD;AAEA,iBACC,CAAA,4BAAA,GAA+B,OAAA,WAAA,CAAG,EAAH,CAA/B,EAA8C,CAA9C,CADD;AAEA,8BACC,CAAA,yBAAA,GAA4B,OAAA,WAAA,CAAG,GAAH,CAA5B,EAA6C,MAA7C,CADD;AAEA,4BACC,uEADD;AAEA,6BACC,CAAA,yBAAA,GAA4B,OAAA,WAAA,CAAG,EAAH,CAA5B,EAA+C,CAA/C,CADD;AAEA,4BACC,CAAA,yBAAA,GAA4B,OAAA,WAAA,CAAG,EAAH,CAA5B,EAA8C,CAA9C,CADD;AAEA,uBACC,6BADD;AAEA,4BACC,sCADD;AAEA,kCACC,mCADD;AAEA,yBAAiB,WAChB,CAAA,SAAA,GAAY,OAAA,WAAA,CAAG,OAAH,CAAZ,EAAuB,CADP;AAEjB,6BACC,wCADD;AAEA,0BACC,sCADD;AAEA,2BAAmB,SAClB,CAAA,2BAAA,GAA8B,KAA9B,EAAmC,CAAnC,CADkB;AAEnB,sBAAc,SACb,CAAA,qBAAA,GAAwB,KAAxB,EAA6B,CADhB;AAEd,qBACC,CAAA,YAAA,GAAe,OAAA,IAAA,CAAK,IAAL,CAAf,EAAyB,CAD1B;AAEA,+BAAuB,WACtB,CAAA,uBAAA,GAA0B,OAAA,WAAA,CAAG,OAAH,CAA1B,EAAqC,kCAArC,GAA0E,OAAA,WAAA,CAAG,GAAH,CAA1E,EAA4F,CAA5F,CADsB;AAEvB,6BACC,CAAA,SAAA,GAAY,OAAA,QAAA,CAAS,EAAT,CAAZ,EAAiC,yBAAjC,CADD;AAEA,uBACC,CAAA,IAAA,GAAO,OAAA,WAAA,CAAG,GAAH,CAAP,EAAwB,qBAAxB,CADD;AAEA,6BACC,0BADD;AAEA,oBACC,2EADD;AAEA,uBACC,CAAA,GAAG,OAAA,WAAA,CAAG,GAAH,CAAH,EAAqB,4BAArB,CADD;AAEA,sBACC,CAAA,qBAAA,GAAwB,OAAA,WAAA,CAAG,GAAH,CAAxB,EAAuC,KAAvC,GAA+C,OAAA,WAAA,CAAG,GAAH,CAA/C,EAAoE,CAApE,CADD;AAEA,0BAAkB,QACjB,CAAA,GAAG,OAAA,WAAA,CAAG,IAAH,CAAH,EAAW,qBAAX,CADiB;AAElB,6BACC,CAAA,uBAAA,GAA0B,OAAA,WAAA,CAAG,GAAH,CAA1B,EAA8C,CAA9C,CADD;AAEA,2BACC,CAAA,IAAA,GAAO,OAAA,IAAA,CAAK,OAAL,CAAP,EAAoB,MAApB,GAA6B,OAAA,IAAA,CAAK,MAAL,CAA7B,EAAyC,CAAzC,CADD;AAEA,sBAAc,SACb,CAAA,cAAA,GAAiB,KAAjB,EAAsB,CAAtB,CADa;AAEd,yBACC,CAAA,SAAA,GAAY,OAAA,WAAA,CAAG,GAAH,CAAZ,EAA4B,IAA5B,GAAmC,OAAA,IAAA,CAAK,IAAL,CAAnC,EAA6C,OAA7C,GAAuD,OAAA,WAAA,CAAG,GAAH,CAAvD,EAAyE,CAD1E;AAEA,wBACC,sBADD;AAEA,uBACC,mBADD;AAEA,+BACC,8BADD;AAEA,oBAAY,SACX,CAAA,WAAA,GAAc,KAAd,EAAmB,CAAnB,CADW;AAEZ,yBAAiB,SAChB,CAAA,8BAAA,GAAiC,KAAjC,EAAsC,CAAtC,CADgB;AAEjB,iCACC,CAAA,WAAA,GAAc,OAAA,WAAA,CAAG,GAAH,CAAd,EAAmC,iCAAnC,CADD;AAEA,6BAAqB,QACpB,CAAA,gCAAA,GAAmC,OAAA,WAAA,CAAG,IAAH,CAAnC,EAA2C,WAA3C,CADoB;AAErB,6BACC,CAAA,gCAAA,GAAmC,OAAA,WAAA,CAAG,GAAH,CAAnC,EAAoD,cAApD,CADD;AAKA,qBACC,sFADD;AAEA,wBACC,CAAA,cAAA,GAAiB,OAAA,WAAA,CAAG,GAAH,CAAjB,EAAiC,iBAAjC,IACA,CAAA,KAAA,GAAQ,OAAA,WAAA,CAAG,EAAH,CAAR,EAA0B,6BAA1B,CADA;AAED,sBAAc,mBACb,CAAA,6CAAA,GAAgD,eAAhD,EAA+D,CADlD;AAEd,mBAAW,UAAe;AACzB,gBAAI;AAEH,oBAAI,MAAJ,CAAW,MAAX,EAFG;AAIH,uBAAA,MAAA,CAAO,KAAP,EAJG;AAKH,uBAAO,EAAP,CALG;aAAJ,CAME,OAAO,GAAP,EAAY;AACb,uBAAO,IAAI,OAAJ,CADM;aAAZ;SAPQ;AAWX,2BACC,qCADD;AAEA,4BACC,CAAA,GAAG,OAAA,WAAA,CAAG,EAAH,CAAH,EAAqB,kBAArB,GAA0C,OAAA,WAAA,CAAG,GAAH,CAA1C,EAA0D,8BAA1D,CADD;AAEA,yBACC,CAAA,GAAG,OAAA,WAAA,CAAG,GAAH,CAAH,EAAmB,6BAAnB,GAAmD,OAAA,WAAA,CAAG,EAAH,CAAnD,EAAqE,cAArE,CADD;AAEA,0BACC,CAAA,GAAG,OAAA,WAAA,CAAG,EAAH,CAAH,EAAqB,IAArB,GAA4B,OAAA,WAAA,CAAG,GAAH,CAA5B,EAA+C,oBAA/C,CADD;AAEA,2BACC,uEADD;AAEA,4BACC,2DADD;AAEA,4BACC,kDADD;AAEA,yBAAiB,CAAC,IAAD,EAAe,OAAf,KAChB,CAAA,GAAG,OAAA,IAAA,CAAK,IAAL,CAAH,EAAa,qBAAb,GAAqC,OAArC,EAA4C,CAD5B;AAEjB,sBAAc,OACb,CAAA,cAAA,GAAiB,GAAjB,EAAoB,CADP;AAEd,wBAAgB,QACf,CAAA,QAAA,GAAW,OAAA,IAAA,CAAK,IAAL,CAAX,EAAqB,sCAArB,CADe;AAEhB,2BACC,CAAA,GAAG,OAAA,WAAA,CAAG,GAAH,CAAH,EAAoB,mBAApB,GAA0C,OAAA,WAAA,CAAG,EAAH,CAA1C,EAA4D,CAA5D,CADD;AAEA,oBACC,0CADD;AAEA,4BACC,CAAA,GAAG,OAAA,WAAA,CAAG,GAAH,CAAH,EAAwB,+CAAxB,CADD;AAEA,wBACC,CAAA,OAAA,GAAU,OAAA,WAAA,CAAG,EAAH,CAAV,EAA4B,2BAA5B,CADD;AAEA,wBACC,gBADD;AAEA,2BACC,CAAA,oDAAA,GAAuD,OAAA,WAAA,CAAG,GAAH,CAAvD,EAAwE,CAAxE,CADD;AAEA,4BACC,CAAA,yBAAA,GAA4B,OAAA,WAAA,CAAG,GAAH,CAA5B,EAA4C,KAA5C,GAAoD,OAAA,IAAA,CAAK,IAAL,CAApD,EAA8D,CAA9D,CADD;AAEA,wBAAgB,QACf,CAAA,OAAA,GAAU,OAAA,WAAA,CAAG,IAAH,CAAV,EAAkB,+BAAlB,CADe;AAEhB,sBAAc,QACb,CAAA,cAAA,GAAiB,OAAA,IAAA,CAAK,IAAL,CAAjB,EAA2B,CAA3B,CADa;AAEd,qBACC,+BADD;AAEA,wBACC,oCADD;AAEA,2BAAmB,CAAC,IAAD,EAAe,WAAf,KAClB,CAAA,MAAA,GAAS,OAAA,IAAA,CAAK,IAAL,CAAT,EAAmB,wBAAnB,GAA8C,OAAA,IAAA,CAAK,WAAL,CAA9C,EAA+D,CAA/D,CADkB;AAEnB,0BACC,0EADD;AAEA,wBACC,CAAA,4BAAA,GAA+B,OAAA,WAAA,CAAG,GAAH,CAA/B,EAAiD,gBAAjD,CADD;AAEA,8BACC,CAAA,GAAG,OAAA,WAAA,CAAG,GAAH,CAAH,EAAqB,4CAArB,CADD;AAEA,qBACC,CAAA,yBAAA,GAA4B,OAAA,WAAA,CAAG,GAAH,CAA5B,EAA8C,CAD/C;AAEA,0BACC,CAAA,GAAG,OAAA,WAAA,CAAG,GAAH,CAAH,EAAqB,qBAArB,CADD;AAEA,qBAAa,QACZ,CAAA,sBAAA,GAAyB,OAAA,IAAA,CAAK,IAAL,CAAzB,EAAmC,CAAnC,CADY;AAEb,uBACC,CAAA,GAAG,OAAA,WAAA,CAAG,GAAH,CAAH,EAAsB,WAAtB,GAAoC,OAAA,WAAA,CAAG,EAAH,CAApC,EAAsD,IAAtD,GAA6D,OAAA,WAAA,CAAG,GAAH,CAA7D,EAAiF,CAAjF,CADD;AAEA,0BACC,yDADD;KAnMK,CDFyB;ACwM/B,WAAA,cAAA,CAAA,OAAA,EAAA,YAAA,EAAA,EAAA,OAAA,IAAA,EAAA,EDxM+B;AA0G3B,YAAQ,OAAR,GC8FW,OD9FX,CA1G2B;CAA5B,CAPH","file":"private/languages/english.js","sourcesContent":["(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", '../util', './util'], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    const util_1 = require('../util');\n    const util_2 = require('./util');\n    const english = {\n        badInterpolation: `${util_2.code('#')} must be followed by ${util_2.code('(')}, ${util_2.code('#')}, or a name.`,\n        badSpacedIndent: (indent) => `Indentation spaces must be a multiple of ${indent}.`,\n        commentNeedsSpace: 'A comment should start with a space or tab.',\n        emptyBlock: 'Empty block.',\n        extraSpace: 'Unnecessary space.',\n        mismatchedGroupClose: (actual, expected) => `Trying to close ${actual.prototype.showType()}, but last opened ${expected.showType()}.`,\n        noLeadingSpace: 'Line begins in a space',\n        nonLeadingTab: 'Tab may only be used to indent',\n        noNewlineInInterpolation: 'Quote interpolation cannot contain newline.',\n        reservedChar: (char) => `Reserved character ${util_2.showChar(char)}.`,\n        suggestSimpleQuote: (name) => `Quoted text could be a simple quote ${util_2.code(`'${name}`)}.`,\n        tooMuchIndent: 'Line is indented more than once.',\n        tooMuchIndentQuote: 'Indented quote must have exactly one more indent than previous line.',\n        trailingDocComment: `Doc comment must go on its own line. Did you mean ${util_2.code('||')}?`,\n        trailingSpace: 'Line ends in a space.',\n        unclosedQuote: 'Unclosed quote.',\n        argsCond: `${util_2.showKeyword(95)} takes exactly 3 arguments.`,\n        argsConditional: (kind) => `${util_2.showKeyword(kind)} with no block takes exactly 2 arguments.`,\n        argsDel: `${util_2.showKeyword(100)} takes only one argument.`,\n        argsTraitDo: `${util_2.showKeyword(168)} takes 2 arguments: implementor and trait.`,\n        assignNothing: 'Assignment to nothing.',\n        asToken: `Expected only 1 token after ${util_2.showKeyword(86)}.`,\n        caseSwitchNeedsParts: `Must have at least 1 non-${util_2.showKeyword(105)} test.`,\n        destructureAllLazy: 'All locals of destructuring assignment must all lazy or all non-lazy.',\n        expectedAfterAssert: `Expected something after ${util_2.showKeyword(87)}.`,\n        expectedAfterColon: `Expected something after ${util_2.showKeyword(97)}.`,\n        expectedBlock: 'Expected an indented block.',\n        expectedExpression: 'Expected an expression, got nothing.',\n        expectedImportModuleName: 'Expected a module name to import.',\n        expectedKeyword: (keyword) => `Expected ${util_2.showKeyword(keyword)}`,\n        expectedMethodSplit: 'Expected a function keyword somewhere.',\n        expectedOneLocal: 'Expected only one local declaration.',\n        expectedLocalName: (token) => `Expected a local name, not ${token}.`,\n        expectedName: (token) => `Expected a name, not ${token}`,\n        extraParens: `Unnecessary ${util_2.code('()')}`,\n        funFocusArgIsImplicit: (keyword) => `Nothing may come after ${util_2.showKeyword(keyword)}; function argument is implicitly ${util_2.showKeyword(110)}.`,\n        implicitFunctionDot: `Function ${util_2.showChar(46)} is implicit for methods.`,\n        infiniteRange: `Use ${util_2.showKeyword(104)} for infinite ranges.`,\n        invalidImportModule: 'Not a valid module name.',\n        methodName: 'Method name may only be one token (including a parenthesized expression).',\n        noImportFocus: `${util_2.showKeyword(110)} not allowed as import name.`,\n        noMyOverride: `Method can't be both ${util_2.showKeyword(135)} and ${util_2.showKeyword(155)}.`,\n        noSpecialKeyword: (kind) => `${util_2.showKeyword(kind)} is not allowed here.`,\n        nothingAfterFinally: `Nothing may come after ${util_2.showKeyword(109)}.`,\n        parensOutsideCall: `Use ${util_2.code('(a b)')}, not ${util_2.code('a(b)')}.`,\n        reservedWord: (token) => `Reserved word ${token}.`,\n        tokenAfterSuper: `Expected ${util_2.showKeyword(102)} or ${util_2.code('()')} after ${util_2.showKeyword(161)}`,\n        todoForPattern: 'TODO: pattern in for',\n        todoLazyField: 'TODO: lazy fields',\n        todoMutateDestructure: 'TODO: LocalDestructureMutate',\n        unexpected: (token) => `Unexpected ${token}.`,\n        unexpectedAfter: (token) => `Did not expect anything after ${token}.`,\n        unexpectedAfterImportDo: `This is an ${util_2.showKeyword(131)}, so you can't import any values.`,\n        unexpectedAfterKind: (kind) => `Did not expect anything between ${util_2.showKeyword(kind)} and block.`,\n        unexpectedAfterPoly: `Did not expect anything between ${util_2.showKeyword(158)} and function.`,\n        ambiguousSK: 'Can\\'t tell if this is a statement. Some parts are statements but others are values.',\n        ambiguousForSK: `Can't tell if ${util_2.showKeyword(111)} is a statement. ` +\n            `Some ${util_2.showKeyword(91)}s have a value, others don't.`,\n        argsOperator: (numProvidedArgs) => `Operator should have multiple arguments, got ${numProvidedArgs}`,\n        badRegExp: (source) => {\n            try {\n                new RegExp(source);\n                util_1.assert(false);\n                return '';\n            }\n            catch (err) {\n                return err.message;\n            }\n        },\n        blockNeedsContent: 'Value block must have some content.',\n        breakCantHaveValue: `${util_2.showKeyword(91)} with value needs ${util_2.showKeyword(111)} to be in expression position.`,\n        breakNeedsValue: `${util_2.showKeyword(111)} in expression position must ${util_2.showKeyword(91)} with a value.`,\n        breakValInForBag: `${util_2.showKeyword(91)} in ${util_2.showKeyword(113)} may not have value.`,\n        cantDetermineName: 'Expression must be placed in a position where name can be determined.',\n        cantInferBlockKind: 'Block has mixed bag/map/obj entries — can not infer type.',\n        doFuncCantHaveType: 'Function with return type must return something.',\n        duplicateImport: (name, prevLoc) => `${util_2.code(name)} already imported at ${prevLoc}`,\n        duplicateKey: (key) => `Duplicate key ${key}`,\n        duplicateLocal: (name) => `A local ${util_2.code(name)} already exists and can't be shadowed.`,\n        elseRequiresCatch: `${util_2.showKeyword(105)} must come after a ${util_2.showKeyword(94)}.`,\n        exportName: 'Module export must have a constant name.',\n        forAsyncNeedsAsync: `${util_2.showKeyword(112)} as statement must be inside an async function.`,\n        misplacedAwait: `Cannot ${util_2.showKeyword(90)} outside of async function.`,\n        misplacedBreak: 'Not in a loop.',\n        misplacedSpreadDo: `Can not spread here. Did you forget the space after ${util_2.showKeyword(104)}?`,\n        misplacedSpreadVal: `Can only spread in call, ${util_2.showKeyword(137)}, or ${util_2.code('[]')}.`,\n        misplacedYield: (kind) => `Cannot ${util_2.showKeyword(kind)} outside of generator function.`,\n        missingLocal: (name) => `No such local ${util_2.code(name)}.`,\n        noLazyCatch: 'Caught error can not be lazy.',\n        noLazyIteratee: 'Iteration element can not be lazy.',\n        overriddenBuiltin: (name, builtinPath) => `Local ${util_2.code(name)} overrides builtin from ${util_2.code(builtinPath)}.`,\n        statementAsValue: 'This can only be used as a statement, but appears in expression context.',\n        superForbidden: `Class has no superclass, so ${util_2.showKeyword(161)} is not allowed.`,\n        superMustBeStatement: `${util_2.showKeyword(161)} in constructor must appear as a statement.'`,\n        superNeeded: `Constructor must contain ${util_2.showKeyword(161)}`,\n        superNeedsMethod: `${util_2.showKeyword(161)} must be in a method.`,\n        unusedLocal: (name) => `Unused local variable ${util_2.code(name)}.`,\n        uselessExcept: `${util_2.showKeyword(106)} must have ${util_2.showKeyword(94)} or ${util_2.showKeyword(109)}.`,\n        valueAsStatement: 'Value appears in statement context, so it does nothing.'\n    };\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = english;\n});\n","import Loc from 'esast/lib/Loc'\nimport Char from 'typescript-char/Char'\nimport Token from '../token/Token'\nimport Group, {GroupType} from '../token/Group'\nimport {Keywords} from '../token/Keyword'\nimport {assert} from '../util'\nimport Language from './Language'\nimport {code, showChar, showKeyword as kw} from './util'\n\nconst english: Language = {\n\t// Lex:\n\n\tbadInterpolation:\n\t\t`${code('#')} must be followed by ${code('(')}, ${code('#')}, or a name.`,\n\tbadSpacedIndent: (indent: number): string =>\n\t\t`Indentation spaces must be a multiple of ${indent}.`,\n\tcommentNeedsSpace:\n\t\t'A comment should start with a space or tab.',\n\temptyBlock:\n\t\t'Empty block.',\n\textraSpace:\n\t\t'Unnecessary space.',\n\tmismatchedGroupClose: (actual: GroupType, expected: Group<Token>): string =>\n\t\t`Trying to close ${actual.prototype.showType()}, but last opened ${expected.showType()}.`,\n\tnoLeadingSpace:\n\t\t'Line begins in a space',\n\tnonLeadingTab:\n\t\t'Tab may only be used to indent',\n\tnoNewlineInInterpolation:\n\t\t'Quote interpolation cannot contain newline.',\n\treservedChar: (char: Char): string =>\n\t\t`Reserved character ${showChar(char)}.`,\n\tsuggestSimpleQuote: (name: string): string =>\n\t\t`Quoted text could be a simple quote ${code(`'${name}`)}.`,\n\ttooMuchIndent:\n\t\t'Line is indented more than once.',\n\ttooMuchIndentQuote:\n\t\t'Indented quote must have exactly one more indent than previous line.',\n\ttrailingDocComment:\n\t\t`Doc comment must go on its own line. Did you mean ${code('||')}?`,\n\ttrailingSpace:\n\t\t'Line ends in a space.',\n\tunclosedQuote:\n\t\t'Unclosed quote.',\n\n\t// Parse:\n\n\targsCond:\n\t\t`${kw(Keywords.Cond)} takes exactly 3 arguments.`,\n\targsConditional: (kind: Keywords): string =>\n\t\t`${kw(kind)} with no block takes exactly 2 arguments.`,\n\targsDel:\n\t\t`${kw(Keywords.Del)} takes only one argument.`,\n\targsTraitDo:\n\t\t`${kw(Keywords.TraitDo)} takes 2 arguments: implementor and trait.`,\n\tassignNothing:\n\t\t'Assignment to nothing.',\n\tasToken:\n\t\t`Expected only 1 token after ${kw(Keywords.As)}.`,\n\tcaseSwitchNeedsParts:\n\t\t`Must have at least 1 non-${kw(Keywords.Else)} test.`,\n\tdestructureAllLazy:\n\t\t'All locals of destructuring assignment must all lazy or all non-lazy.',\n\texpectedAfterAssert:\n\t\t`Expected something after ${kw(Keywords.Assert)}.`,\n\texpectedAfterColon:\n\t\t`Expected something after ${kw(Keywords.Colon)}.`,\n\texpectedBlock:\n\t\t'Expected an indented block.',\n\texpectedExpression:\n\t\t'Expected an expression, got nothing.',\n\texpectedImportModuleName:\n\t\t'Expected a module name to import.',\n\texpectedKeyword: (keyword: Keywords): string =>\n\t\t`Expected ${kw(keyword)}`,\n\texpectedMethodSplit:\n\t\t'Expected a function keyword somewhere.',\n\texpectedOneLocal:\n\t\t'Expected only one local declaration.',\n\texpectedLocalName: (token: Token): string =>\n\t\t`Expected a local name, not ${token}.`,\n\texpectedName: (token: Token): string =>\n\t\t`Expected a name, not ${token}`,\n\textraParens:\n\t\t`Unnecessary ${code('()')}`,\n\tfunFocusArgIsImplicit: (keyword: Keywords): string =>\n\t\t`Nothing may come after ${kw(keyword)}; function argument is implicitly ${kw(Keywords.Focus)}.`,\n\timplicitFunctionDot:\n\t\t`Function ${showChar(Char.Period)} is implicit for methods.`,\n\tinfiniteRange:\n\t\t`Use ${kw(Keywords.Dot3)} for infinite ranges.`,\n\tinvalidImportModule:\n\t\t'Not a valid module name.',\n\tmethodName:\n\t\t'Method name may only be one token (including a parenthesized expression).',\n\tnoImportFocus:\n\t\t`${kw(Keywords.Focus)} not allowed as import name.`,\n\tnoMyOverride:\n\t\t`Method can't be both ${kw(Keywords.My)} and ${kw(Keywords.Override)}.`,\n\tnoSpecialKeyword: (kind: Keywords): string =>\n\t\t`${kw(kind)} is not allowed here.`,\n\tnothingAfterFinally:\n\t\t`Nothing may come after ${kw(Keywords.Finally)}.`,\n\tparensOutsideCall:\n\t\t`Use ${code('(a b)')}, not ${code('a(b)')}.`,\n\treservedWord: (token: Token): string =>\n\t\t`Reserved word ${token}.`,\n\ttokenAfterSuper:\n\t\t`Expected ${kw(Keywords.Dot)} or ${code('()')} after ${kw(Keywords.Super)}`,\n\ttodoForPattern:\n\t\t'TODO: pattern in for',\n\ttodoLazyField:\n\t\t'TODO: lazy fields',\n\ttodoMutateDestructure:\n\t\t'TODO: LocalDestructureMutate',\n\tunexpected: (token: Token): string =>\n\t\t`Unexpected ${token}.`,\n\tunexpectedAfter: (token: Token): string =>\n\t\t`Did not expect anything after ${token}.`,\n\tunexpectedAfterImportDo:\n\t\t`This is an ${kw(Keywords.ImportDo)}, so you can't import any values.`,\n\tunexpectedAfterKind: (kind: Keywords): string =>\n\t\t`Did not expect anything between ${kw(kind)} and block.`,\n\tunexpectedAfterPoly:\n\t\t`Did not expect anything between ${kw(Keywords.Poly)} and function.`,\n\n\t// Verify:\n\n\tambiguousSK:\n\t\t'Can\\'t tell if this is a statement. Some parts are statements but others are values.',\n\tambiguousForSK:\n\t\t`Can't tell if ${kw(Keywords.For)} is a statement. ` +\n\t\t`Some ${kw(Keywords.Break)}s have a value, others don't.`,\n\targsOperator: (numProvidedArgs: number): string =>\n\t\t`Operator should have multiple arguments, got ${numProvidedArgs}`,\n\tbadRegExp: (source: string): string => {\n\t\ttry {\n\t\t\t/* tslint:disable:no-unused-expression */\n\t\t\tnew RegExp(source)\n\t\t\t// This should only be called for bad regexp...\n\t\t\tassert(false)\n\t\t\treturn ''\n\t\t} catch (err) {\n\t\t\treturn err.message\n\t\t}\n\t},\n\tblockNeedsContent:\n\t\t'Value block must have some content.',\n\tbreakCantHaveValue:\n\t\t`${kw(Keywords.Break)} with value needs ${kw(Keywords.For)} to be in expression position.`,\n\tbreakNeedsValue:\n\t\t`${kw(Keywords.For)} in expression position must ${kw(Keywords.Break)} with a value.`,\n\tbreakValInForBag:\n\t\t`${kw(Keywords.Break)} in ${kw(Keywords.ForBag)} may not have value.`,\n\tcantDetermineName:\n\t\t'Expression must be placed in a position where name can be determined.',\n\tcantInferBlockKind:\n\t\t'Block has mixed bag/map/obj entries — can not infer type.',\n\tdoFuncCantHaveType:\n\t\t'Function with return type must return something.',\n\tduplicateImport: (name: string, prevLoc: Loc): string =>\n\t\t`${code(name)} already imported at ${prevLoc}`,\n\tduplicateKey: (key: string): string =>\n\t\t`Duplicate key ${key}`,\n\tduplicateLocal: (name: string): string =>\n\t\t`A local ${code(name)} already exists and can't be shadowed.`,\n\telseRequiresCatch:\n\t\t`${kw(Keywords.Else)} must come after a ${kw(Keywords.Catch)}.`,\n\texportName:\n\t\t'Module export must have a constant name.',\n\tforAsyncNeedsAsync:\n\t\t`${kw(Keywords.ForAsync)} as statement must be inside an async function.`,\n\tmisplacedAwait:\n\t\t`Cannot ${kw(Keywords.Await)} outside of async function.`,\n\tmisplacedBreak:\n\t\t'Not in a loop.',\n\tmisplacedSpreadDo:\n\t\t`Can not spread here. Did you forget the space after ${kw(Keywords.Dot3)}?`,\n\tmisplacedSpreadVal:\n\t\t`Can only spread in call, ${kw(Keywords.New)}, or ${code('[]')}.`,\n\tmisplacedYield: (kind: Keywords): string =>\n\t\t`Cannot ${kw(kind)} outside of generator function.`,\n\tmissingLocal: (name: string): string =>\n\t\t`No such local ${code(name)}.`,\n\tnoLazyCatch:\n\t\t'Caught error can not be lazy.',\n\tnoLazyIteratee:\n\t\t'Iteration element can not be lazy.',\n\toverriddenBuiltin: (name: string, builtinPath: string): string =>\n\t\t`Local ${code(name)} overrides builtin from ${code(builtinPath)}.`,\n\tstatementAsValue:\n\t\t'This can only be used as a statement, but appears in expression context.',\n\tsuperForbidden:\n\t\t`Class has no superclass, so ${kw(Keywords.Super)} is not allowed.`,\n\tsuperMustBeStatement:\n\t\t`${kw(Keywords.Super)} in constructor must appear as a statement.'`,\n\tsuperNeeded:\n\t\t`Constructor must contain ${kw(Keywords.Super)}`,\n\tsuperNeedsMethod:\n\t\t`${kw(Keywords.Super)} must be in a method.`,\n\tunusedLocal: (name: string): string =>\n\t\t`Unused local variable ${code(name)}.`,\n\tuselessExcept:\n\t\t`${kw(Keywords.Except)} must have ${kw(Keywords.Catch)} or ${kw(Keywords.Finally)}.`,\n\tvalueAsStatement:\n\t\t'Value appears in statement context, so it does nothing.'\n}\nexport default english\n"],"sourceRoot":"/source/"}