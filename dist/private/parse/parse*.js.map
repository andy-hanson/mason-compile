{"version":3,"sources":["private/parse/parse*.js","private/parse/parse*.ts"],"names":[],"mappings":"AAAA,CAAC,UAAU,OAAO,EAAE;AAChB,QAAI,OAAO,MAAM,KAAK,QAAQ,IAAI,OAAO,MAAM,CAAC,OAAO,KAAK,QAAQ,EAAE;AAClE,YAAI,CAAC,GAAG,OAAO,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC,AAAC,IAAI,CAAC,KAAK,SAAS,EAAE,MAAM,CAAC,OAAO,GAAG,CAAC,CAAC;KAC9E,MACI,IAAI,OAAO,MAAM,KAAK,UAAU,IAAI,MAAM,CAAC,GAAG,EAAE;AACjD,cAAM,CAAC,CAAC,SAAS,EAAE,SAAS,CAAC,EAAE,OAAO,CAAC,CAAC;KAC3C;CACJ,CAAA,CAAE,UAAU,OAAO,EAAE,OAAO,EAAE;AAC3B,gBAAY,CAAC;;ACUjB,aAAA,IAAA,CAAqB,CAAM,EAAA;AAC1B,eAAA,CAAA,WAAW,GAAG,CAAC,CAAC,WAAW,CAAA;AAC3B,eAAA,CAAA,UAAU,GAAG,CAAC,CAAC,UAAU,CAAA;AACzB,eAAA,CAAA,WAAW,GAAG,CAAC,CAAC,WAAW,CAAA;AAC3B,eAAA,CAAA,SAAS,GAAG,CAAC,CAAC,SAAS,CAAA;AACvB,eAAA,CAAA,cAAc,GAAG,CAAC,CAAC,cAAc,CAAA;AACjC,eAAA,CAAA,eAAe,GAAG,CAAC,CAAC,eAAe,CAAA;AACnC,eAAA,CAAA,WAAW,GAAG,CAAC,CAAC,WAAW,CAAA;AAC3B,eAAA,CAAA,WAAW,GAAG,CAAC,CAAC,WAAW,CAAA;AAC3B,eAAA,CAAA,WAAW,GAAG,CAAC,CAAC,WAAW,CAAA;AAC3B,eAAA,CAAA,YAAY,GAAG,CAAC,CAAC,YAAY,CAAA;KAC7B;AAXe,WAAA,CAAA,IAAI,GAAA,IAWnB,CAAA;CDPA,CAAC,CAAC","file":"private/parse/parse*.js","sourcesContent":["(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    function load(_) {\n        exports.opParseExpr = _.opParseExpr;\n        exports.parseClass = _.parseClass;\n        exports.parseExcept = _.parseExcept;\n        exports.parseExpr = _.parseExpr;\n        exports.parseExprParts = _.parseExprParts;\n        exports.parseNExprParts = _.parseNExprParts;\n        exports.parseSingle = _.parseSingle;\n        exports.parseSpaced = _.parseSpaced;\n        exports.parseSwitch = _.parseSwitch;\n        exports.parseTraitDo = _.parseTraitDo;\n    }\n    exports.load = load;\n});\n","import Op from 'op/Op'\nimport {Class, Val, Except, Switch, TraitDo} from '../MsAst'\nimport Token from '../Token'\nimport {Lines, Tokens} from './Slice'\n\n// TODO:ES6 Recursive modules should work, so this should not be necessary.\n\nexport let opParseExpr: (_: Tokens) => Op<Val>\nexport let parseClass: (_: Tokens) => Class\nexport let parseExcept: (_: Tokens) => Except\nexport let parseExpr: (_: Tokens) => Val\nexport let parseExprParts: (_: Tokens) => Array<Val>\nexport let parseNExprParts: (_: Tokens, n: number, errorCode: string) => Array<Val>\nexport let parseSingle: (_: Token) => Val\nexport let parseSpaced: (_: Tokens) => Val\nexport let parseSwitch: (switchedFromFun: boolean, _: Tokens) => Switch\nexport let parseTraitDo: (_: Tokens) => TraitDo\n\nexport function load(_: any) {\n\topParseExpr = _.opParseExpr\n\tparseClass = _.parseClass\n\tparseExcept = _.parseExcept\n\tparseExpr = _.parseExpr\n\tparseExprParts = _.parseExprParts\n\tparseNExprParts = _.parseNExprParts\n\tparseSingle = _.parseSingle\n\tparseSpaced = _.parseSpaced\n\tparseSwitch = _.parseSwitch\n\tparseTraitDo = _.parseTraitDo\n}\n"],"sourceRoot":"/source/"}