if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports', 'esast/dist/ast', 'esast/dist/util', 'esast/dist/mangle-identifier', 'esast/dist/specialize', '../util', './ms-call', './transpile'], function (exports, _esastDistAst, _esastDistUtil, _esastDistMangleIdentifier, _esastDistSpecialize, _util, _msCall, _transpile) {
	'use strict';

	Object.defineProperty(exports, '__esModule', {
		value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _mangleIdentifier = _interopRequireDefault(_esastDistMangleIdentifier);

	var _specialize = _interopRequireDefault(_esastDistSpecialize);

	// Define this here to avoid circular dependency with ast-constants.
	const _IdError = (0, _esastDistAst.Identifier)('Error');

	exports._IdError = _IdError;
	const accessLocalDeclare = localDeclare => localDeclare.isLazy() ? (0, _msCall.msUnlazy)(idForDeclareCached(localDeclare)) : (0, _esastDistAst.Identifier)(idForDeclareCached(localDeclare).name),
	      declare = (localDeclare, val) => (0, _esastDistSpecialize.variableDeclarationConst)([(0, _esastDistAst.VariableDeclarator)(idForDeclareCached(localDeclare), val)]),
	      forStatementInfinite = (0, _specialize.default)(_esastDistAst.ForStatement, ['body', _esastDistAst.Statement], { init: null, test: null, update: null }),
	      idForDeclareCached = localDeclare => {
		let _ = declareToId.get(localDeclare);
		if (_ === undefined) {
			_ = (0, _esastDistAst.Identifier)((0, _mangleIdentifier.default)(localDeclare.name));
			declareToId.set(localDeclare, _);
		}
		return _;
	},
	      opTypeCheckForLocalDeclare = localDeclare =>
	// TODO: Way to typecheck lazies
	(0, _util.opIf)(!localDeclare.isLazy(), () => (0, _util.opMap)(localDeclare.opType, type => (0, _esastDistAst.ExpressionStatement)((0, _msCall.msCheckContains)((0, _transpile.t0)(type), accessLocalDeclare(localDeclare), (0, _esastDistAst.Literal)(localDeclare.name))))),
	      throwErrorFromString = msg => (0, _esastDistAst.ThrowStatement)((0, _esastDistAst.NewExpression)(_IdError, [(0, _esastDistAst.Literal)(msg)])),
	      templateElementForString = str => (0, _esastDistAst.TemplateElement)(false, { cooked: str, raw: (0, _esastDistUtil.escapeStringForTemplate)(str) });

	exports.accessLocalDeclare = accessLocalDeclare;
	exports.declare = declare;
	exports.forStatementInfinite = forStatementInfinite;
	exports.idForDeclareCached = idForDeclareCached;
	exports.opTypeCheckForLocalDeclare = opTypeCheckForLocalDeclare;
	exports.throwErrorFromString = throwErrorFromString;
	exports.templateElementForString = templateElementForString;
	const declareToId = new WeakMap();
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInByaXZhdGUvdHJhbnNwaWxlL3V0aWwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFVTyxPQUFNLFFBQVEsR0FBRyxrQkFWb0IsVUFBVSxFQVVuQixPQUFPLENBQUMsQ0FBQTs7O0FBRXBDLE9BQ04sa0JBQWtCLEdBQUcsWUFBWSxJQUNoQyxZQUFZLENBQUMsTUFBTSxFQUFFLEdBQ3BCLFlBVHVCLFFBQVEsRUFTdEIsa0JBQWtCLENBQUMsWUFBWSxDQUFDLENBQUMsR0FDMUMsa0JBaEJ5QyxVQUFVLEVBZ0J4QyxrQkFBa0IsQ0FBQyxZQUFZLENBQUMsQ0FBQyxJQUFJLENBQUM7T0FFbkQsT0FBTyxHQUFHLENBQUMsWUFBWSxFQUFFLEdBQUcsS0FDM0IseUJBZm1CLHdCQUF3QixFQWVsQixDQUFFLGtCQWxCSyxrQkFBa0IsRUFrQkosa0JBQWtCLENBQUMsWUFBWSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUUsQ0FBQztPQUV4RixvQkFBb0IsR0FBRyx1Q0FyQk0sWUFBWSxFQXNCeEMsQ0FBRSxNQUFNLGdCQXRCc0UsU0FBUyxDQXNCbEUsRUFDckIsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxDQUFDO09BRTFDLGtCQUFrQixHQUFHLFlBQVksSUFBSTtBQUNwQyxNQUFJLENBQUMsR0FBRyxXQUFXLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFBO0FBQ3JDLE1BQUksQ0FBQyxLQUFLLFNBQVMsRUFBRTtBQUNwQixJQUFDLEdBQUcsa0JBNUJxQyxVQUFVLEVBNEJwQywrQkFBaUIsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUE7QUFDbkQsY0FBVyxDQUFDLEdBQUcsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDLENBQUE7R0FDaEM7QUFDRCxTQUFPLENBQUMsQ0FBQTtFQUNSO09BRUQsMEJBQTBCLEdBQUcsWUFBWTs7QUFFeEMsV0EvQk8sSUFBSSxFQStCTixDQUFDLFlBQVksQ0FBQyxNQUFNLEVBQUUsRUFBRSxNQUM1QixVQWhDWSxLQUFLLEVBZ0NYLFlBQVksQ0FBQyxNQUFNLEVBQUUsSUFBSSxJQUM5QixrQkF0Q0ssbUJBQW1CLEVBc0NKLFlBaENmLGVBQWUsRUFpQ25CLGVBaENJLEVBQUUsRUFnQ0gsSUFBSSxDQUFDLEVBQ1Isa0JBQWtCLENBQUMsWUFBWSxDQUFDLEVBQ2hDLGtCQXpDbUQsT0FBTyxFQXlDbEQsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO09BRWxDLG9CQUFvQixHQUFHLEdBQUcsSUFDekIsa0JBM0NnQixjQUFjLEVBMkNmLGtCQTVDZ0QsYUFBYSxFQTRDL0MsUUFBUSxFQUFFLENBQUUsa0JBNUNhLE9BQU8sRUE0Q1osR0FBRyxDQUFDLENBQUUsQ0FBQyxDQUFDO09BRTFELHdCQUF3QixHQUFHLEdBQUcsSUFDN0Isa0JBOUNELGVBQWUsRUE4Q0UsS0FBSyxFQUFFLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsbUJBN0NwQyx1QkFBdUIsRUE2Q3FDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQTs7Ozs7Ozs7O0FBRTVFLE9BQ0MsV0FBVyxHQUFHLElBQUksT0FBTyxFQUFFLENBQUEiLCJmaWxlIjoicHJpdmF0ZS90cmFuc3BpbGUvdXRpbC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4cHJlc3Npb25TdGF0ZW1lbnQsIEZvclN0YXRlbWVudCwgSWRlbnRpZmllciwgTGl0ZXJhbCwgTmV3RXhwcmVzc2lvbiwgU3RhdGVtZW50LFxuXHRUZW1wbGF0ZUVsZW1lbnQsIFRocm93U3RhdGVtZW50LCBWYXJpYWJsZURlY2xhcmF0b3IgfSBmcm9tICdlc2FzdC9kaXN0L2FzdCdcbmltcG9ydCB7IGVzY2FwZVN0cmluZ0ZvclRlbXBsYXRlIH0gZnJvbSAnZXNhc3QvZGlzdC91dGlsJ1xuaW1wb3J0IG1hbmdsZUlkZW50aWZpZXIgZnJvbSAnZXNhc3QvZGlzdC9tYW5nbGUtaWRlbnRpZmllcidcbmltcG9ydCBzcGVjaWFsaXplLCB7IHZhcmlhYmxlRGVjbGFyYXRpb25Db25zdCB9IGZyb20gJ2VzYXN0L2Rpc3Qvc3BlY2lhbGl6ZSdcbmltcG9ydCB7IG9wSWYsIG9wTWFwIH0gZnJvbSAnLi4vdXRpbCdcbmltcG9ydCB7IG1zQ2hlY2tDb250YWlucywgbXNVbmxhenkgfSBmcm9tICcuL21zLWNhbGwnXG5pbXBvcnQgeyB0MCB9IGZyb20gJy4vdHJhbnNwaWxlJ1xuXG4vLyBEZWZpbmUgdGhpcyBoZXJlIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY3kgd2l0aCBhc3QtY29uc3RhbnRzLlxuZXhwb3J0IGNvbnN0IF9JZEVycm9yID0gSWRlbnRpZmllcignRXJyb3InKVxuXG5leHBvcnQgY29uc3Rcblx0YWNjZXNzTG9jYWxEZWNsYXJlID0gbG9jYWxEZWNsYXJlID0+XG5cdFx0bG9jYWxEZWNsYXJlLmlzTGF6eSgpID9cblx0XHRcdG1zVW5sYXp5KGlkRm9yRGVjbGFyZUNhY2hlZChsb2NhbERlY2xhcmUpKSA6XG5cdFx0XHRJZGVudGlmaWVyKGlkRm9yRGVjbGFyZUNhY2hlZChsb2NhbERlY2xhcmUpLm5hbWUpLFxuXG5cdGRlY2xhcmUgPSAobG9jYWxEZWNsYXJlLCB2YWwpID0+XG5cdFx0dmFyaWFibGVEZWNsYXJhdGlvbkNvbnN0KFsgVmFyaWFibGVEZWNsYXJhdG9yKGlkRm9yRGVjbGFyZUNhY2hlZChsb2NhbERlY2xhcmUpLCB2YWwpIF0pLFxuXG5cdGZvclN0YXRlbWVudEluZmluaXRlID0gc3BlY2lhbGl6ZShGb3JTdGF0ZW1lbnQsXG5cdFx0WyAnYm9keScsIFN0YXRlbWVudCBdLFxuXHRcdHsgaW5pdDogbnVsbCwgdGVzdDogbnVsbCwgdXBkYXRlOiBudWxsIH0pLFxuXG5cdGlkRm9yRGVjbGFyZUNhY2hlZCA9IGxvY2FsRGVjbGFyZSA9PiB7XG5cdFx0bGV0IF8gPSBkZWNsYXJlVG9JZC5nZXQobG9jYWxEZWNsYXJlKVxuXHRcdGlmIChfID09PSB1bmRlZmluZWQpIHtcblx0XHRcdF8gPSBJZGVudGlmaWVyKG1hbmdsZUlkZW50aWZpZXIobG9jYWxEZWNsYXJlLm5hbWUpKVxuXHRcdFx0ZGVjbGFyZVRvSWQuc2V0KGxvY2FsRGVjbGFyZSwgXylcblx0XHR9XG5cdFx0cmV0dXJuIF9cblx0fSxcblxuXHRvcFR5cGVDaGVja0ZvckxvY2FsRGVjbGFyZSA9IGxvY2FsRGVjbGFyZSA9PlxuXHRcdC8vIFRPRE86IFdheSB0byB0eXBlY2hlY2sgbGF6aWVzXG5cdFx0b3BJZighbG9jYWxEZWNsYXJlLmlzTGF6eSgpLCAoKSA9PlxuXHRcdFx0b3BNYXAobG9jYWxEZWNsYXJlLm9wVHlwZSwgdHlwZSA9PlxuXHRcdFx0XHRFeHByZXNzaW9uU3RhdGVtZW50KG1zQ2hlY2tDb250YWlucyhcblx0XHRcdFx0XHR0MCh0eXBlKSxcblx0XHRcdFx0XHRhY2Nlc3NMb2NhbERlY2xhcmUobG9jYWxEZWNsYXJlKSxcblx0XHRcdFx0XHRMaXRlcmFsKGxvY2FsRGVjbGFyZS5uYW1lKSkpKSksXG5cblx0dGhyb3dFcnJvckZyb21TdHJpbmcgPSBtc2cgPT5cblx0XHRUaHJvd1N0YXRlbWVudChOZXdFeHByZXNzaW9uKF9JZEVycm9yLCBbIExpdGVyYWwobXNnKSBdKSksXG5cblx0dGVtcGxhdGVFbGVtZW50Rm9yU3RyaW5nID0gc3RyID0+XG5cdFx0VGVtcGxhdGVFbGVtZW50KGZhbHNlLCB7IGNvb2tlZDogc3RyLCByYXc6IGVzY2FwZVN0cmluZ0ZvclRlbXBsYXRlKHN0cikgfSlcblxuY29uc3Rcblx0ZGVjbGFyZVRvSWQgPSBuZXcgV2Vha01hcCgpXG4iXSwic291cmNlUm9vdCI6Ii9zcmMifQ==