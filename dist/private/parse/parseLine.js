if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports', '../context', '../MsAst', '../Token', '../util', './checks', './parseBlock', './parseCase', './parseExcept', './parseFor', './parseLine', './parseLocalDeclares', './parseMemberName', './parseQuote', './parse*', './Slice'], function (exports, _context, _MsAst, _Token, _util, _checks, _parseBlock, _parseCase, _parseExcept, _parseFor, _parseLine, _parseLocalDeclares, _parseMemberName, _parseQuote, _parse, _Slice) {
	'use strict';

	Object.defineProperty(exports, '__esModule', {
		value: true
	});

	var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _parseCase2 = _interopRequireDefault(_parseCase);

	var _parseExcept2 = _interopRequireDefault(_parseExcept);

	var _parseLine2 = _interopRequireDefault(_parseLine);

	var _parseLocalDeclares2 = _interopRequireDefault(_parseLocalDeclares);

	var _parseMemberName2 = _interopRequireDefault(_parseMemberName);

	var _parseQuote2 = _interopRequireDefault(_parseQuote);

	var _Slice2 = _interopRequireDefault(_Slice);

	exports.default = tokens => {
		const head = tokens.head();
		const rest = tokens.tail();

		const noRest = () => (0, _checks.checkEmpty)(rest, () => `Did not expect anything after ${ head }.`);

		// We only deal with mutable expressions here, otherwise we fall back to parseExpr.
		if (head instanceof _Token.Keyword) switch (head.kind) {
			case _Token.KW_Assert:case _Token.KW_AssertNot:
				return parseAssert(head.kind === _Token.KW_AssertNot, rest);
			case _Token.KW_ExceptDo:
				return (0, _parseExcept2.default)(_Token.KW_ExceptDo, rest);
			case _Token.KW_Break:
				noRest();
				return new _MsAst.Break(tokens.loc);
			case _Token.KW_BreakWithVal:
				return new _MsAst.BreakWithVal(tokens.loc, (0, _parse.parseExpr)(rest));
			case _Token.KW_CaseDo:
				return (0, _parseCase2.default)(false, false, rest);
			case _Token.KW_Debugger:
				noRest();
				return new _MsAst.SpecialDo(tokens.loc, _MsAst.SD_Debugger);
			case _Token.KW_Ellipsis:
				return new _MsAst.BagEntryMany(tokens.loc, (0, _parse.parseExpr)(rest));
			case _Token.KW_ForDo:
				return (0, _parseFor.parseForDo)(rest);
			case _Token.KW_Ignore:
				return parseIgnore(rest);
			case _Token.KW_IfDo:case _Token.KW_UnlessDo:
				{
					var _beforeAndBlock = (0, _parseBlock.beforeAndBlock)(rest);

					var _beforeAndBlock2 = _slicedToArray(_beforeAndBlock, 2);

					const before = _beforeAndBlock2[0];
					const block = _beforeAndBlock2[1];

					return new _MsAst.ConditionalDo(tokens.loc, (0, _parse.parseExpr)(before), (0, _parseBlock.parseBlockDo)(block), head.kind === _Token.KW_UnlessDo);
				}
			case _Token.KW_ObjAssign:
				return new _MsAst.BagEntry(tokens.loc, (0, _parse.parseExpr)(rest));
			case _Token.KW_Pass:
				noRest();
				return [];
			case _Token.KW_Region:
				return (0, _parseBlock.parseLinesFromBlock)(tokens);
			case _Token.KW_SuperDo:
				return new _MsAst.SuperCallDo(tokens.loc, (0, _parse.parseExprParts)(rest));
			case _Token.KW_SwitchDo:
				return (0, _parse.parseSwitch)(false, false, rest);
			case _Token.KW_Throw:
				return new _MsAst.Throw(tokens.loc, (0, _util.opIf)(!rest.isEmpty(), () => (0, _parse.parseExpr)(rest)));
			case _Token.KW_Name:
				if ((0, _Token.isKeyword)(_Token.KW_ObjAssign, rest.head())) {
					const r = rest.tail();
					const val = r.isEmpty() ? new _MsAst.SpecialVal(tokens.loc, _MsAst.SV_Name) : (0, _parse.parseExpr)(r);
					return _MsAst.ObjEntryPlain.name(tokens.loc, val);
				}
			// else fall through
			default:
			// fall through
		}

		return (0, _util.ifElse)(tokens.opSplitOnceWhere(isLineSplitKeyword), _ref => {
			let before = _ref.before;
			let at = _ref.at;
			let after = _ref.after;
			return parseAssignLike(before, at, after, tokens.loc);
		}, () => (0, _parse.parseExpr)(tokens));
	};

	const parseLineOrLines = tokens => {
		const _ = (0, _parseLine2.default)(tokens);
		return _ instanceof Array ? _ : [_];
	};

	exports.parseLineOrLines = parseLineOrLines;
	const isLineSplitKeyword = token => {
		if (token instanceof _Token.Keyword) switch (token.kind) {
			case _Token.KW_Assign:case _Token.KW_AssignMutable:case _Token.KW_LocalMutate:
			case _Token.KW_MapEntry:case _Token.KW_ObjAssign:case _Token.KW_Yield:case _Token.KW_YieldTo:
				return true;
			default:
				return false;
		} else return false;
	},
	      parseAssignLike = (before, at, after, loc) => {
		const kind = at.kind;
		if (kind === _Token.KW_MapEntry) return new _MsAst.MapEntry(loc, (0, _parse.parseExpr)(before), (0, _parse.parseExpr)(after));

		if (before.size() === 1) {
			const token = before.head();
			// `a.b = c`, `.b = c`, `a."b" = c`, `."b" = c`, `a[b] = c`
			if ((0, _Token.isGroup)(_Token.G_Space, token)) {
				const spaced = _Slice2.default.group(token);

				var _ifElse = (0, _util.ifElse)(spaced.opSplitOnceWhere(_ => (0, _Token.isKeyword)(_Token.KW_Type, _)), _ref2 => {
					let before = _ref2.before;
					let after = _ref2.after;
					return [before, (0, _parse.parseExpr)(after)];
				}, () => [spaced, null]);

				var _ifElse2 = _slicedToArray(_ifElse, 2);

				const value = _ifElse2[0];
				const opType = _ifElse2[1];

				const last = value.last();
				const object = obj => obj.isEmpty() ? _MsAst.LocalAccess.this(obj.loc) : (0, _parse.parseSpaced)(obj);

				if ((0, _Token.isKeyword)(_Token.KW_Dot, value.nextToLast())) {
					const name = (0, _parseMemberName2.default)(last);
					const set = object(value.rtail().rtail());
					const kind = memberSetKind(at);
					return new _MsAst.MemberSet(loc, set, name, opType, kind, (0, _parse.parseExpr)(after));
				} else if ((0, _Token.isGroup)(_Token.G_Bracket, last)) {
					const set = object(value.rtail());
					return parseSubSet(set, _Slice2.default.group(last), opType, at, after, loc);
				}
				// `"1". 1`
			} else if ((0, _Token.isGroup)(_Token.G_Quote, token) && kind === _Token.KW_ObjAssign) return new _MsAst.ObjEntryComputed(loc, (0, _parseQuote2.default)(_Slice2.default.group(token)), (0, _parse.parseExpr)(after));
		}

		return kind === _Token.KW_LocalMutate ? parseLocalMutate(before, after, loc) : parseAssign(before, kind, after, loc);
	},
	      memberSetKind = at => {
		switch (at.kind) {
			case _Token.KW_Assign:
				return _MsAst.SET_Init;
			case _Token.KW_AssignMutable:
				return _MsAst.SET_InitMutable;
			case _Token.KW_LocalMutate:
				return _MsAst.SET_Mutate;
			default:
				(0, _checks.unexpected)(at);
		}
	},
	      parseSubSet = (object, subbed, opType, at, after, loc) => {
		const subbeds = (0, _parse.parseExprParts)(subbed);
		return new _MsAst.SetSub(loc, object, subbeds, opType, memberSetKind(at), (0, _parse.parseExpr)(after));
	},
	      parseLocalMutate = (localsTokens, valueTokens, loc) => {
		const locals = (0, _parseLocalDeclares.parseLocalDeclaresJustNames)(localsTokens);
		(0, _context.check)(locals.length === 1, loc, 'TODO: LocalDestructureMutate');
		const name = locals[0].name;
		const value = (0, _parse.parseExpr)(valueTokens);
		return new _MsAst.LocalMutate(loc, name, value);
	},
	      parseAssign = (localsTokens, kind, valueTokens, loc) => {
		const locals = (0, _parseLocalDeclares2.default)(localsTokens);

		// Handle `a.` which moves an outer local into an ObjEntry.
		if (kind === _Token.KW_ObjAssign && valueTokens.isEmpty() && locals.length === 1) {
			const local = locals[0];
			(0, _context.check)(local.opType === null, local.loc, () => `Type declaration should go with initial declaration of ${ local.name }.`);
			return _MsAst.ObjEntryPlain.access(loc, local.name);
		}

		const value = parseAssignValue(kind, valueTokens);

		const isYield = kind === _Token.KW_Yield || kind === _Token.KW_YieldTo;
		if ((0, _util.isEmpty)(locals)) {
			(0, _context.check)(isYield, localsTokens.loc, 'Assignment to nothing');
			return value;
		} else {
			if (isYield) for (const _ of locals) (0, _context.check)(!_.isLazy(), _.loc, 'Can not yield to lazy variable.');

			const isObjAssign = kind === _Token.KW_ObjAssign;

			if (kind === _Token.KW_AssignMutable) for (let _ of locals) {
				(0, _context.check)(!_.isLazy(), _.loc, 'Lazy local can not be mutable.');
				_.kind = _MsAst.LD_Mutable;
			}

			const wrap = _ => isObjAssign ? new _MsAst.ObjEntryAssign(loc, _) : _;

			if (locals.length === 1) {
				const assignee = locals[0];
				const assign = new _MsAst.AssignSingle(loc, assignee, value);
				return wrap(assign);
			} else {
				const kind = locals[0].kind;
				for (const _ of locals) (0, _context.check)(_.kind === kind, _.loc, 'All locals of destructuring assignment must be of the same kind.');
				return wrap(new _MsAst.AssignDestructure(loc, locals, value, kind));
			}
		}
	},
	      parseAssignValue = (kind, valueTokens) => {
		const value = (0, _parse.parseExpr)(valueTokens);
		switch (kind) {
			case _Token.KW_Yield:
				return new _MsAst.Yield(value.loc, value);
			case _Token.KW_YieldTo:
				return new _MsAst.YieldTo(value.loc, value);
			default:
				return value;
		}
	},
	      parseAssert = (negate, tokens) => {
		(0, _checks.checkNonEmpty)(tokens, () => `Expected something after ${ (0, _Token.keywordName)(_Token.KW_Assert) }.`);

		var _ifElse3 = (0, _util.ifElse)(tokens.opSplitOnceWhere(_ => (0, _Token.isKeyword)(_Token.KW_Throw, _)), _ref3 => {
			let before = _ref3.before;
			let after = _ref3.after;
			return [before, (0, _parse.parseExpr)(after)];
		}, () => [tokens, null]);

		var _ifElse32 = _slicedToArray(_ifElse3, 2);

		const condTokens = _ifElse32[0];
		const opThrown = _ifElse32[1];

		const parts = (0, _parse.parseExprParts)(condTokens);
		const cond = parts.length === 1 ? parts[0] : new _MsAst.Call(condTokens.loc, parts[0], (0, _util.tail)(parts));
		return new _MsAst.Assert(tokens.loc, negate, cond, opThrown);
	},
	      parseIgnore = tokens => {
		const ignored = tokens.map(_ => {
			if ((0, _Token.isKeyword)(_Token.KW_Focus, _)) return '_';else {
				(0, _context.check)(_ instanceof _Token.Name, _.loc, () => `Expected local name, not ${ _ }.`);
				return _.name;
			}
		});
		return new _MsAst.Ignore(tokens.loc, ignored);
	};
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhcnNlTGluZS5qcyIsInByaXZhdGUvcGFyc2UvcGFyc2VMaW5lLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O21CQ3dCZSxNQUFNLElBQUk7QUFDeEIsUUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFBO0FBQzFCLFFBQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQTs7QUFFMUIsUUFBTSxNQUFNLEdBQUcsTUFDZCxZQWpCTSxVQUFVLEVBaUJMLElBQUksRUFBRSxNQUFNLENBQUMsOEJBQThCLEdBQUUsSUFBSSxFQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7OztBQUdqRSxNQUFJLElBQUksbUJBMUJnRCxPQUFPLEFBMEJwQyxFQUMxQixRQUFRLElBQUksQ0FBQyxJQUFJO0FBQ2hCLGVBNUI0RSxTQUFTLENBNEJ0RSxBQUFDLFlBM0JsQixZQUFZO0FBNEJULFdBQU8sV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLFlBNUIvQixZQUFZLEFBNEJvQyxFQUFFLElBQUksQ0FBQyxDQUFBO0FBQUEsQUFDckQsZUE1Qm1CLFdBQVc7QUE2QjdCLFdBQU8sa0NBN0JXLFdBQVcsRUE2QkcsSUFBSSxDQUFDLENBQUE7QUFBQSxBQUN0QyxlQS9CeUMsUUFBUTtBQWdDaEQsVUFBTSxFQUFFLENBQUE7QUFDUixXQUFPLFdBdkM4RCxLQUFLLENBdUN6RCxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUE7QUFBQSxBQUM3QixlQWxDbUQsZUFBZTtBQW1DakUsV0FBTyxXQXpDcUUsWUFBWSxDQXlDaEUsTUFBTSxDQUFDLEdBQUcsRUFBRSxXQXJCaEMsU0FBUyxFQXFCaUMsSUFBSSxDQUFDLENBQUMsQ0FBQTtBQUFBLEFBQ3JELGVBcENvRSxTQUFTO0FBcUM1RSxXQUFPLHlCQUFVLEtBQUssRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUE7QUFBQSxBQUNyQyxlQXRDK0UsV0FBVztBQXVD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QUFRLEVBNk9oQixDQUFDLENBQUMsRUFDekIsT0FBTyxHQUFHLENBQUEsS0FDTjtBQUNKLGlCQXhQSSxLQUFLLEVBd1BILENBQUMsbUJBOU9rQyxJQUFJLEFBOE90QixFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLHlCQUF5QixHQUFFLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQyxDQUFBO0FBQ3ZFLFdBQU8sQ0FBQyxDQUFDLElBQUksQ0FBQTtJQUNiO0dBQ0QsQ0FBQyxDQUFBO0FBQ0YsU0FBTyxXQTFQTyxNQUFNLENBMFBGLE1BQU0sQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLENBQUE7RUFDdEMsQ0FBQSIsImZpbGUiOiJwcml2YXRlL3BhcnNlL3BhcnNlTGluZS5qcyIsInNvdXJjZXNDb250ZW50IjpbbnVsbCwiaW1wb3J0IHtjaGVja30gZnJvbSAnLi4vY29udGV4dCdcbmltcG9ydCB7QXNzZXJ0LCBBc3NpZ25TaW5nbGUsIEFzc2lnbkRlc3RydWN0dXJlLCBCYWdFbnRyeSwgQmFnRW50cnlNYW55LCBCcmVhaywgQnJlYWtXaXRoVmFsLCBDYWxsLFxuXHRDb25kaXRpb25hbERvLCBJZ25vcmUsIExEX011dGFibGUsIExvY2FsQWNjZXNzLCBMb2NhbE11dGF0ZSwgTWFwRW50cnksIE1lbWJlclNldCxcblx0T2JqRW50cnlBc3NpZ24sIE9iakVudHJ5Q29tcHV0ZWQsIE9iakVudHJ5UGxhaW4sIFNEX0RlYnVnZ2VyLCBTRVRfSW5pdCwgU0VUX0luaXRNdXRhYmxlLFxuXHRTRVRfTXV0YXRlLCBTZXRTdWIsIFNwZWNpYWxEbywgU3BlY2lhbFZhbCwgU3VwZXJDYWxsRG8sIFNWX05hbWUsIFRocm93LCBZaWVsZCwgWWllbGRUb1xuXHR9IGZyb20gJy4uL01zQXN0J1xuaW1wb3J0IHtHX0JyYWNrZXQsIEdfUXVvdGUsIEdfU3BhY2UsIGlzR3JvdXAsIGlzS2V5d29yZCwgS2V5d29yZCwga2V5d29yZE5hbWUsIEtXX0Fzc2VydCxcblx0S1dfQXNzZXJ0Tm90LCBLV19Bc3NpZ24sIEtXX0Fzc2lnbk11dGFibGUsIEtXX0JyZWFrLCBLV19CcmVha1dpdGhWYWwsIEtXX0Nhc2VEbywgS1dfRGVidWdnZXIsXG5cdEtXX0RvdCwgS1dfRWxsaXBzaXMsIEtXX0V4Y2VwdERvLCBLV19Gb2N1cywgS1dfRm9yRG8sIEtXX0lmRG8sIEtXX0lnbm9yZSwgS1dfTG9jYWxNdXRhdGUsXG5cdEtXX01hcEVudHJ5LCBLV19OYW1lLCBLV19PYmpBc3NpZ24sIEtXX1Bhc3MsIEtXX1JlZ2lvbiwgS1dfU3VwZXJEbywgS1dfU3dpdGNoRG8sIEtXX1Rocm93LFxuXHRLV19UeXBlLCBLV19Vbmxlc3NEbywgS1dfWWllbGQsIEtXX1lpZWxkVG8sIE5hbWV9IGZyb20gJy4uL1Rva2VuJ1xuaW1wb3J0IHtpZkVsc2UsIGlzRW1wdHksIG9wSWYsIHRhaWx9IGZyb20gJy4uL3V0aWwnXG5pbXBvcnQge2NoZWNrRW1wdHksIGNoZWNrTm9uRW1wdHksIHVuZXhwZWN0ZWR9IGZyb20gJy4vY2hlY2tzJ1xuaW1wb3J0IHtiZWZvcmVBbmRCbG9jaywgcGFyc2VCbG9ja0RvLCBwYXJzZUxpbmVzRnJvbUJsb2NrfSBmcm9tICcuL3BhcnNlQmxvY2snXG5pbXBvcnQgcGFyc2VDYXNlIGZyb20gJy4vcGFyc2VDYXNlJ1xuaW1wb3J0IHBhcnNlRXhjZXB0IGZyb20gJy4vcGFyc2VFeGNlcHQnXG5pbXBvcnQge3BhcnNlRm9yRG99IGZyb20gJy4vcGFyc2VGb3InXG5pbXBvcnQgcGFyc2VMaW5lIGZyb20gJy4vcGFyc2VMaW5lJ1xuaW1wb3J0IHBhcnNlTG9jYWxEZWNsYXJlcywge3BhcnNlTG9jYWxEZWNsYXJlc0p1c3ROYW1lc30gZnJvbSAnLi9wYXJzZUxvY2FsRGVjbGFyZXMnXG5pbXBvcnQgcGFyc2VNZW1iZXJOYW1lIGZyb20gJy4vcGFyc2VNZW1iZXJOYW1lJ1xuaW1wb3J0IHBhcnNlUXVvdGUgZnJvbSAnLi9wYXJzZVF1b3RlJ1xuaW1wb3J0IHtwYXJzZUV4cHIsIHBhcnNlRXhwclBhcnRzLCBwYXJzZVNwYWNlZCwgcGFyc2VTd2l0Y2h9IGZyb20gJy4vcGFyc2UqJ1xuaW1wb3J0IFNsaWNlIGZyb20gJy4vU2xpY2UnXG5cbmV4cG9ydCBkZWZhdWx0IHRva2VucyA9PiB7XG5cdGNvbnN0IGhlYWQgPSB0b2tlbnMuaGVhZCgpXG5cdGNvbnN0IHJlc3QgPSB0b2tlbnMudGFpbCgpXG5cblx0Y29uc3Qgbm9SZXN0ID0gKCkgPT5cblx0XHRjaGVja0VtcHR5KHJlc3QsICgpID0+IGBEaWQgbm90IGV4cGVjdCBhbnl0aGluZyBhZnRlciAke2hlYWR9LmApXG5cblx0Ly8gV2Ugb25seSBkZWFsIHdpdGggbXV0YWJsZSBleHByZXNzaW9ucyBoZXJlLCBvdGhlcndpc2Ugd2UgZmFsbCBiYWNrIHRvIHBhcnNlRXhwci5cblx0aWYgKGhlYWQgaW5zdGFuY2VvZiBLZXl3b3JkKVxuXHRcdHN3aXRjaCAoaGVhZC5raW5kKSB7XG5cdFx0XHRjYXNlIEtXX0Fzc2VydDogY2FzZSBLV19Bc3NlcnROb3Q6XG5cdFx0XHRcdHJldHVybiBwYXJzZUFzc2VydChoZWFkLmtpbmQgPT09IEtXX0Fzc2VydE5vdCwgcmVzdClcblx0XHRcdGNhc2UgS1dfRXhjZXB0RG86XG5cdFx0XHRcdHJldHVybiBwYXJzZUV4Y2VwdChLV19FeGNlcHREbywgcmVzdClcblx0XHRcdGNhc2UgS1dfQnJlYWs6XG5cdFx0XHRcdG5vUmVzdCgpXG5cdFx0XHRcdHJldHVybiBuZXcgQnJlYWsodG9rZW5zLmxvYylcblx0XHRcdGNhc2UgS1dfQnJlYWtXaXRoVmFsOlxuXHRcdFx0XHRyZXR1cm4gbmV3IEJyZWFrV2l0aFZhbCh0b2tlbnMubG9jLCBwYXJzZUV4cHIocmVzdCkpXG5cdFx0XHRjYXNlIEtXX0Nhc2VEbzpcblx0XHRcdFx0cmV0dXJuIHBhcnNlQ2FzZShmYWxzZSwgZmFsc2UsIHJlc3QpXG5cdFx0XHRjYXNlIEtXX0RlYnVnZ2VyOlxuXHRcdFx0XHRub1Jlc3QoKVxuXHRcdFx0XHRyZXR1cm4gbmV3IFNwZWNpYWxEbyh0b2tlbnMubG9jLCBTRF9EZWJ1Z2dlcilcblx0XHRcdGNhc2UgS1dfRWxsaXBzaXM6XG5cdFx0XHRcdHJldHVybiBuZXcgQmFnRW50cnlNYW55KHRva2Vucy5sb2MsIHBhcnNlRXhwcihyZXN0KSlcblx0XHRcdGNhc2UgS1dfRm9yRG86XG5cdFx0XHRcdHJldHVybiBwYXJzZUZvckRvKHJlc3QpXG5cdFx0XHRjYXNlIEtXX0lnbm9yZTpcblx0XHRcdFx0cmV0dXJuIHBhcnNlSWdub3JlKHJlc3QpXG5cdFx0XHRjYXNlIEtXX0lmRG86IGNhc2UgS1dfVW5sZXNzRG86IHtcblx0XHRcdFx0Y29uc3QgW2JlZm9yZSwgYmxvY2tdID0gYmVmb3JlQW5kQmxvY2socmVzdClcblx0XHRcdFx0cmV0dXJuIG5ldyBDb25kaXRpb25hbERvKHRva2Vucy5sb2MsXG5cdFx0XHRcdFx0cGFyc2VFeHByKGJlZm9yZSksXG5cdFx0XHRcdFx0cGFyc2VCbG9ja0RvKGJsb2NrKSxcblx0XHRcdFx0XHRoZWFkLmtpbmQgPT09IEtXX1VubGVzc0RvKVxuXHRcdFx0fVxuXHRcdFx0Y2FzZSBLV19PYmpBc3NpZ246XG5cdFx0XHRcdHJldHVybiBuZXcgQmFnRW50cnkodG9rZW5zLmxvYywgcGFyc2VFeHByKHJlc3QpKVxuXHRcdFx0Y2FzZSBLV19QYXNzOlxuXHRcdFx0XHRub1Jlc3QoKVxuXHRcdFx0XHRyZXR1cm4gW11cblx0XHRcdGNhc2UgS1dfUmVnaW9uOlxuXHRcdFx0XHRyZXR1cm4gcGFyc2VMaW5lc0Zyb21CbG9jayh0b2tlbnMpXG5cdFx0XHRjYXNlIEtXX1N1cGVyRG86XG5cdFx0XHRcdHJldHVybiBuZXcgU3VwZXJDYWxsRG8odG9rZW5zLmxvYywgcGFyc2VFeHByUGFydHMocmVzdCkpXG5cdFx0XHRjYXNlIEtXX1N3aXRjaERvOlxuXHRcdFx0XHRyZXR1cm4gcGFyc2VTd2l0Y2goZmFsc2UsIGZhbHNlLCByZXN0KVxuXHRcdFx0Y2FzZSBLV19UaHJvdzpcblx0XHRcdFx0cmV0dXJuIG5ldyBUaHJvdyh0b2tlbnMubG9jLCBvcElmKCFyZXN0LmlzRW1wdHkoKSwgKCkgPT4gcGFyc2VFeHByKHJlc3QpKSlcblx0XHRcdGNhc2UgS1dfTmFtZTpcblx0XHRcdFx0aWYgKGlzS2V5d29yZChLV19PYmpBc3NpZ24sIHJlc3QuaGVhZCgpKSkge1xuXHRcdFx0XHRcdGNvbnN0IHIgPSByZXN0LnRhaWwoKVxuXHRcdFx0XHRcdGNvbnN0IHZhbCA9IHIuaXNFbXB0eSgpID8gbmV3IFNwZWNpYWxWYWwodG9rZW5zLmxvYywgU1ZfTmFtZSkgOiBwYXJzZUV4cHIocilcblx0XHRcdFx0XHRyZXR1cm4gT2JqRW50cnlQbGFpbi5uYW1lKHRva2Vucy5sb2MsIHZhbClcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBlbHNlIGZhbGwgdGhyb3VnaFxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0Ly8gZmFsbCB0aHJvdWdoXG5cdFx0fVxuXG5cdHJldHVybiBpZkVsc2UodG9rZW5zLm9wU3BsaXRPbmNlV2hlcmUoaXNMaW5lU3BsaXRLZXl3b3JkKSxcblx0XHQoe2JlZm9yZSwgYXQsIGFmdGVyfSkgPT4gcGFyc2VBc3NpZ25MaWtlKGJlZm9yZSwgYXQsIGFmdGVyLCB0b2tlbnMubG9jKSxcblx0XHQoKSA9PiBwYXJzZUV4cHIodG9rZW5zKSlcbn1cblxuZXhwb3J0IGNvbnN0IHBhcnNlTGluZU9yTGluZXMgPSB0b2tlbnMgPT4ge1xuXHRjb25zdCBfID0gcGFyc2VMaW5lKHRva2Vucylcblx0cmV0dXJuIF8gaW5zdGFuY2VvZiBBcnJheSA/IF8gOiBbX11cbn1cblxuY29uc3Rcblx0aXNMaW5lU3BsaXRLZXl3b3JkID0gdG9rZW4gPT4ge1xuXHRcdGlmICh0b2tlbiBpbnN0YW5jZW9mIEtleXdvcmQpXG5cdFx0XHRzd2l0Y2ggKHRva2VuLmtpbmQpIHtcblx0XHRcdFx0Y2FzZSBLV19Bc3NpZ246IGNhc2UgS1dfQXNzaWduTXV0YWJsZTogY2FzZSBLV19Mb2NhbE11dGF0ZTpcblx0XHRcdFx0Y2FzZSBLV19NYXBFbnRyeTogY2FzZSBLV19PYmpBc3NpZ246IGNhc2UgS1dfWWllbGQ6IGNhc2UgS1dfWWllbGRUbzpcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHJldHVybiBmYWxzZVxuXHRcdFx0fVxuXHRcdGVsc2Vcblx0XHRcdHJldHVybiBmYWxzZVxuXHR9LFxuXG5cdHBhcnNlQXNzaWduTGlrZSA9IChiZWZvcmUsIGF0LCBhZnRlciwgbG9jKSA9PiB7XG5cdFx0Y29uc3Qga2luZCA9IGF0LmtpbmRcblx0XHRpZiAoa2luZCA9PT0gS1dfTWFwRW50cnkpXG5cdFx0XHRyZXR1cm4gbmV3IE1hcEVudHJ5KGxvYywgcGFyc2VFeHByKGJlZm9yZSksIHBhcnNlRXhwcihhZnRlcikpXG5cblx0XHRpZiAoYmVmb3JlLnNpemUoKSA9PT0gMSkge1xuXHRcdFx0Y29uc3QgdG9rZW4gPSBiZWZvcmUuaGVhZCgpXG5cdFx0XHQvLyBgYS5iID0gY2AsIGAuYiA9IGNgLCBgYS5cImJcIiA9IGNgLCBgLlwiYlwiID0gY2AsIGBhW2JdID0gY2Bcblx0XHRcdGlmIChpc0dyb3VwKEdfU3BhY2UsIHRva2VuKSkge1xuXHRcdFx0XHRjb25zdCBzcGFjZWQgPSBTbGljZS5ncm91cCh0b2tlbilcblx0XHRcdFx0Y29uc3QgW3ZhbHVlLCBvcFR5cGVdID0gaWZFbHNlKHNwYWNlZC5vcFNwbGl0T25jZVdoZXJlKF8gPT4gaXNLZXl3b3JkKEtXX1R5cGUsIF8pKSxcblx0XHRcdFx0XHQoe2JlZm9yZSwgYWZ0ZXJ9KSA9PiBbYmVmb3JlLCBwYXJzZUV4cHIoYWZ0ZXIpXSxcblx0XHRcdFx0XHQoKSA9PiBbc3BhY2VkLCBudWxsXSlcblxuXHRcdFx0XHRjb25zdCBsYXN0ID0gdmFsdWUubGFzdCgpXG5cdFx0XHRcdGNvbnN0IG9iamVjdCA9IG9iaiA9PlxuXHRcdFx0XHRcdG9iai5pc0VtcHR5KCkgPyBMb2NhbEFjY2Vzcy50aGlzKG9iai5sb2MpIDogcGFyc2VTcGFjZWQob2JqKVxuXG5cdFx0XHRcdGlmIChpc0tleXdvcmQoS1dfRG90LCB2YWx1ZS5uZXh0VG9MYXN0KCkpKSB7XG5cdFx0XHRcdFx0Y29uc3QgbmFtZSA9IHBhcnNlTWVtYmVyTmFtZShsYXN0KVxuXHRcdFx0XHRcdGNvbnN0IHNldCA9IG9iamVjdCh2YWx1ZS5ydGFpbCgpLnJ0YWlsKCkpXG5cdFx0XHRcdFx0Y29uc3Qga2luZCA9IG1lbWJlclNldEtpbmQoYXQpXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBNZW1iZXJTZXQobG9jLCBzZXQsIG5hbWUsIG9wVHlwZSwga2luZCwgcGFyc2VFeHByKGFmdGVyKSlcblx0XHRcdFx0fSBlbHNlIGlmIChpc0dyb3VwKEdfQnJhY2tldCwgbGFzdCkpIHtcblx0XHRcdFx0XHRjb25zdCBzZXQgPSBvYmplY3QodmFsdWUucnRhaWwoKSlcblx0XHRcdFx0XHRyZXR1cm4gcGFyc2VTdWJTZXQoc2V0LCBTbGljZS5ncm91cChsYXN0KSwgb3BUeXBlLCBhdCwgYWZ0ZXIsIGxvYylcblx0XHRcdFx0fVxuXHRcdFx0Ly8gYFwiMVwiLiAxYFxuXHRcdFx0fSBlbHNlIGlmIChpc0dyb3VwKEdfUXVvdGUsIHRva2VuKSAmJiBraW5kID09PSBLV19PYmpBc3NpZ24pXG5cdFx0XHRcdHJldHVybiBuZXcgT2JqRW50cnlDb21wdXRlZChsb2MsIHBhcnNlUXVvdGUoU2xpY2UuZ3JvdXAodG9rZW4pKSwgcGFyc2VFeHByKGFmdGVyKSlcblx0XHR9XG5cblx0XHRyZXR1cm4ga2luZCA9PT0gS1dfTG9jYWxNdXRhdGUgP1xuXHRcdFx0cGFyc2VMb2NhbE11dGF0ZShiZWZvcmUsIGFmdGVyLCBsb2MpIDpcblx0XHRcdHBhcnNlQXNzaWduKGJlZm9yZSwga2luZCwgYWZ0ZXIsIGxvYylcblx0fSxcblxuXHRtZW1iZXJTZXRLaW5kID0gYXQgPT4ge1xuXHRcdHN3aXRjaCAoYXQua2luZCkge1xuXHRcdFx0Y2FzZSBLV19Bc3NpZ246XG5cdFx0XHRcdHJldHVybiBTRVRfSW5pdFxuXHRcdFx0Y2FzZSBLV19Bc3NpZ25NdXRhYmxlOlxuXHRcdFx0XHRyZXR1cm4gU0VUX0luaXRNdXRhYmxlXG5cdFx0XHRjYXNlIEtXX0xvY2FsTXV0YXRlOlxuXHRcdFx0XHRyZXR1cm4gU0VUX011dGF0ZVxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dW5leHBlY3RlZChhdClcblx0XHR9XG5cdH0sXG5cblx0cGFyc2VTdWJTZXQgPSAob2JqZWN0LCBzdWJiZWQsIG9wVHlwZSwgYXQsIGFmdGVyLCBsb2MpID0+IHtcblx0XHRjb25zdCBzdWJiZWRzID0gcGFyc2VFeHByUGFydHMoc3ViYmVkKVxuXHRcdHJldHVybiBuZXcgU2V0U3ViKGxvYywgb2JqZWN0LCBzdWJiZWRzLCBvcFR5cGUsIG1lbWJlclNldEtpbmQoYXQpLCBwYXJzZUV4cHIoYWZ0ZXIpKVxuXHR9LFxuXG5cdHBhcnNlTG9jYWxNdXRhdGUgPSAobG9jYWxzVG9rZW5zLCB2YWx1ZVRva2VucywgbG9jKSA9PiB7XG5cdFx0Y29uc3QgbG9jYWxzID0gcGFyc2VMb2NhbERlY2xhcmVzSnVzdE5hbWVzKGxvY2Fsc1Rva2Vucylcblx0XHRjaGVjayhsb2NhbHMubGVuZ3RoID09PSAxLCBsb2MsICdUT0RPOiBMb2NhbERlc3RydWN0dXJlTXV0YXRlJylcblx0XHRjb25zdCBuYW1lID0gbG9jYWxzWzBdLm5hbWVcblx0XHRjb25zdCB2YWx1ZSA9IHBhcnNlRXhwcih2YWx1ZVRva2Vucylcblx0XHRyZXR1cm4gbmV3IExvY2FsTXV0YXRlKGxvYywgbmFtZSwgdmFsdWUpXG5cdH0sXG5cblx0cGFyc2VBc3NpZ24gPSAobG9jYWxzVG9rZW5zLCBraW5kLCB2YWx1ZVRva2VucywgbG9jKSA9PiB7XG5cdFx0Y29uc3QgbG9jYWxzID0gcGFyc2VMb2NhbERlY2xhcmVzKGxvY2Fsc1Rva2VucylcblxuXHRcdC8vIEhhbmRsZSBgYS5gIHdoaWNoIG1vdmVzIGFuIG91dGVyIGxvY2FsIGludG8gYW4gT2JqRW50cnkuXG5cdFx0aWYgKGtpbmQgPT09IEtXX09iakFzc2lnbiAmJiB2YWx1ZVRva2Vucy5pc0VtcHR5KCkgJiYgbG9jYWxzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0Y29uc3QgbG9jYWwgPSBsb2NhbHNbMF1cblx0XHRcdGNoZWNrKGxvY2FsLm9wVHlwZSA9PT0gbnVsbCwgbG9jYWwubG9jLCAoKSA9PlxuXHRcdFx0XHRgVHlwZSBkZWNsYXJhdGlvbiBzaG91bGQgZ28gd2l0aCBpbml0aWFsIGRlY2xhcmF0aW9uIG9mICR7bG9jYWwubmFtZX0uYClcblx0XHRcdHJldHVybiBPYmpFbnRyeVBsYWluLmFjY2Vzcyhsb2MsIGxvY2FsLm5hbWUpXG5cdFx0fVxuXG5cdFx0Y29uc3QgdmFsdWUgPSBwYXJzZUFzc2lnblZhbHVlKGtpbmQsIHZhbHVlVG9rZW5zKVxuXG5cdFx0Y29uc3QgaXNZaWVsZCA9IGtpbmQgPT09IEtXX1lpZWxkIHx8IGtpbmQgPT09IEtXX1lpZWxkVG9cblx0XHRpZiAoaXNFbXB0eShsb2NhbHMpKSB7XG5cdFx0XHRjaGVjayhpc1lpZWxkLCBsb2NhbHNUb2tlbnMubG9jLCAnQXNzaWdubWVudCB0byBub3RoaW5nJylcblx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoaXNZaWVsZClcblx0XHRcdFx0Zm9yIChjb25zdCBfIG9mIGxvY2Fscylcblx0XHRcdFx0XHRjaGVjayghXy5pc0xhenkoKSwgXy5sb2MsICdDYW4gbm90IHlpZWxkIHRvIGxhenkgdmFyaWFibGUuJylcblxuXHRcdFx0Y29uc3QgaXNPYmpBc3NpZ24gPSBraW5kID09PSBLV19PYmpBc3NpZ25cblxuXHRcdFx0aWYgKGtpbmQgPT09IEtXX0Fzc2lnbk11dGFibGUpXG5cdFx0XHRcdGZvciAobGV0IF8gb2YgbG9jYWxzKSB7XG5cdFx0XHRcdFx0Y2hlY2soIV8uaXNMYXp5KCksIF8ubG9jLCAnTGF6eSBsb2NhbCBjYW4gbm90IGJlIG11dGFibGUuJylcblx0XHRcdFx0XHRfLmtpbmQgPSBMRF9NdXRhYmxlXG5cdFx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgd3JhcCA9IF8gPT4gaXNPYmpBc3NpZ24gPyBuZXcgT2JqRW50cnlBc3NpZ24obG9jLCBfKSA6IF9cblxuXHRcdFx0aWYgKGxvY2Fscy5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0Y29uc3QgYXNzaWduZWUgPSBsb2NhbHNbMF1cblx0XHRcdFx0Y29uc3QgYXNzaWduID0gbmV3IEFzc2lnblNpbmdsZShsb2MsIGFzc2lnbmVlLCB2YWx1ZSlcblx0XHRcdFx0cmV0dXJuIHdyYXAoYXNzaWduKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3Qga2luZCA9IGxvY2Fsc1swXS5raW5kXG5cdFx0XHRcdGZvciAoY29uc3QgXyBvZiBsb2NhbHMpXG5cdFx0XHRcdFx0Y2hlY2soXy5raW5kID09PSBraW5kLCBfLmxvYyxcblx0XHRcdFx0XHRcdCdBbGwgbG9jYWxzIG9mIGRlc3RydWN0dXJpbmcgYXNzaWdubWVudCBtdXN0IGJlIG9mIHRoZSBzYW1lIGtpbmQuJylcblx0XHRcdFx0cmV0dXJuIHdyYXAobmV3IEFzc2lnbkRlc3RydWN0dXJlKGxvYywgbG9jYWxzLCB2YWx1ZSwga2luZCkpXG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHBhcnNlQXNzaWduVmFsdWUgPSAoa2luZCwgdmFsdWVUb2tlbnMpID0+IHtcblx0XHRjb25zdCB2YWx1ZSA9IHBhcnNlRXhwcih2YWx1ZVRva2Vucylcblx0XHRzd2l0Y2ggKGtpbmQpIHtcblx0XHRcdGNhc2UgS1dfWWllbGQ6XG5cdFx0XHRcdHJldHVybiBuZXcgWWllbGQodmFsdWUubG9jLCB2YWx1ZSlcblx0XHRcdGNhc2UgS1dfWWllbGRUbzpcblx0XHRcdFx0cmV0dXJuIG5ldyBZaWVsZFRvKHZhbHVlLmxvYywgdmFsdWUpXG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gdmFsdWVcblx0XHR9XG5cdH0sXG5cblx0cGFyc2VBc3NlcnQgPSAobmVnYXRlLCB0b2tlbnMpID0+IHtcblx0XHRjaGVja05vbkVtcHR5KHRva2VucywgKCkgPT4gYEV4cGVjdGVkIHNvbWV0aGluZyBhZnRlciAke2tleXdvcmROYW1lKEtXX0Fzc2VydCl9LmApXG5cblx0XHRjb25zdCBbY29uZFRva2Vucywgb3BUaHJvd25dID1cblx0XHRcdGlmRWxzZSh0b2tlbnMub3BTcGxpdE9uY2VXaGVyZShfID0+IGlzS2V5d29yZChLV19UaHJvdywgXykpLFxuXHRcdFx0XHQoe2JlZm9yZSwgYWZ0ZXJ9KSA9PiBbYmVmb3JlLCBwYXJzZUV4cHIoYWZ0ZXIpXSxcblx0XHRcdFx0KCkgPT4gW3Rva2VucywgbnVsbF0pXG5cblx0XHRjb25zdCBwYXJ0cyA9IHBhcnNlRXhwclBhcnRzKGNvbmRUb2tlbnMpXG5cdFx0Y29uc3QgY29uZCA9IHBhcnRzLmxlbmd0aCA9PT0gMSA/IHBhcnRzWzBdIDogbmV3IENhbGwoY29uZFRva2Vucy5sb2MsIHBhcnRzWzBdLCB0YWlsKHBhcnRzKSlcblx0XHRyZXR1cm4gbmV3IEFzc2VydCh0b2tlbnMubG9jLCBuZWdhdGUsIGNvbmQsIG9wVGhyb3duKVxuXHR9LFxuXG5cdHBhcnNlSWdub3JlID0gdG9rZW5zID0+IHtcblx0XHRjb25zdCBpZ25vcmVkID0gdG9rZW5zLm1hcChfID0+IHtcblx0XHRcdGlmIChpc0tleXdvcmQoS1dfRm9jdXMsIF8pKVxuXHRcdFx0XHRyZXR1cm4gJ18nXG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Y2hlY2soXyBpbnN0YW5jZW9mIE5hbWUsIF8ubG9jLCAoKSA9PiBgRXhwZWN0ZWQgbG9jYWwgbmFtZSwgbm90ICR7X30uYClcblx0XHRcdFx0cmV0dXJuIF8ubmFtZVxuXHRcdFx0fVxuXHRcdH0pXG5cdFx0cmV0dXJuIG5ldyBJZ25vcmUodG9rZW5zLmxvYywgaWdub3JlZClcblx0fSJdLCJzb3VyY2VSb290IjoiL3NyYyJ9
