if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports', '../MsAst', '../Token', '../util', './context', './parseBlock', './parseCase', './parseExcept', './parseFor', './parseLine', './parseLocalDeclares', './parseQuote', './parse*', './Slice'], function (exports, _MsAst, _Token, _util, _context, _parseBlock, _parseCase, _parseExcept, _parseFor, _parseLine, _parseLocalDeclares, _parseQuote, _parse, _Slice) {
	'use strict';

	Object.defineProperty(exports, '__esModule', {
		value: true
	});

	var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _parseCase2 = _interopRequireDefault(_parseCase);

	var _parseExcept2 = _interopRequireDefault(_parseExcept);

	var _parseLine2 = _interopRequireDefault(_parseLine);

	var _parseLocalDeclares2 = _interopRequireDefault(_parseLocalDeclares);

	var _parseQuote2 = _interopRequireDefault(_parseQuote);

	var _Slice2 = _interopRequireDefault(_Slice);

	exports.default = tokens => {
		const head = tokens.head();
		const rest = tokens.tail();

		const noRest = () => (0, _context.checkEmpty)(rest, () => `Did not expect anything after ${ head }.`);

		// We only deal with mutable expressions here, otherwise we fall back to parseExpr.
		if (head instanceof _Token.Keyword) switch (head.kind) {
			case _Token.KW_Assert:case _Token.KW_AssertNot:
				return parseAssert(head.kind === _Token.KW_AssertNot, rest);
			case _Token.KW_ExceptDo:
				return (0, _parseExcept2.default)(_Token.KW_ExceptDo, rest);
			case _Token.KW_Break:
				noRest();
				return new _MsAst.Break(tokens.loc);
			case _Token.KW_BreakWithVal:
				return new _MsAst.BreakWithVal(tokens.loc, (0, _parse.parseExpr)(rest));
			case _Token.KW_CaseDo:
				return (0, _parseCase2.default)(false, false, rest);
			case _Token.KW_Debugger:
				noRest();
				return new _MsAst.SpecialDo(tokens.loc, _MsAst.SD_Debugger);
			case _Token.KW_Ellipsis:
				return new _MsAst.BagEntryMany(tokens.loc, (0, _parse.parseExpr)(rest));
			case _Token.KW_ForDo:
				return (0, _parseFor.parseForDo)(rest);
			case _Token.KW_Ignore:
				return parseIgnore(rest);
			case _Token.KW_IfDo:case _Token.KW_UnlessDo:
				{
					var _beforeAndBlock = (0, _parseBlock.beforeAndBlock)(rest);

					var _beforeAndBlock2 = _slicedToArray(_beforeAndBlock, 2);

					const before = _beforeAndBlock2[0];
					const block = _beforeAndBlock2[1];

					return new _MsAst.ConditionalDo(tokens.loc, (0, _parse.parseExpr)(before), (0, _parseBlock.parseBlockDo)(block), head.kind === _Token.KW_UnlessDo);
				}
			case _Token.KW_ObjAssign:
				return new _MsAst.BagEntry(tokens.loc, (0, _parse.parseExpr)(rest));
			case _Token.KW_Pass:
				noRest();
				return [];
			case _Token.KW_Region:
				return (0, _parseBlock.parseLinesFromBlock)(tokens);
			case _Token.KW_SuperDo:
				return new _MsAst.SuperCallDo(tokens.loc, (0, _parse.parseExprParts)(rest));
			case _Token.KW_SwitchDo:
				return (0, _parse.parseSwitch)(false, false, rest);
			case _Token.KW_Throw:
				return new _MsAst.Throw(tokens.loc, (0, _util.opIf)(!rest.isEmpty(), () => (0, _parse.parseExpr)(rest)));
			case _Token.KW_Name:
				if ((0, _Token.isKeyword)(_Token.KW_ObjAssign, rest.head())) {
					const r = rest.tail();
					const val = r.isEmpty() ? new _MsAst.SpecialVal(tokens.loc, _MsAst.SV_Name) : (0, _parse.parseExpr)(r);
					return _MsAst.ObjEntryComputed.name(tokens.loc, val);
				}
			// else fall through
			default:
			// fall through
		}

		return (0, _util.ifElse)(tokens.opSplitOnceWhere(isLineSplitKeyword), _ref => {
			let before = _ref.before;
			let at = _ref.at;
			let after = _ref.after;
			return parseAssignLike(before, at, after, tokens.loc);
		}, () => (0, _parse.parseExpr)(tokens));
	};

	const parseLineOrLines = tokens => {
		const _ = (0, _parseLine2.default)(tokens);
		return _ instanceof Array ? _ : [_];
	};

	exports.parseLineOrLines = parseLineOrLines;
	const isLineSplitKeyword = token => {
		if (token instanceof _Token.Keyword) switch (token.kind) {
			case _Token.KW_Assign:case _Token.KW_AssignMutable:case _Token.KW_LocalMutate:
			case _Token.KW_MapEntry:case _Token.KW_ObjAssign:case _Token.KW_Yield:case _Token.KW_YieldTo:
				return true;
			default:
				return false;
		} else return false;
	},
	      parseAssignLike = (before, at, after, loc) => {
		const kind = at.kind;
		if (kind === _Token.KW_MapEntry) return new _MsAst.MapEntry(loc, (0, _parse.parseExpr)(before), (0, _parse.parseExpr)(after));

		if (before.size() === 1) {
			const token = before.head();

			// `.x = y`
			if (token instanceof _Token.DotName) return parseMemberSet(_MsAst.LocalAccess.this(token.loc), token.name, null, at, after, loc);
			// `x.y = z`
			else if ((0, _Token.isGroup)(_Token.G_Space, token)) {
					const spaced = _Slice2.default.group(token);

					var _ifElse = (0, _util.ifElse)(spaced.opSplitOnceWhere(_ => (0, _Token.isKeyword)(_Token.KW_Type, _)), _ref2 => {
						let before = _ref2.before;
						let after = _ref2.after;
						return [before, (0, _parse.parseExpr)(after)];
					}, () => [spaced, null]);

					var _ifElse2 = _slicedToArray(_ifElse, 2);

					const value = _ifElse2[0];
					const opType = _ifElse2[1];

					const last = value.last();
					const object = () => {
						const obj = value.rtail();
						return obj.isEmpty() ? _MsAst.LocalAccess.this(obj.loc) : (0, _parse.parseSpaced)(obj);
					};

					if (last instanceof _Token.DotName) {
						_context.context.check(last.nDots === 1, last.loc, 'Must have only 1 `.`.');
						return parseMemberSet(object(), last.name, opType, at, after, loc);
					} else if ((0, _Token.isGroup)(_Token.G_Bracket, last)) return parseSubSet(object(), _Slice2.default.group(last), opType, at, after, loc);
					// `"1". 1`
				} else if ((0, _Token.isGroup)(_Token.G_Quote, token) && kind === _Token.KW_ObjAssign) return new _MsAst.ObjEntryComputed(loc, (0, _parseQuote2.default)(_Slice2.default.group(token)), (0, _parse.parseExpr)(after));
		}

		return kind === _Token.KW_LocalMutate ? parseLocalMutate(before, after, loc) : parseAssign(before, kind, after, loc);
	},
	      parseMemberSet = (object, name, opType, at, after, loc) => new _MsAst.MemberSet(loc, object, name, opType, memberSetKind(at), (0, _parse.parseExpr)(after)),
	      memberSetKind = at => {
		switch (at.kind) {
			case _Token.KW_Assign:
				return _MsAst.SET_Init;
			case _Token.KW_AssignMutable:
				return _MsAst.SET_InitMutable;
			case _Token.KW_LocalMutate:
				return _MsAst.SET_Mutate;
			default:
				(0, _context.unexpected)(at);
		}
	},
	      parseSubSet = (object, subbed, opType, at, after, loc) => {
		const subbeds = (0, _parse.parseExprParts)(subbed);
		return new _MsAst.SetSub(loc, object, subbeds, opType, memberSetKind(at), (0, _parse.parseExpr)(after));
	},
	      parseLocalMutate = (localsTokens, valueTokens, loc) => {
		const locals = (0, _parseLocalDeclares.parseLocalDeclaresJustNames)(localsTokens);
		_context.context.check(locals.length === 1, loc, 'TODO: LocalDestructureMutate');
		const name = locals[0].name;
		const value = (0, _parse.parseExpr)(valueTokens);
		return new _MsAst.LocalMutate(loc, name, value);
	},
	      parseAssign = (localsTokens, kind, valueTokens, loc) => {
		const locals = (0, _parseLocalDeclares2.default)(localsTokens);
		const value = parseAssignValue(kind, valueTokens);

		const isYield = kind === _Token.KW_Yield || kind === _Token.KW_YieldTo;
		if ((0, _util.isEmpty)(locals)) {
			_context.context.check(isYield, localsTokens.loc, 'Assignment to nothing');
			return value;
		} else {
			if (isYield) for (const _ of locals) _context.context.check(!_.isLazy(), _.loc, 'Can not yield to lazy variable.');

			const isObjAssign = kind === _Token.KW_ObjAssign;

			if (kind === _Token.KW_AssignMutable) for (let _ of locals) {
				_context.context.check(!_.isLazy(), _.loc, 'Lazy local can not be mutable.');
				_.kind = _MsAst.LD_Mutable;
			}

			const wrap = _ => isObjAssign ? new _MsAst.ObjEntryAssign(loc, _) : _;

			if (locals.length === 1) {
				const assignee = locals[0];
				const assign = new _MsAst.AssignSingle(loc, assignee, value);
				return wrap(assign);
			} else {
				const kind = locals[0].kind;
				for (const _ of locals) _context.context.check(_.kind === kind, _.loc, 'All locals of destructuring assignment must be of the same kind.');
				return wrap(new _MsAst.AssignDestructure(loc, locals, value, kind));
			}
		}
	},
	      parseAssignValue = (kind, valueTokens) => {
		const value = (0, _parse.parseExpr)(valueTokens);
		switch (kind) {
			case _Token.KW_Yield:
				return new _MsAst.Yield(value.loc, value);
			case _Token.KW_YieldTo:
				return new _MsAst.YieldTo(value.loc, value);
			default:
				return value;
		}
	},
	      parseAssert = (negate, tokens) => {
		(0, _context.checkNonEmpty)(tokens, () => `Expected something after ${ (0, _Token.keywordName)(_Token.KW_Assert) }.`);

		var _ifElse3 = (0, _util.ifElse)(tokens.opSplitOnceWhere(_ => (0, _Token.isKeyword)(_Token.KW_Throw, _)), _ref3 => {
			let before = _ref3.before;
			let after = _ref3.after;
			return [before, (0, _parse.parseExpr)(after)];
		}, () => [tokens, null]);

		var _ifElse32 = _slicedToArray(_ifElse3, 2);

		const condTokens = _ifElse32[0];
		const opThrown = _ifElse32[1];

		const parts = (0, _parse.parseExprParts)(condTokens);
		const cond = parts.length === 1 ? parts[0] : new _MsAst.Call(condTokens.loc, parts[0], (0, _util.tail)(parts));
		return new _MsAst.Assert(tokens.loc, negate, cond, opThrown);
	},
	      parseIgnore = tokens => {
		const ignored = tokens.map(_ => {
			if ((0, _Token.isKeyword)(_Token.KW_Focus, _)) return '_';else {
				_context.context.check(_ instanceof _Token.Name, _.loc, () => `Expected local name, not ${ _ }.`);
				return _.name;
			}
		});
		return new _MsAst.Ignore(tokens.loc, ignored);
	};
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhcnNlTGluZS5qcyIsInByaXZhdGUvcGFyc2UvcGFyc2VMaW5lLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttQkNxQmUsTUFBTSxJQUFJO0FBQ3hCLFFBQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQTtBQUMxQixRQUFNLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUE7O0FBRTFCLFFBQU0sTUFBTSxHQUFHLE1BQ2QsYUFoQk0sVUFBVSxFQWdCTCxJQUFJLEVBQUUsTUFBTSxDQUFDLDhCQUE4QixHQUFFLElBQUksRUFBQyxDQUFDLENBQUMsQ0FBQyxDQUFBOzs7QUFHakUsTUFBSSxJQUFJLG1CQXpCeUQsT0FBTyxBQXlCN0MsRUFDMUIsUUFBUSxJQUFJLENBQUMsSUFBSTtBQUNoQixlQTNCcUYsU0FBUyxDQTJCL0UsQUFBQyxZQTFCbEIsWUFBWTtBQTJCVCxXQUFPLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxZQTNCL0IsWUFBWSxBQTJCb0MsRUFBRSxJQUFJLENBQUMsQ0FBQTtBQUFBLEFBQ3JELGVBM0JXLFdBQVc7QUE0QnJCLFdBQU8sa0NBNUJHLFdBQVcsRUE0QlcsSUFBSSxDQUFDLENBQUE7QUFBQSxBQUN0QyxlQTlCeUMsUUFBUTtBQStCaEQsVUFBTSxFQUFFLENBQUE7QUFDUixXQUFPLFdBckM4RCxLQUFLLENBcUN6RCxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUE7QUFBQSxBQUM3QixlQWpDbUQsZUFBZTtBQWtDakUsV0FBTyxXQXZDcUUsWUFBWSxDQXVDaEUsTUFBTSxDQUFDLEdBQUcsRUFBRSxXQXJCaEMsU0FBUyxFQXFCaUMsSUFBSSxDQUFDLENBQUMsQ0FBQTtBQUFBLEFBQ3JELGVBbkNvRSxTQUFTO0FBb0M1RSxXQUFPLHlCQUFVLEtBQUssRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUE7QUFBQSxBQUNyQyxlQXJDK0UsV0FBVztBQXNDekYs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QUFHLENBQUEsS0FDTjtBQUNKLGFBdE8rQixPQUFPLENBc085QixLQUFLLENBQUMsQ0FBQyxtQkF4T2lCLElBQUksQUF3T0wsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyx5QkFBeUIsR0FBRSxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtBQUMvRSxXQUFPLENBQUMsQ0FBQyxJQUFJLENBQUE7SUFDYjtHQUNELENBQUMsQ0FBQTtBQUNGLFNBQU8sV0FuUE8sTUFBTSxDQW1QRixNQUFNLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxDQUFBO0VBQ3RDLENBQUEiLCJmaWxlIjoicHJpdmF0ZS9wYXJzZS9wYXJzZUxpbmUuanMiLCJzb3VyY2VzQ29udGVudCI6W251bGwsImltcG9ydCB7QXNzZXJ0LCBBc3NpZ25TaW5nbGUsIEFzc2lnbkRlc3RydWN0dXJlLCBCYWdFbnRyeSwgQmFnRW50cnlNYW55LCBCcmVhaywgQnJlYWtXaXRoVmFsLCBDYWxsLFxuXHRDb25kaXRpb25hbERvLCBJZ25vcmUsIExEX011dGFibGUsIExvY2FsQWNjZXNzLCBMb2NhbE11dGF0ZSwgTWFwRW50cnksIE1lbWJlclNldCxcblx0T2JqRW50cnlBc3NpZ24sIE9iakVudHJ5Q29tcHV0ZWQsIFNEX0RlYnVnZ2VyLCBTRVRfSW5pdCwgU0VUX0luaXRNdXRhYmxlLCBTRVRfTXV0YXRlLCBTZXRTdWIsXG5cdFNwZWNpYWxEbywgU3BlY2lhbFZhbCwgU3VwZXJDYWxsRG8sIFNWX05hbWUsIFRocm93LCBZaWVsZCwgWWllbGRUb30gZnJvbSAnLi4vTXNBc3QnXG5pbXBvcnQge0RvdE5hbWUsIEdfQnJhY2tldCwgR19RdW90ZSwgR19TcGFjZSwgaXNHcm91cCwgaXNLZXl3b3JkLCBLZXl3b3JkLCBrZXl3b3JkTmFtZSwgS1dfQXNzZXJ0LFxuXHRLV19Bc3NlcnROb3QsIEtXX0Fzc2lnbiwgS1dfQXNzaWduTXV0YWJsZSwgS1dfQnJlYWssIEtXX0JyZWFrV2l0aFZhbCwgS1dfQ2FzZURvLCBLV19EZWJ1Z2dlcixcblx0S1dfRWxsaXBzaXMsIEtXX0V4Y2VwdERvLCBLV19Gb2N1cywgS1dfRm9yRG8sIEtXX0lmRG8sIEtXX0lnbm9yZSwgS1dfTG9jYWxNdXRhdGUsIEtXX01hcEVudHJ5LFxuXHRLV19OYW1lLCBLV19PYmpBc3NpZ24sIEtXX1Bhc3MsIEtXX1JlZ2lvbiwgS1dfU3VwZXJEbywgS1dfU3dpdGNoRG8sIEtXX1Rocm93LCBLV19UeXBlLFxuXHRLV19Vbmxlc3NEbywgS1dfWWllbGQsIEtXX1lpZWxkVG8sIE5hbWV9IGZyb20gJy4uL1Rva2VuJ1xuaW1wb3J0IHtpZkVsc2UsIGlzRW1wdHksIG9wSWYsIHRhaWx9IGZyb20gJy4uL3V0aWwnXG5pbXBvcnQge2NoZWNrRW1wdHksIGNoZWNrTm9uRW1wdHksIGNvbnRleHQsIHVuZXhwZWN0ZWR9IGZyb20gJy4vY29udGV4dCdcbmltcG9ydCB7YmVmb3JlQW5kQmxvY2ssIHBhcnNlQmxvY2tEbywgcGFyc2VMaW5lc0Zyb21CbG9ja30gZnJvbSAnLi9wYXJzZUJsb2NrJ1xuaW1wb3J0IHBhcnNlQ2FzZSBmcm9tICcuL3BhcnNlQ2FzZSdcbmltcG9ydCBwYXJzZUV4Y2VwdCBmcm9tICcuL3BhcnNlRXhjZXB0J1xuaW1wb3J0IHtwYXJzZUZvckRvfSBmcm9tICcuL3BhcnNlRm9yJ1xuaW1wb3J0IHBhcnNlTGluZSBmcm9tICcuL3BhcnNlTGluZSdcbmltcG9ydCBwYXJzZUxvY2FsRGVjbGFyZXMsIHtwYXJzZUxvY2FsRGVjbGFyZXNKdXN0TmFtZXN9IGZyb20gJy4vcGFyc2VMb2NhbERlY2xhcmVzJ1xuaW1wb3J0IHBhcnNlUXVvdGUgZnJvbSAnLi9wYXJzZVF1b3RlJ1xuaW1wb3J0IHtwYXJzZUV4cHIsIHBhcnNlRXhwclBhcnRzLCBwYXJzZVNwYWNlZCwgcGFyc2VTd2l0Y2h9IGZyb20gJy4vcGFyc2UqJ1xuaW1wb3J0IFNsaWNlIGZyb20gJy4vU2xpY2UnXG5cbmV4cG9ydCBkZWZhdWx0IHRva2VucyA9PiB7XG5cdGNvbnN0IGhlYWQgPSB0b2tlbnMuaGVhZCgpXG5cdGNvbnN0IHJlc3QgPSB0b2tlbnMudGFpbCgpXG5cblx0Y29uc3Qgbm9SZXN0ID0gKCkgPT5cblx0XHRjaGVja0VtcHR5KHJlc3QsICgpID0+IGBEaWQgbm90IGV4cGVjdCBhbnl0aGluZyBhZnRlciAke2hlYWR9LmApXG5cblx0Ly8gV2Ugb25seSBkZWFsIHdpdGggbXV0YWJsZSBleHByZXNzaW9ucyBoZXJlLCBvdGhlcndpc2Ugd2UgZmFsbCBiYWNrIHRvIHBhcnNlRXhwci5cblx0aWYgKGhlYWQgaW5zdGFuY2VvZiBLZXl3b3JkKVxuXHRcdHN3aXRjaCAoaGVhZC5raW5kKSB7XG5cdFx0XHRjYXNlIEtXX0Fzc2VydDogY2FzZSBLV19Bc3NlcnROb3Q6XG5cdFx0XHRcdHJldHVybiBwYXJzZUFzc2VydChoZWFkLmtpbmQgPT09IEtXX0Fzc2VydE5vdCwgcmVzdClcblx0XHRcdGNhc2UgS1dfRXhjZXB0RG86XG5cdFx0XHRcdHJldHVybiBwYXJzZUV4Y2VwdChLV19FeGNlcHREbywgcmVzdClcblx0XHRcdGNhc2UgS1dfQnJlYWs6XG5cdFx0XHRcdG5vUmVzdCgpXG5cdFx0XHRcdHJldHVybiBuZXcgQnJlYWsodG9rZW5zLmxvYylcblx0XHRcdGNhc2UgS1dfQnJlYWtXaXRoVmFsOlxuXHRcdFx0XHRyZXR1cm4gbmV3IEJyZWFrV2l0aFZhbCh0b2tlbnMubG9jLCBwYXJzZUV4cHIocmVzdCkpXG5cdFx0XHRjYXNlIEtXX0Nhc2VEbzpcblx0XHRcdFx0cmV0dXJuIHBhcnNlQ2FzZShmYWxzZSwgZmFsc2UsIHJlc3QpXG5cdFx0XHRjYXNlIEtXX0RlYnVnZ2VyOlxuXHRcdFx0XHRub1Jlc3QoKVxuXHRcdFx0XHRyZXR1cm4gbmV3IFNwZWNpYWxEbyh0b2tlbnMubG9jLCBTRF9EZWJ1Z2dlcilcblx0XHRcdGNhc2UgS1dfRWxsaXBzaXM6XG5cdFx0XHRcdHJldHVybiBuZXcgQmFnRW50cnlNYW55KHRva2Vucy5sb2MsIHBhcnNlRXhwcihyZXN0KSlcblx0XHRcdGNhc2UgS1dfRm9yRG86XG5cdFx0XHRcdHJldHVybiBwYXJzZUZvckRvKHJlc3QpXG5cdFx0XHRjYXNlIEtXX0lnbm9yZTpcblx0XHRcdFx0cmV0dXJuIHBhcnNlSWdub3JlKHJlc3QpXG5cdFx0XHRjYXNlIEtXX0lmRG86IGNhc2UgS1dfVW5sZXNzRG86IHtcblx0XHRcdFx0Y29uc3QgW2JlZm9yZSwgYmxvY2tdID0gYmVmb3JlQW5kQmxvY2socmVzdClcblx0XHRcdFx0cmV0dXJuIG5ldyBDb25kaXRpb25hbERvKHRva2Vucy5sb2MsXG5cdFx0XHRcdFx0cGFyc2VFeHByKGJlZm9yZSksXG5cdFx0XHRcdFx0cGFyc2VCbG9ja0RvKGJsb2NrKSxcblx0XHRcdFx0XHRoZWFkLmtpbmQgPT09IEtXX1VubGVzc0RvKVxuXHRcdFx0fVxuXHRcdFx0Y2FzZSBLV19PYmpBc3NpZ246XG5cdFx0XHRcdHJldHVybiBuZXcgQmFnRW50cnkodG9rZW5zLmxvYywgcGFyc2VFeHByKHJlc3QpKVxuXHRcdFx0Y2FzZSBLV19QYXNzOlxuXHRcdFx0XHRub1Jlc3QoKVxuXHRcdFx0XHRyZXR1cm4gW11cblx0XHRcdGNhc2UgS1dfUmVnaW9uOlxuXHRcdFx0XHRyZXR1cm4gcGFyc2VMaW5lc0Zyb21CbG9jayh0b2tlbnMpXG5cdFx0XHRjYXNlIEtXX1N1cGVyRG86XG5cdFx0XHRcdHJldHVybiBuZXcgU3VwZXJDYWxsRG8odG9rZW5zLmxvYywgcGFyc2VFeHByUGFydHMocmVzdCkpXG5cdFx0XHRjYXNlIEtXX1N3aXRjaERvOlxuXHRcdFx0XHRyZXR1cm4gcGFyc2VTd2l0Y2goZmFsc2UsIGZhbHNlLCByZXN0KVxuXHRcdFx0Y2FzZSBLV19UaHJvdzpcblx0XHRcdFx0cmV0dXJuIG5ldyBUaHJvdyh0b2tlbnMubG9jLCBvcElmKCFyZXN0LmlzRW1wdHkoKSwgKCkgPT4gcGFyc2VFeHByKHJlc3QpKSlcblx0XHRcdGNhc2UgS1dfTmFtZTpcblx0XHRcdFx0aWYgKGlzS2V5d29yZChLV19PYmpBc3NpZ24sIHJlc3QuaGVhZCgpKSkge1xuXHRcdFx0XHRcdGNvbnN0IHIgPSByZXN0LnRhaWwoKVxuXHRcdFx0XHRcdGNvbnN0IHZhbCA9IHIuaXNFbXB0eSgpID8gbmV3IFNwZWNpYWxWYWwodG9rZW5zLmxvYywgU1ZfTmFtZSkgOiBwYXJzZUV4cHIocilcblx0XHRcdFx0XHRyZXR1cm4gT2JqRW50cnlDb21wdXRlZC5uYW1lKHRva2Vucy5sb2MsIHZhbClcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBlbHNlIGZhbGwgdGhyb3VnaFxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0Ly8gZmFsbCB0aHJvdWdoXG5cdFx0fVxuXG5cdHJldHVybiBpZkVsc2UodG9rZW5zLm9wU3BsaXRPbmNlV2hlcmUoaXNMaW5lU3BsaXRLZXl3b3JkKSxcblx0XHQoe2JlZm9yZSwgYXQsIGFmdGVyfSkgPT4gcGFyc2VBc3NpZ25MaWtlKGJlZm9yZSwgYXQsIGFmdGVyLCB0b2tlbnMubG9jKSxcblx0XHQoKSA9PiBwYXJzZUV4cHIodG9rZW5zKSlcbn1cblxuZXhwb3J0IGNvbnN0IHBhcnNlTGluZU9yTGluZXMgPSB0b2tlbnMgPT4ge1xuXHRjb25zdCBfID0gcGFyc2VMaW5lKHRva2Vucylcblx0cmV0dXJuIF8gaW5zdGFuY2VvZiBBcnJheSA/IF8gOiBbX11cbn1cblxuY29uc3Rcblx0aXNMaW5lU3BsaXRLZXl3b3JkID0gdG9rZW4gPT4ge1xuXHRcdGlmICh0b2tlbiBpbnN0YW5jZW9mIEtleXdvcmQpXG5cdFx0XHRzd2l0Y2ggKHRva2VuLmtpbmQpIHtcblx0XHRcdFx0Y2FzZSBLV19Bc3NpZ246IGNhc2UgS1dfQXNzaWduTXV0YWJsZTogY2FzZSBLV19Mb2NhbE11dGF0ZTpcblx0XHRcdFx0Y2FzZSBLV19NYXBFbnRyeTogY2FzZSBLV19PYmpBc3NpZ246IGNhc2UgS1dfWWllbGQ6IGNhc2UgS1dfWWllbGRUbzpcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHJldHVybiBmYWxzZVxuXHRcdFx0fVxuXHRcdGVsc2Vcblx0XHRcdHJldHVybiBmYWxzZVxuXHR9LFxuXG5cdHBhcnNlQXNzaWduTGlrZSA9IChiZWZvcmUsIGF0LCBhZnRlciwgbG9jKSA9PiB7XG5cdFx0Y29uc3Qga2luZCA9IGF0LmtpbmRcblx0XHRpZiAoa2luZCA9PT0gS1dfTWFwRW50cnkpXG5cdFx0XHRyZXR1cm4gbmV3IE1hcEVudHJ5KGxvYywgcGFyc2VFeHByKGJlZm9yZSksIHBhcnNlRXhwcihhZnRlcikpXG5cblx0XHRpZiAoYmVmb3JlLnNpemUoKSA9PT0gMSkge1xuXHRcdFx0Y29uc3QgdG9rZW4gPSBiZWZvcmUuaGVhZCgpXG5cblx0XHRcdC8vIGAueCA9IHlgXG5cdFx0XHRpZiAodG9rZW4gaW5zdGFuY2VvZiBEb3ROYW1lKVxuXHRcdFx0XHRyZXR1cm4gcGFyc2VNZW1iZXJTZXQoTG9jYWxBY2Nlc3MudGhpcyh0b2tlbi5sb2MpLCB0b2tlbi5uYW1lLCBudWxsLCBhdCwgYWZ0ZXIsIGxvYylcblx0XHRcdC8vIGB4LnkgPSB6YFxuXHRcdFx0ZWxzZSBpZiAoaXNHcm91cChHX1NwYWNlLCB0b2tlbikpIHtcblx0XHRcdFx0Y29uc3Qgc3BhY2VkID0gU2xpY2UuZ3JvdXAodG9rZW4pXG5cdFx0XHRcdGNvbnN0IFt2YWx1ZSwgb3BUeXBlXSA9IGlmRWxzZShzcGFjZWQub3BTcGxpdE9uY2VXaGVyZShfID0+IGlzS2V5d29yZChLV19UeXBlLCBfKSksXG5cdFx0XHRcdFx0KHtiZWZvcmUsIGFmdGVyfSkgPT4gW2JlZm9yZSwgcGFyc2VFeHByKGFmdGVyKV0sXG5cdFx0XHRcdFx0KCkgPT4gW3NwYWNlZCwgbnVsbF0pXG5cblx0XHRcdFx0Y29uc3QgbGFzdCA9IHZhbHVlLmxhc3QoKVxuXHRcdFx0XHRjb25zdCBvYmplY3QgPSAoKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3Qgb2JqID0gdmFsdWUucnRhaWwoKVxuXHRcdFx0XHRcdHJldHVybiBvYmouaXNFbXB0eSgpID8gTG9jYWxBY2Nlc3MudGhpcyhvYmoubG9jKSA6IHBhcnNlU3BhY2VkKG9iailcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChsYXN0IGluc3RhbmNlb2YgRG90TmFtZSkge1xuXHRcdFx0XHRcdGNvbnRleHQuY2hlY2sobGFzdC5uRG90cyA9PT0gMSwgbGFzdC5sb2MsICdNdXN0IGhhdmUgb25seSAxIGAuYC4nKVxuXHRcdFx0XHRcdHJldHVybiBwYXJzZU1lbWJlclNldChvYmplY3QoKSwgbGFzdC5uYW1lLCBvcFR5cGUsIGF0LCBhZnRlciwgbG9jKVxuXHRcdFx0XHR9IGVsc2UgaWYgKGlzR3JvdXAoR19CcmFja2V0LCBsYXN0KSlcblx0XHRcdFx0XHRyZXR1cm4gcGFyc2VTdWJTZXQob2JqZWN0KCksIFNsaWNlLmdyb3VwKGxhc3QpLCBvcFR5cGUsIGF0LCBhZnRlciwgbG9jKVxuXHRcdFx0Ly8gYFwiMVwiLiAxYFxuXHRcdFx0fSBlbHNlIGlmIChpc0dyb3VwKEdfUXVvdGUsIHRva2VuKSAmJiBraW5kID09PSBLV19PYmpBc3NpZ24pXG5cdFx0XHRcdHJldHVybiBuZXcgT2JqRW50cnlDb21wdXRlZChsb2MsIHBhcnNlUXVvdGUoU2xpY2UuZ3JvdXAodG9rZW4pKSwgcGFyc2VFeHByKGFmdGVyKSlcblx0XHR9XG5cblx0XHRyZXR1cm4ga2luZCA9PT0gS1dfTG9jYWxNdXRhdGUgP1xuXHRcdFx0cGFyc2VMb2NhbE11dGF0ZShiZWZvcmUsIGFmdGVyLCBsb2MpIDpcblx0XHRcdHBhcnNlQXNzaWduKGJlZm9yZSwga2luZCwgYWZ0ZXIsIGxvYylcblx0fSxcblxuXHRwYXJzZU1lbWJlclNldCA9IChvYmplY3QsIG5hbWUsIG9wVHlwZSwgYXQsIGFmdGVyLCBsb2MpID0+XG5cdFx0bmV3IE1lbWJlclNldChsb2MsIG9iamVjdCwgbmFtZSwgb3BUeXBlLCBtZW1iZXJTZXRLaW5kKGF0KSwgcGFyc2VFeHByKGFmdGVyKSksXG5cdG1lbWJlclNldEtpbmQgPSBhdCA9PiB7XG5cdFx0c3dpdGNoIChhdC5raW5kKSB7XG5cdFx0XHRjYXNlIEtXX0Fzc2lnbjpcblx0XHRcdFx0cmV0dXJuIFNFVF9Jbml0XG5cdFx0XHRjYXNlIEtXX0Fzc2lnbk11dGFibGU6XG5cdFx0XHRcdHJldHVybiBTRVRfSW5pdE11dGFibGVcblx0XHRcdGNhc2UgS1dfTG9jYWxNdXRhdGU6XG5cdFx0XHRcdHJldHVybiBTRVRfTXV0YXRlXG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR1bmV4cGVjdGVkKGF0KVxuXHRcdH1cblx0fSxcblxuXHRwYXJzZVN1YlNldCA9IChvYmplY3QsIHN1YmJlZCwgb3BUeXBlLCBhdCwgYWZ0ZXIsIGxvYykgPT4ge1xuXHRcdGNvbnN0IHN1YmJlZHMgPSBwYXJzZUV4cHJQYXJ0cyhzdWJiZWQpXG5cdFx0cmV0dXJuIG5ldyBTZXRTdWIobG9jLCBvYmplY3QsIHN1YmJlZHMsIG9wVHlwZSwgbWVtYmVyU2V0S2luZChhdCksIHBhcnNlRXhwcihhZnRlcikpXG5cdH0sXG5cblx0cGFyc2VMb2NhbE11dGF0ZSA9IChsb2NhbHNUb2tlbnMsIHZhbHVlVG9rZW5zLCBsb2MpID0+IHtcblx0XHRjb25zdCBsb2NhbHMgPSBwYXJzZUxvY2FsRGVjbGFyZXNKdXN0TmFtZXMobG9jYWxzVG9rZW5zKVxuXHRcdGNvbnRleHQuY2hlY2sobG9jYWxzLmxlbmd0aCA9PT0gMSwgbG9jLCAnVE9ETzogTG9jYWxEZXN0cnVjdHVyZU11dGF0ZScpXG5cdFx0Y29uc3QgbmFtZSA9IGxvY2Fsc1swXS5uYW1lXG5cdFx0Y29uc3QgdmFsdWUgPSBwYXJzZUV4cHIodmFsdWVUb2tlbnMpXG5cdFx0cmV0dXJuIG5ldyBMb2NhbE11dGF0ZShsb2MsIG5hbWUsIHZhbHVlKVxuXHR9LFxuXG5cdHBhcnNlQXNzaWduID0gKGxvY2Fsc1Rva2Vucywga2luZCwgdmFsdWVUb2tlbnMsIGxvYykgPT4ge1xuXHRcdGNvbnN0IGxvY2FscyA9IHBhcnNlTG9jYWxEZWNsYXJlcyhsb2NhbHNUb2tlbnMpXG5cdFx0Y29uc3QgdmFsdWUgPSBwYXJzZUFzc2lnblZhbHVlKGtpbmQsIHZhbHVlVG9rZW5zKVxuXG5cdFx0Y29uc3QgaXNZaWVsZCA9IGtpbmQgPT09IEtXX1lpZWxkIHx8IGtpbmQgPT09IEtXX1lpZWxkVG9cblx0XHRpZiAoaXNFbXB0eShsb2NhbHMpKSB7XG5cdFx0XHRjb250ZXh0LmNoZWNrKGlzWWllbGQsIGxvY2Fsc1Rva2Vucy5sb2MsICdBc3NpZ25tZW50IHRvIG5vdGhpbmcnKVxuXHRcdFx0cmV0dXJuIHZhbHVlXG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChpc1lpZWxkKVxuXHRcdFx0XHRmb3IgKGNvbnN0IF8gb2YgbG9jYWxzKVxuXHRcdFx0XHRcdGNvbnRleHQuY2hlY2soIV8uaXNMYXp5KCksIF8ubG9jLCAnQ2FuIG5vdCB5aWVsZCB0byBsYXp5IHZhcmlhYmxlLicpXG5cblx0XHRcdGNvbnN0IGlzT2JqQXNzaWduID0ga2luZCA9PT0gS1dfT2JqQXNzaWduXG5cblx0XHRcdGlmIChraW5kID09PSBLV19Bc3NpZ25NdXRhYmxlKVxuXHRcdFx0XHRmb3IgKGxldCBfIG9mIGxvY2Fscykge1xuXHRcdFx0XHRcdGNvbnRleHQuY2hlY2soIV8uaXNMYXp5KCksIF8ubG9jLCAnTGF6eSBsb2NhbCBjYW4gbm90IGJlIG11dGFibGUuJylcblx0XHRcdFx0XHRfLmtpbmQgPSBMRF9NdXRhYmxlXG5cdFx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgd3JhcCA9IF8gPT4gaXNPYmpBc3NpZ24gPyBuZXcgT2JqRW50cnlBc3NpZ24obG9jLCBfKSA6IF9cblxuXHRcdFx0aWYgKGxvY2Fscy5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0Y29uc3QgYXNzaWduZWUgPSBsb2NhbHNbMF1cblx0XHRcdFx0Y29uc3QgYXNzaWduID0gbmV3IEFzc2lnblNpbmdsZShsb2MsIGFzc2lnbmVlLCB2YWx1ZSlcblx0XHRcdFx0cmV0dXJuIHdyYXAoYXNzaWduKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3Qga2luZCA9IGxvY2Fsc1swXS5raW5kXG5cdFx0XHRcdGZvciAoY29uc3QgXyBvZiBsb2NhbHMpXG5cdFx0XHRcdFx0Y29udGV4dC5jaGVjayhfLmtpbmQgPT09IGtpbmQsIF8ubG9jLFxuXHRcdFx0XHRcdFx0J0FsbCBsb2NhbHMgb2YgZGVzdHJ1Y3R1cmluZyBhc3NpZ25tZW50IG11c3QgYmUgb2YgdGhlIHNhbWUga2luZC4nKVxuXHRcdFx0XHRyZXR1cm4gd3JhcChuZXcgQXNzaWduRGVzdHJ1Y3R1cmUobG9jLCBsb2NhbHMsIHZhbHVlLCBraW5kKSlcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cGFyc2VBc3NpZ25WYWx1ZSA9IChraW5kLCB2YWx1ZVRva2VucykgPT4ge1xuXHRcdGNvbnN0IHZhbHVlID0gcGFyc2VFeHByKHZhbHVlVG9rZW5zKVxuXHRcdHN3aXRjaCAoa2luZCkge1xuXHRcdFx0Y2FzZSBLV19ZaWVsZDpcblx0XHRcdFx0cmV0dXJuIG5ldyBZaWVsZCh2YWx1ZS5sb2MsIHZhbHVlKVxuXHRcdFx0Y2FzZSBLV19ZaWVsZFRvOlxuXHRcdFx0XHRyZXR1cm4gbmV3IFlpZWxkVG8odmFsdWUubG9jLCB2YWx1ZSlcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdH1cblx0fSxcblxuXHRwYXJzZUFzc2VydCA9IChuZWdhdGUsIHRva2VucykgPT4ge1xuXHRcdGNoZWNrTm9uRW1wdHkodG9rZW5zLCAoKSA9PiBgRXhwZWN0ZWQgc29tZXRoaW5nIGFmdGVyICR7a2V5d29yZE5hbWUoS1dfQXNzZXJ0KX0uYClcblxuXHRcdGNvbnN0IFtjb25kVG9rZW5zLCBvcFRocm93bl0gPVxuXHRcdFx0aWZFbHNlKHRva2Vucy5vcFNwbGl0T25jZVdoZXJlKF8gPT4gaXNLZXl3b3JkKEtXX1Rocm93LCBfKSksXG5cdFx0XHRcdCh7YmVmb3JlLCBhZnRlcn0pID0+IFtiZWZvcmUsIHBhcnNlRXhwcihhZnRlcildLFxuXHRcdFx0XHQoKSA9PiBbdG9rZW5zLCBudWxsXSlcblxuXHRcdGNvbnN0IHBhcnRzID0gcGFyc2VFeHByUGFydHMoY29uZFRva2Vucylcblx0XHRjb25zdCBjb25kID0gcGFydHMubGVuZ3RoID09PSAxID8gcGFydHNbMF0gOiBuZXcgQ2FsbChjb25kVG9rZW5zLmxvYywgcGFydHNbMF0sIHRhaWwocGFydHMpKVxuXHRcdHJldHVybiBuZXcgQXNzZXJ0KHRva2Vucy5sb2MsIG5lZ2F0ZSwgY29uZCwgb3BUaHJvd24pXG5cdH0sXG5cblx0cGFyc2VJZ25vcmUgPSB0b2tlbnMgPT4ge1xuXHRcdGNvbnN0IGlnbm9yZWQgPSB0b2tlbnMubWFwKF8gPT4ge1xuXHRcdFx0aWYgKGlzS2V5d29yZChLV19Gb2N1cywgXykpXG5cdFx0XHRcdHJldHVybiAnXydcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRjb250ZXh0LmNoZWNrKF8gaW5zdGFuY2VvZiBOYW1lLCBfLmxvYywgKCkgPT4gYEV4cGVjdGVkIGxvY2FsIG5hbWUsIG5vdCAke199LmApXG5cdFx0XHRcdHJldHVybiBfLm5hbWVcblx0XHRcdH1cblx0XHR9KVxuXHRcdHJldHVybiBuZXcgSWdub3JlKHRva2Vucy5sb2MsIGlnbm9yZWQpXG5cdH0iXSwic291cmNlUm9vdCI6Ii9zcmMifQ==
