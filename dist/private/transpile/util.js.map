{"version":3,"sources":["private/transpile/util.js","private/transpile/util.ts"],"names":[],"mappings":"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","file":"private/transpile/util.js","sourcesContent":["(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", 'esast/lib/Declaration', 'esast/lib/Expression', 'esast/lib/Function', 'esast/lib/Identifier', 'esast/lib/Statement', 'esast-create-util/lib/util', 'op/Op', '../context', '../ast/Block', '../ast/Val', '../util', './esast-constants', './context', './transpileBlock', './transpileDo', './transpileVal'], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    var Declaration_1 = require('esast/lib/Declaration');\n    var Expression_1 = require('esast/lib/Expression');\n    var Function_1 = require('esast/lib/Function');\n    var Identifier_1 = require('esast/lib/Identifier');\n    var Statement_1 = require('esast/lib/Statement');\n    var util_1 = require('esast-create-util/lib/util');\n    var Op_1 = require('op/Op');\n    var context_1 = require('../context');\n    var Block_1 = require('../ast/Block');\n    var Val_1 = require('../ast/Val');\n    var util_2 = require('../util');\n    var esast_constants_1 = require('./esast-constants');\n    var context_2 = require('./context');\n    var transpileBlock_1 = require('./transpileBlock');\n    var transpileDo_1 = require('./transpileDo');\n    var transpileVal_1 = require('./transpileVal');\n    function loc(expr, node) {\n        util_2.assert(node.loc === undefined);\n        node.loc = expr.loc;\n        return node;\n    }\n    exports.loc = loc;\n    function tLines(exprs) {\n        const out = [];\n        for (const expr of exprs) {\n            const ast = transpileDo_1.default(expr);\n            if (ast instanceof Array)\n                for (const _ of ast)\n                    out.push(_);\n            else\n                out.push(ast);\n        }\n        return out;\n    }\n    exports.tLines = tLines;\n    function accessLocalDeclare(localDeclare) {\n        const id = idForDeclareCached(localDeclare);\n        return localDeclare.isLazy ? msCall('unlazy', id) : new Identifier_1.default(id.name);\n    }\n    exports.accessLocalDeclare = accessLocalDeclare;\n    function makeDeclare(localDeclare, val) {\n        return new Declaration_1.VariableDeclarationLet([new Declaration_1.VariableDeclarator(idForDeclareCached(localDeclare), val)]);\n    }\n    exports.makeDeclare = makeDeclare;\n    const declareToId = new WeakMap();\n    function idForDeclareCached(localDeclare) {\n        let _ = declareToId.get(localDeclare);\n        if (_ === undefined) {\n            _ = util_1.identifier(localDeclare.name);\n            declareToId.set(localDeclare, _);\n        }\n        return _;\n    }\n    exports.idForDeclareCached = idForDeclareCached;\n    function opTypeCheckForLocalDeclare(localDeclare) {\n        return Op_1.opIf(!localDeclare.isLazy, () => Op_1.opMap(localDeclare.opType, type => new Statement_1.ExpressionStatement(msCall('checkInstance', transpileVal_1.default(type), accessLocalDeclare(localDeclare), new Expression_1.LiteralString(localDeclare.name)))));\n    }\n    exports.opTypeCheckForLocalDeclare = opTypeCheckForLocalDeclare;\n    function makeDeclarator(assignee, value, valueIsAlreadyLazy) {\n        const { name, opType } = assignee;\n        const isLazy = assignee.isLazy;\n        value = isLazy ? value : maybeWrapInCheckInstance(value, opType, name);\n        const val = isLazy && !valueIsAlreadyLazy ? lazyWrap(value) : value;\n        util_2.assert(isLazy || !valueIsAlreadyLazy);\n        return new Declaration_1.VariableDeclarator(idForDeclareCached(assignee), val);\n    }\n    exports.makeDeclarator = makeDeclarator;\n    function maybeWrapInCheckInstance(ast, opType, name) {\n        return context_1.options.checks && Op_1.nonNull(opType) ?\n            msCall('checkInstance', transpileVal_1.default(opType), ast, new Expression_1.LiteralString(name)) :\n            ast;\n    }\n    exports.maybeWrapInCheckInstance = maybeWrapInCheckInstance;\n    function doThrow(thrown) {\n        return new Statement_1.ThrowStatement(thrown instanceof Val_1.QuoteAbstract ?\n            new Expression_1.NewExpression(esast_constants_1.GlobalError, [transpileVal_1.default(thrown)]) :\n            transpileVal_1.default(thrown));\n    }\n    exports.doThrow = doThrow;\n    function memberStringOrVal(object, memberName) {\n        return typeof memberName === 'string' ?\n            util_1.member(object, memberName) :\n            new Expression_1.MemberExpressionComputed(object, transpileVal_1.default(memberName));\n    }\n    exports.memberStringOrVal = memberStringOrVal;\n    function lazyWrap(value) {\n        return msCall('lazy', new Function_1.ArrowFunctionExpression([], value));\n    }\n    exports.lazyWrap = lazyWrap;\n    const IdMs = new Identifier_1.default('_ms');\n    function msCall(name, ...args) {\n        return new Expression_1.CallExpression(util_1.member(IdMs, name), args);\n    }\n    exports.msCall = msCall;\n    function msMember(name) {\n        return util_1.member(IdMs, name);\n    }\n    exports.msMember = msMember;\n    function makeDestructureDeclarators(assignees, isLazy, value, isModule) {\n        const id = context_2.getDestructuredId();\n        const destructuredName = `_$${id}`;\n        const idDestructured = new Identifier_1.default(destructuredName);\n        const declarators = assignees.map(assignee => {\n            const get = getMember(idDestructured, assignee.name, isLazy, isModule);\n            return makeDeclarator(assignee, get, isLazy);\n        });\n        const val = isLazy && !isModule ? lazyWrap(value) : value;\n        return util_2.cat(new Declaration_1.VariableDeclarator(idDestructured, val), declarators);\n    }\n    exports.makeDestructureDeclarators = makeDestructureDeclarators;\n    function getMember(astObject, gotName, isLazy, isModule) {\n        return isLazy ?\n            msCall('lazyProp', astObject, new Expression_1.LiteralString(gotName)) :\n            isModule && context_1.options.checks ?\n                msCall('get', astObject, new Expression_1.LiteralString(gotName)) :\n                util_1.member(astObject, gotName);\n    }\n    function blockWrap(block) {\n        const thunk = context_2.funKind === 0 ?\n            new Function_1.ArrowFunctionExpression([], block) :\n            new Function_1.FunctionExpression(null, [], block, { generator: true });\n        return callPreservingFunKind(new Expression_1.CallExpression(thunk, []));\n    }\n    exports.blockWrap = blockWrap;\n    function blockWrapStatement(statement) {\n        return blockWrap(new Statement_1.BlockStatement([statement]));\n    }\n    exports.blockWrapStatement = blockWrapStatement;\n    function callFocusFun(value, calledOn) {\n        const fun = context_2.funKind === 0 ?\n            new Function_1.ArrowFunctionExpression([esast_constants_1.IdFocus], value) :\n            new Function_1.FunctionExpression(null, [esast_constants_1.IdFocus], new Statement_1.BlockStatement([new Statement_1.ReturnStatement(value)]), { generator: true });\n        return callPreservingFunKind(new Expression_1.CallExpression(fun, [calledOn]));\n    }\n    exports.callFocusFun = callFocusFun;\n    function callPreservingFunKind(call) {\n        return context_2.funKind === 0 ? call : new Expression_1.YieldDelegateExpression(call);\n    }\n    function blockWrapIfBlock(value) {\n        return value instanceof Block_1.default ? blockWrap(transpileBlock_1.default(value)) : (transpileVal_1.default(value));\n    }\n    exports.blockWrapIfBlock = blockWrapIfBlock;\n    function focusFun(value) {\n        return new Function_1.ArrowFunctionExpression([esast_constants_1.IdFocus], value);\n    }\n    exports.focusFun = focusFun;\n    function plainLet(identifier, value) {\n        return new Declaration_1.VariableDeclarationLet([new Declaration_1.VariableDeclarator(identifier, value)]);\n    }\n    exports.plainLet = plainLet;\n});\n","import {VariableDeclarator, VariableDeclarationLet} from 'esast/lib/Declaration'\nimport Expression, {CallExpression, LiteralString, MemberExpression, MemberExpressionComputed, NewExpression, YieldDelegateExpression} from 'esast/lib/Expression'\nimport {ArrowFunctionExpression, FunctionExpression} from 'esast/lib/Function'\nimport Identifier from 'esast/lib/Identifier'\nimport Node from 'esast/lib/Node'\nimport Statement, {BlockStatement, ExpressionStatement, ReturnStatement, ThrowStatement} from 'esast/lib/Statement'\nimport {identifier, loc, member} from 'esast-create-util/lib/util'\nimport Op, {nonNull, opIf, opMap} from 'op/Op'\nimport {options} from '../context'\nimport Block from '../ast/Block'\nimport {Funs} from '../ast/Fun'\nimport LineContent, {Do, Val} from '../ast/LineContent'\nimport {LocalDeclare} from '../ast/locals'\nimport MemberName from '../ast/MemberName'\nimport MsAst from '../ast/MsAst'\nimport {QuoteAbstract} from '../ast/Val'\nimport {assert, cat, toArray} from '../util'\nimport {IdFocus, GlobalError} from './esast-constants'\nimport {funKind, getDestructuredId, verifyResults} from './context'\nimport transpileBlock from './transpileBlock'\nimport transpileDo from './transpileDo'\nimport transpileVal from './transpileVal'\n\n//rename!\nexport function loc<A extends Node>(expr: MsAst, node: A): A {\n\tassert(node.loc === undefined)\n\tnode.loc = expr.loc\n\treturn node\n}\n\n//rename\nexport function tLines(exprs: Array<Do>): Array<Statement> {\n\tconst out: Array<Statement> = []\n\tfor (const expr of exprs) {\n\t\tconst ast = transpileDo(expr)\n\t\tif (ast instanceof Array)\n\t\t\tfor (const _ of ast)\n\t\t\t\tout.push(_)\n\t\telse\n\t\t\tout.push(ast) //was: loc(ast, expr.loc))\n\t}\n\treturn out\n}\n\nexport function accessLocalDeclare(localDeclare: LocalDeclare): Expression {\n\tconst id = idForDeclareCached(localDeclare)\n\treturn localDeclare.isLazy ? msCall('unlazy', id) : new Identifier(id.name)\n}\n\nexport function makeDeclare(localDeclare: LocalDeclare, val: Expression): VariableDeclarationLet {\n\treturn new VariableDeclarationLet(\n\t\t[new VariableDeclarator(idForDeclareCached(localDeclare), val)])\n}\n\nconst declareToId: WeakMap<LocalDeclare, Identifier> = new WeakMap()\nexport function idForDeclareCached(localDeclare: LocalDeclare): Identifier {\n\tlet _ = declareToId.get(localDeclare)\n\tif (_ === undefined) {\n\t\t_ = identifier(localDeclare.name)\n\t\tdeclareToId.set(localDeclare, _)\n\t}\n\treturn _\n}\n\nexport function opTypeCheckForLocalDeclare(localDeclare: LocalDeclare): Op<Statement> {\n\t// TODO: Way to typecheck lazies\n\treturn opIf(!localDeclare.isLazy, () =>\n\t\topMap(localDeclare.opType, type =>\n\t\t\tnew ExpressionStatement(msCall(\n\t\t\t\t'checkInstance',\n\t\t\t\ttranspileVal(type),\n\t\t\t\taccessLocalDeclare(localDeclare),\n\t\t\t\tnew LiteralString(localDeclare.name)))))\n}\n\nexport function makeDeclarator(assignee: LocalDeclare, value: Expression, valueIsAlreadyLazy: boolean): VariableDeclarator {\n\tconst {name, opType} = assignee\n\tconst isLazy = assignee.isLazy\n\t// TODO: assert(assignee.opType === null)\n\t// or TODO: Allow type check on lazy value?\n\tvalue = isLazy ? value : maybeWrapInCheckInstance(value, opType, name)\n\tconst val = isLazy && !valueIsAlreadyLazy ? lazyWrap(value) : value\n\tassert(isLazy || !valueIsAlreadyLazy)\n\treturn new VariableDeclarator(idForDeclareCached(assignee), val)\n}\n\nexport function maybeWrapInCheckInstance(ast: Expression, opType: Op<Val>, name: string): Expression {\n\treturn options.checks && nonNull(opType) ?\n\t\tmsCall('checkInstance', transpileVal(opType), ast, new LiteralString(name)) :\n\t\tast\n}\n\nexport function doThrow(thrown: Val): ThrowStatement {\n\treturn new ThrowStatement(thrown instanceof QuoteAbstract ?\n\t\tnew NewExpression(GlobalError, [transpileVal(thrown)]) :\n\t\ttranspileVal(thrown))\n}\n\nexport function memberStringOrVal(object: Expression, memberName: MemberName): MemberExpression {\n\treturn typeof memberName === 'string' ?\n\t\tmember(object, memberName) :\n\t\tnew MemberExpressionComputed(object, transpileVal(memberName))\n}\n\nexport function lazyWrap(value: Expression): Expression {\n\treturn msCall('lazy', new ArrowFunctionExpression([], value))\n}\n\nconst IdMs = new Identifier('_ms')\nexport function msCall(name: string, ...args: Array<Expression>): Expression {\n\treturn new CallExpression(member(IdMs, name), args)\n}\n\nexport function msMember(name: string): Expression {\n\treturn member(IdMs, name)\n}\n\nexport function makeDestructureDeclarators(\n\tassignees: Array<LocalDeclare>,\n\tisLazy: boolean,\n\tvalue: Expression,\n\tisModule: boolean): Array<VariableDeclarator> {\n\tconst id = getDestructuredId()\n\tconst destructuredName = `_$${id}`\n\tconst idDestructured = new Identifier(destructuredName)\n\tconst declarators = assignees.map(assignee => {\n\t\tconst get = getMember(idDestructured, assignee.name, isLazy, isModule)\n\t\treturn makeDeclarator(assignee, get, isLazy)\n\t})\n\t// Getting lazy module is done by ms.lazyGetModule.\n\tconst val = isLazy && !isModule ? lazyWrap(value) : value\n\treturn cat(new VariableDeclarator(idDestructured, val), declarators)\n}\nfunction getMember(astObject: Expression, gotName: string, isLazy: boolean, isModule: boolean): Expression {\n\treturn isLazy ?\n\t\tmsCall('lazyProp', astObject, new LiteralString(gotName)) :\n\t\tisModule && options.checks ?\n\t\tmsCall('get', astObject, new LiteralString(gotName)) :\n\t\tmember(astObject, gotName)\n}\n\n/** Wraps a block (with `return` statements in it) in an IIFE. */\nexport function blockWrap(block: BlockStatement): Expression {\n\tconst thunk = funKind === Funs.Plain ?\n\t\tnew ArrowFunctionExpression([], block) :\n\t\tnew FunctionExpression(null, [], block, {generator: true})\n\treturn callPreservingFunKind(new CallExpression(thunk, []))\n}\n\n/** Wrap a statement in an IIFE. */\nexport function blockWrapStatement(statement: Statement): Expression {\n\treturn blockWrap(new BlockStatement([statement]))\n}\n\n/** Create a focus fun returning `value` and call it on `calledOn`, preserving generator/async. */\nexport function callFocusFun(value: Expression, calledOn: Expression): Expression {\n\tconst fun = funKind === Funs.Plain ?\n\t\tnew ArrowFunctionExpression([IdFocus], value) :\n\t\tnew FunctionExpression(\n\t\t\tnull, [IdFocus], new BlockStatement([new ReturnStatement(value)]), {generator: true})\n\treturn callPreservingFunKind(new CallExpression(fun, [calledOn]))\n}\n\n/**\nCall a function created by `blockWrap` or `callFocusFun`.\nThis looks like:\n\tFuns.Plain: `(_ => foo(_))(1)`.\n\tFuns.Generator, Funs.Async: `yield* function*(_) { return foo(_) }(1)`\n*/\nfunction callPreservingFunKind(call: Expression): Expression {\n\treturn funKind === Funs.Plain ? call : new YieldDelegateExpression(call)\n}\n\n//check uses (loc)\nexport function blockWrapIfBlock(value: Block | Val): Expression {\n\treturn value instanceof Block ? blockWrap(transpileBlock(value)) : (transpileVal(value))\n}\n\nexport function focusFun(value: Expression): ArrowFunctionExpression {\n\treturn new ArrowFunctionExpression([IdFocus], value)\n}\n\nexport function plainLet(identifier: Identifier, value: Expression): VariableDeclarationLet {\n\treturn new VariableDeclarationLet([new VariableDeclarator(identifier, value)])\n}\n"],"sourceRoot":"/source/"}