{"version":3,"sources":["private/transpile/transpile.js","private/transpile/transpile.ts"],"names":[],"mappings":"AAAA,CAAC,UAAU,OAAV,EAAmB;AAChB,QAAI,OAAO,MAAP,KAAkB,QAAlB,IAA8B,OAAO,OAAO,OAAP,KAAmB,QAA1B,EAAoC;AAClE,YAAI,IAAI,QAAQ,OAAR,EAAiB,OAAjB,CAAJ,CAD8D,IAC3B,MAAM,SAAN,EAAiB,OAAO,OAAP,GAAiB,CAAjB,CAArB;KADvC,MAGK,IAAI,OAAO,MAAP,KAAkB,UAAlB,IAAgC,OAAO,GAAP,EAAY;AACjD,eAAO,CAAC,SAAD,EAAY,SAAZ,EAAuB,WAAvB,EAAoC,mBAApC,CAAP,EAAiE,OAAjE,EADiD;KAAhD;CAJR,CAAD,CAOG,UAAU,OAAV,EAAmB,OAAnB,EAA4B;AAC3B,iBAD2B;;ACJ/B,UAAA,YAAA,QAA8B,WAA9B,CAAA,CDI+B;ACH/B,UAAA,oBAAA,QAA4B,mBAA5B,CAAA,CDG+B;ACoB/B,aAAA,SAAA,CAAkC,gBAAlC,EAA4D,SAA5D,EAAoF;AACnF,kBAAA,KAAA,CAAM,SAAN,EADmF;AAEnF,cAAM,MAAM,kBAAA,OAAA,CAAgB,gBAAhB,CAAN,CAF6E;AAGnF,kBAAA,QAAA,GAHmF;AAInF,eAAO,GAAP,CAJmF;KAApF;AAAA,WAAA,cAAA,CAAA,OAAA,EAAA,YAAA,EAAA,EAAA,OAAA,IAAA,EAAA,EDpB+B;AAW3B,YAAQ,OAAR,GAAkB,SAAlB,CAX2B;CAA5B,CAPH","file":"private/transpile/transpile.js","sourcesContent":["(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", './context', './transpileModule'], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    const context_1 = require('./context');\n    const transpileModule_1 = require('./transpileModule');\n    function transpile(moduleExpression, verifyRes) {\n        context_1.setup(verifyRes);\n        const res = transpileModule_1.default(moduleExpression);\n        context_1.tearDown();\n        return res;\n    }\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = transpile;\n});\n","import {Module as EsModule} from 'esast/lib/Program'\nimport Module from '../ast/Module'\nimport VerifyResults from '../VerifyResults'\nimport {setup, tearDown} from './context'\nimport transpileModule from './transpileModule'\n\n/**\nTransform a [[MsAst]] into an esast.\n\nImplementation notes:\n\n[[MsAst]]s map pretty much directly to javascript ASTs, so we just recursively transform the tree.\n`transfileFoo` is never allowed to look at the parent.\nOccasionally (and it's rare) the parent may pass down some information.\nFor example, [[transpileBlock]] takes some parameters.\n\nEvery `transpileFoo` function must set the location on the output esast.\nOtherwise the function should be named `transpileFooNoLoc`.\n\nSome [[MsAst]]s may be either an expression or statement.\nIn that case, the parent will call either `transpileDo` or `transpileVal`.\nThat way we have a type safety guarantee that statements only appear in statement context.\n\nThere should be no [[CompileError]]s or warnings during transpile.\nAny checks should be moved into [[verify]].\nThat way one gets all errors even if just parsing.\n**/\nexport default function transpile(moduleExpression: Module, verifyRes: VerifyResults): EsModule {\n\tsetup(verifyRes)\n\tconst res = transpileModule(moduleExpression)\n\ttearDown()\n\treturn res\n}\n"],"sourceRoot":"/source/"}