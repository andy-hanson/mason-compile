{"version":3,"sources":["private/lex/lex.js","private/lex/lex.ts"],"names":[],"mappings":"AAAA,CAAC,UAAU,OAAO,EAAE;AAChB,QAAI,OAAO,MAAM,KAAK,QAAQ,IAAI,OAAO,MAAM,CAAC,OAAO,KAAK,QAAQ,EAAE;AAClE,YAAI,CAAC,GAAG,OAAO,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC,AAAC,IAAI,CAAC,KAAK,SAAS,EAAE,MAAM,CAAC,OAAO,GAAG,CAAC,CAAC;KAC9E,MACI,IAAI,OAAO,MAAM,KAAK,UAAU,IAAI,MAAM,CAAC,GAAG,EAAE;AACjD,cAAM,CAAC,CAAC,SAAS,EAAE,SAAS,EAAE,eAAe,EAAE,gBAAgB,EAAE,YAAY,EAAE,iBAAiB,CAAC,EAAE,OAAO,CAAC,CAAC;KAC/G;CACJ,CAAA,CAAE,UAAU,OAAO,EAAE,OAAO,EAAE;AAC3B,gBAAY,CAAC;;ACRjB,QAAA,KAAA,GAAA,OAAA,CAAkB,eAClB,CAAC,CADgC;AAEjC,QAAA,cAAA,GAAA,OAAA,CAAgE,gBAChE,CAAC,CAD+E;AAChF,QAAA,UAAA,GAAA,OAAA,CAAqB,YACrB,CAAC,CADgC;AACjC,QAAA,eAAA,GAAA,OAAA,CAAsC,iBAOtC,CAAC,CAPsD;AAOvD,aAAA,GAAA,CAA4B,YAAoB,EAAA;AAE/C,YAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,IAAI,CAAC,EAC/B,YAAY,GAAG,CAAA,GAAG,YAAY,EAAA,EAAA,CAAI,CAAA;AAOnC,oBAAY,GAAG,CAAA,GAAG,YAAY,EAAA,EAAA,CAAI,CAAA;AAElC,sBAAA,CAAA,iBAAiB,EAAE,CAAA;AACnB,uBAAA,CAAA,kBAAkB,CAAC,YAAY,CAAC,CAAA;AAEhC,sBAAA,CAAA,QAAQ,CAAC,KAAA,CAAA,GAAG,CAAC,KAAK,CAAC,CAAA;AAEnB,kBAAA,CAAA,OAAQ,CAAC,KAAK,CAAC,CAAA;AAEf,cAAM,MAAM,GAAG,eAAA,CAAA,GAAG,EAAE,CAAA;AACpB,eAAoB,cAAA,CAAA,oBAAoB,CAAC,MAAM,CAAC,CAAA;KAChD;AArBD,UAAA,CAAA,cAAA,CAAA,OAAA,EAAA,YAAA,EAAA,EAAA,KAAA,EAAA,IAAA,EAAA,CAAA,CAAA;ADcI,WAAO,CAAC,OAAO,GAAG,GCOrB,CAAA;CDNA,CAAC,CAAC","file":"private/lex/lex.js","sourcesContent":["(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", 'esast/lib/Loc', './groupContext', './lexPlain', './sourceContext'], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    var Loc_1 = require('esast/lib/Loc');\n    var groupContext_1 = require('./groupContext');\n    var lexPlain_1 = require('./lexPlain');\n    var sourceContext_1 = require('./sourceContext');\n    function lex(sourceString) {\n        if (!sourceString.endsWith('\\n'))\n            sourceString = `${sourceString}\\n`;\n        sourceString = `${sourceString}\\0`;\n        groupContext_1.setupGroupContext();\n        sourceContext_1.setupSourceContext(sourceString);\n        groupContext_1.openLine(Loc_1.Pos.start);\n        lexPlain_1.default(false);\n        const endPos = sourceContext_1.pos();\n        return groupContext_1.tearDownGroupContext(endPos);\n    }\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = lex;\n});\n","import {Pos} from 'esast/lib/Loc'\nimport {GroupBlock} from '../token/Group'\nimport {openLine, setupGroupContext, tearDownGroupContext} from './groupContext'\nimport lexPlain from './lexPlain'\nimport {pos, setupSourceContext} from './sourceContext'\n\n/**\nLexes the source code into [[Token]]s.\nThe Mason lexer also groups tokens as part of lexing.\nThis makes writing a recursive-descent parser easy.\n*/\nexport default function lex(sourceString: string): GroupBlock {\n\t// Algorithm requires trailing newline to close any blocks.\n\tif (!sourceString.endsWith('\\n'))\n\t\tsourceString = `${sourceString}\\n`\n\n\t/*\n\tUse a 0-terminated string so that we can use `0` as a switch case in lexPlain.\n\tThis is faster than checking whether index === length.\n\t(If we check past the end of the string we get `NaN`, which can't be switched on.)\n\t*/\n\tsourceString = `${sourceString}\\0`\n\n\tsetupGroupContext()\n\tsetupSourceContext(sourceString)\n\n\topenLine(Pos.start)\n\n\tlexPlain(false)\n\n\tconst endPos = pos()\n\treturn <GroupBlock> tearDownGroupContext(endPos)\n}\n"],"sourceRoot":"/source/"}