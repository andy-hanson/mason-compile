if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports', './util'], function (exports, _util) {
	'use strict';

	Object.defineProperty(exports, '__esModule', {
		value: true
	});

	class VerifyResults {
		constructor() {
			// LocalAccess -> LocalDeclare.
			// Needed because lazy accesses must be compiled differently.
			this.localAccessToDeclare = new Map();
			// LocalDeclare -> VrLocalInfo.
			// Debug locals will not be output if not in debug mode.
			this.localDeclareToInfo = new Map();
			// TODO:ES6 Can use do `export { a, b, ... }` at the end, so shouldn't need this.
			// Includes both Assigns and AssignDestructures.
			this.exportAssigns = new Set();
			// Maps Class/Fun to name if one is appropriate.
			// Maps *every* SV_Name to the nearest name.
			this.names = new Map();
		}

		isDebugLocal(localDeclare) {
			return this.localDeclareToInfo.get(localDeclare).isInDebug;
		}

		isAccessed(localDeclare) {
			const info = this.localDeclareToInfo.get(localDeclare);
			return !((0, _util.isEmpty)(info.debugAccesses) && (0, _util.isEmpty)(info.nonDebugAccesses));
		}

		isExportAssign(assign) {
			return this.exportAssigns.has(assign);
		}

		localDeclareForAccess(localAccess) {
			return this.localAccessToDeclare.get(localAccess);
		}

		name(expr) {
			return this.names.get(expr);
		}

		opName(expr) {
			const x = this.names.get(expr);
			return x === undefined ? null : x;
		}
	}

	exports.default = VerifyResults;

	class LocalInfo {
		static empty(isInDebug) {
			return new LocalInfo(isInDebug, [], []);
		}

		constructor(isInDebug, /* Boolean */
		debugAccesses, /* LocalAccess */
		nonDebugAccesses /* Array[LocalAccess] */) {
			this.isInDebug = isInDebug;
			this.debugAccesses = debugAccesses;
			this.nonDebugAccesses = nonDebugAccesses;
		}
	}

	exports.LocalInfo = LocalInfo;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlZlcmlmeVJlc3VsdHMuanMiLCJwcml2YXRlL1ZlcmlmeVJlc3VsdHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7QUNFZSxPQUFNLGFBQWEsQ0FBQztBQUNsQyxhQUFXLEdBQUc7OztBQUdiLE9BQUksQ0FBQyxvQkFBb0IsR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFBOzs7QUFHckMsT0FBSSxDQUFDLGtCQUFrQixHQUFHLElBQUksR0FBRyxFQUFFLENBQUE7OztBQUduQyxPQUFJLENBQUMsYUFBYSxHQUFHLElBQUksR0FBRyxFQUFFLENBQUE7OztBQUc5QixPQUFJLENBQUMsS0FBSyxHQUFHLElBQUksR0FBRyxFQUFFLENBQUE7R0FDdEI7O0FBRUQsY0FBWSxDQUFDLFlBQVksRUFBRTtBQUMxQixVQUFPLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLENBQUMsU0FBUyxDQUFBO0dBQzFEOztBQUVELFlBQVUsQ0FBQyxZQUFZLEVBQUU7QUFDeEIsU0FBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQTtBQUN0RCxVQUFPLEVBQUUsVUF4QkYsT0FBTyxFQXdCRyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksVUF4QmpDLE9BQU8sRUF3QmtDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFBLEFBQUMsQ0FBQTtHQUN2RTs7QUFFRCxnQkFBYyxDQUFDLE1BQU0sRUFBRTtBQUN0QixVQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFBO0dBQ3JDOztBQUVELHVCQUFxQixDQUFDLFdBQVcsRUFBRTtBQUNsQyxVQUFPLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUE7R0FDakQ7O0FBRUQsTUFBSSxDQUFDLElBQUksRUFBRTtBQUNWLFVBQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUE7R0FDM0I7O0FBRUQsUUFBTSxDQUFDLElBQUksRUFBRTtBQUNaLFNBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFBO0FBQzlCLFVBQU8sQ0FBQyxLQUFLLFNBQVMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxDQUFBO0dBQ2pDO0VBQ0Q7O21CQXpDb0IsYUFBYTs7QUEyQzNCLE9BQU0sU0FBUyxDQUFDO0FBQ3RCLFNBQU8sS0FBSyxDQUFDLFNBQVMsRUFBRTtBQUN2QixVQUFPLElBQUksU0FBUyxDQUFDLFNBQVMsRUFBRSxFQUFHLEVBQUUsRUFBRyxDQUFDLENBQUE7R0FDekM7O0FBRUQsYUFBVyxDQUNWLFNBQVM7QUFDVCxlQUFhO0FBQ2Isa0JBQWdCLDJCQUEyQjtBQUMzQyxPQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQTtBQUMxQixPQUFJLENBQUMsYUFBYSxHQUFHLGFBQWEsQ0FBQTtBQUNsQyxPQUFJLENBQUMsZ0JBQWdCLEdBQUcsZ0JBQWdCLENBQUE7R0FDeEM7RUFDRCIsImZpbGUiOiJwcml2YXRlL1ZlcmlmeVJlc3VsdHMuanMiLCJzb3VyY2VzQ29udGVudCI6W251bGwsImltcG9ydCB7IGlzRW1wdHkgfSBmcm9tICcuL3V0aWwnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlcmlmeVJlc3VsdHMge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHQvLyBMb2NhbEFjY2VzcyAtPiBMb2NhbERlY2xhcmUuXG5cdFx0Ly8gTmVlZGVkIGJlY2F1c2UgbGF6eSBhY2Nlc3NlcyBtdXN0IGJlIGNvbXBpbGVkIGRpZmZlcmVudGx5LlxuXHRcdHRoaXMubG9jYWxBY2Nlc3NUb0RlY2xhcmUgPSBuZXcgTWFwKClcblx0XHQvLyBMb2NhbERlY2xhcmUgLT4gVnJMb2NhbEluZm8uXG5cdFx0Ly8gRGVidWcgbG9jYWxzIHdpbGwgbm90IGJlIG91dHB1dCBpZiBub3QgaW4gZGVidWcgbW9kZS5cblx0XHR0aGlzLmxvY2FsRGVjbGFyZVRvSW5mbyA9IG5ldyBNYXAoKVxuXHRcdC8vIFRPRE86RVM2IENhbiB1c2UgZG8gYGV4cG9ydCB7IGEsIGIsIC4uLiB9YCBhdCB0aGUgZW5kLCBzbyBzaG91bGRuJ3QgbmVlZCB0aGlzLlxuXHRcdC8vIEluY2x1ZGVzIGJvdGggQXNzaWducyBhbmQgQXNzaWduRGVzdHJ1Y3R1cmVzLlxuXHRcdHRoaXMuZXhwb3J0QXNzaWducyA9IG5ldyBTZXQoKVxuXHRcdC8vIE1hcHMgQ2xhc3MvRnVuIHRvIG5hbWUgaWYgb25lIGlzIGFwcHJvcHJpYXRlLlxuXHRcdC8vIE1hcHMgKmV2ZXJ5KiBTVl9OYW1lIHRvIHRoZSBuZWFyZXN0IG5hbWUuXG5cdFx0dGhpcy5uYW1lcyA9IG5ldyBNYXAoKVxuXHR9XG5cblx0aXNEZWJ1Z0xvY2FsKGxvY2FsRGVjbGFyZSkge1xuXHRcdHJldHVybiB0aGlzLmxvY2FsRGVjbGFyZVRvSW5mby5nZXQobG9jYWxEZWNsYXJlKS5pc0luRGVidWdcblx0fVxuXG5cdGlzQWNjZXNzZWQobG9jYWxEZWNsYXJlKSB7XG5cdFx0Y29uc3QgaW5mbyA9IHRoaXMubG9jYWxEZWNsYXJlVG9JbmZvLmdldChsb2NhbERlY2xhcmUpXG5cdFx0cmV0dXJuICEoaXNFbXB0eShpbmZvLmRlYnVnQWNjZXNzZXMpICYmIGlzRW1wdHkoaW5mby5ub25EZWJ1Z0FjY2Vzc2VzKSlcblx0fVxuXG5cdGlzRXhwb3J0QXNzaWduKGFzc2lnbikge1xuXHRcdHJldHVybiB0aGlzLmV4cG9ydEFzc2lnbnMuaGFzKGFzc2lnbilcblx0fVxuXG5cdGxvY2FsRGVjbGFyZUZvckFjY2Vzcyhsb2NhbEFjY2Vzcykge1xuXHRcdHJldHVybiB0aGlzLmxvY2FsQWNjZXNzVG9EZWNsYXJlLmdldChsb2NhbEFjY2Vzcylcblx0fVxuXG5cdG5hbWUoZXhwcikge1xuXHRcdHJldHVybiB0aGlzLm5hbWVzLmdldChleHByKVxuXHR9XG5cblx0b3BOYW1lKGV4cHIpIHtcblx0XHRjb25zdCB4ID0gdGhpcy5uYW1lcy5nZXQoZXhwcilcblx0XHRyZXR1cm4geCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHhcblx0fVxufVxuXG5leHBvcnQgY2xhc3MgTG9jYWxJbmZvIHtcblx0c3RhdGljIGVtcHR5KGlzSW5EZWJ1Zykge1xuXHRcdHJldHVybiBuZXcgTG9jYWxJbmZvKGlzSW5EZWJ1ZywgWyBdLCBbIF0pXG5cdH1cblxuXHRjb25zdHJ1Y3Rvcihcblx0XHRpc0luRGVidWcgLyogQm9vbGVhbiAqLyxcblx0XHRkZWJ1Z0FjY2Vzc2VzIC8qIExvY2FsQWNjZXNzICovLFxuXHRcdG5vbkRlYnVnQWNjZXNzZXMgLyogQXJyYXlbTG9jYWxBY2Nlc3NdICovKSB7XG5cdFx0dGhpcy5pc0luRGVidWcgPSBpc0luRGVidWdcblx0XHR0aGlzLmRlYnVnQWNjZXNzZXMgPSBkZWJ1Z0FjY2Vzc2VzXG5cdFx0dGhpcy5ub25EZWJ1Z0FjY2Vzc2VzID0gbm9uRGVidWdBY2Nlc3Nlc1xuXHR9XG59XG4iXSwic291cmNlUm9vdCI6Ii9zcmMifQ==