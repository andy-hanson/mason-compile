if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports', 'module', '../../CompileError', '../context', '../MsAst', '../Token', '../util', './checks', './parse*', './parseMemberName', './parseName', './parseQuote', './parseSingle', './Slice'], function (exports, module, _CompileError, _context, _MsAst, _Token, _util, _checks, _parse, _parseMemberName, _parseName, _parseQuote, _parseSingle, _Slice) {
	'use strict';

	module.exports = parseSpaced;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _parseMemberName2 = _interopRequireDefault(_parseMemberName);

	var _parseName2 = _interopRequireDefault(_parseName);

	var _parseQuote2 = _interopRequireDefault(_parseQuote);

	var _parseSingle2 = _interopRequireDefault(_parseSingle);

	var _Slice2 = _interopRequireDefault(_Slice);

	/**
 Parse tokens in a {@link Groups.Space}.
 @return {Val}
 */

	function parseSpaced(tokens) {
		const h = tokens.head(),
		      rest = tokens.tail();
		if ((0, _Token.isKeyword)(_Token.Keywords.Type, h)) return _MsAst.Call.contains(h.loc, parseSpaced(rest), _MsAst.LocalAccess.focus(h.loc));else if ((0, _Token.isKeyword)(_Token.Keywords.Lazy, h)) return new _MsAst.Lazy(h.loc, parseSpaced(rest));else if ((0, _Token.isKeyword)(_Token.Keywords.Dot, h)) {
			const name = (0, _parseName2.default)(rest.head());
			const rest2 = rest.tail();
			const member = new _MsAst.Member(h.loc, _MsAst.LocalAccess.this(h.loc), name);
			return rest2.isEmpty() ? member : parseSpacedFold(member, rest.tail());
		} else if ((0, _Token.isKeyword)(_Token.Keywords.Ellipsis, h)) return new _MsAst.Splat(tokens.loc, parseSpacedFold((0, _parseSingle2.default)(rest.head()), rest.tail));else if ((0, _Token.isKeyword)(_Token.Keywords.SuperVal, h)) {
			// TODO: handle sub here as well
			const h2 = rest.head();
			if ((0, _Token.isKeyword)(_Token.Keywords.Dot, h2)) {
				const tail = rest.tail();
				const sup = new _MsAst.SuperMember(h2.loc, (0, _parseMemberName2.default)(tail.head()));
				return parseSpacedFold(sup, tail.tail());
			} else if ((0, _Token.isGroup)(_Token.Groups.Parenthesis, h2) && _Slice2.default.group(h2).isEmpty()) {
				const x = new _MsAst.SuperCall(h2.loc, []);
				return parseSpacedFold(x, rest.tail());
			} else (0, _context.fail)(`Expected ${ (0, _CompileError.code)('.') } or ${ (0, _CompileError.code)('()') } after ${ (0, _CompileError.code)('super') }`);
		} else return parseSpacedFold((0, _parseSingle2.default)(h), rest);
	}

	function parseSpacedFold(start, rest) {
		let acc = start;
		for (let i = rest._start; i < rest._end; i = i + 1) {
			const token = rest._tokens[i];
			const loc = token.loc;
			if ((0, _Token.isKeyword)(_Token.Keywords.Dot, token)) {
				// If this was the last one, it would not be a Keywords.Dot but a Keywords.ObjAssign
				(0, _util.assert)(i < rest._end - 1);
				i = i + 1;
				const next = rest._tokens[i];
				acc = new _MsAst.Member(token.loc, acc, (0, _parseMemberName2.default)(next));
			} else if (token instanceof _Token.Keyword) switch (token.kind) {
				case _Token.Keywords.Focus:
					acc = new _MsAst.Call(token.loc, acc, [_MsAst.LocalAccess.focus(loc)]);
					break;
				case _Token.Keywords.Type:
					{
						const type = parseSpaced(rest._chopStart(i + 1));
						return _MsAst.Call.contains(token.loc, type, acc);
					}
				default:
					(0, _checks.unexpected)(token);
			} else if (token instanceof _Token.Group) {
				const slice = _Slice2.default.group(token);
				switch (token.kind) {
					case _Token.Groups.Bracket:
						acc = _MsAst.Call.sub(loc, acc, (0, _parse.parseExprParts)(slice));
						break;
					case _Token.Groups.Parenthesis:
						(0, _checks.checkEmpty)(slice, () => `Use ${ (0, _CompileError.code)('(a b)') }, not ${ (0, _CompileError.code)('a(b)') }`);
						acc = new _MsAst.Call(loc, acc, []);
						break;
					case _Token.Groups.Quote:
						acc = new _MsAst.QuoteTemplate(loc, acc, (0, _parseQuote2.default)(slice));
						break;
					default:
						(0, _checks.unexpected)(token);
				}
			}
		}
		return acc;
	}
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhcnNlU3BhY2VkLmpzIiwicHJpdmF0ZS9wYXJzZS9wYXJzZVNwYWNlZC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O2tCQ2tCd0IsV0FBVzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFwQixVQUFTLFdBQVcsQ0FBQyxNQUFNLEVBQUU7QUFDM0MsUUFBTSxDQUFDLEdBQUcsTUFBTSxDQUFDLElBQUksRUFBRTtRQUFFLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUE7QUFDN0MsTUFBSSxXQWhCMkIsU0FBUyxFQWdCMUIsT0FoQnFDLFFBQVEsQ0FnQnBDLElBQUksRUFBRSxDQUFDLENBQUMsRUFDOUIsT0FBTyxPQW5CRCxJQUFJLENBbUJFLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLFdBQVcsQ0FBQyxJQUFJLENBQUMsRUFBRSxPQW5CN0IsV0FBVyxDQW1COEIsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFBLEtBQ3BFLElBQUksV0FsQnNCLFNBQVMsRUFrQnJCLE9BbEJnQyxRQUFRLENBa0IvQixJQUFJLEVBQUUsQ0FBQyxDQUFDLEVBQ25DLE9BQU8sV0FyQkssSUFBSSxDQXFCQSxDQUFDLENBQUMsR0FBRyxFQUFFLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFBLEtBQ3JDLElBQUksV0FwQnNCLFNBQVMsRUFvQnJCLE9BcEJnQyxRQUFRLENBb0IvQixHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQUU7QUFDcEMsU0FBTSxJQUFJLEdBQUcseUJBQVUsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUE7QUFDbkMsU0FBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFBO0FBQ3pCLFNBQU0sTUFBTSxHQUFHLFdBekJnQixNQUFNLENBeUJYLENBQUMsQ0FBQyxHQUFHLEVBQUUsT0F6QmYsV0FBVyxDQXlCZ0IsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxJQUFJLENB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Q0FBQyxFQUFDLE1BQU0sR0FBRSxrQkE3RWxELElBQUksRUE2RW1ELE1BQU0sQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFBO0FBQ3BFLFNBQUcsR0FBRyxXQTVFSCxJQUFJLENBNEVRLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUE7QUFDNUIsWUFBSztBQUFBLEFBQ04sVUFBSyxPQTVFTSxNQUFNLENBNEVMLEtBQUs7QUFDaEIsU0FBRyxHQUFHLFdBL0U4QixhQUFhLENBK0V6QixHQUFHLEVBQUUsR0FBRyxFQUFFLDBCQUFXLEtBQUssQ0FBQyxDQUFDLENBQUE7QUFDcEQsWUFBSztBQUFBLEFBQ047QUFDQyxrQkE5RWUsVUFBVSxFQThFZCxLQUFLLENBQUMsQ0FBQTtBQUFBLEtBQ2xCO0lBQ0Q7R0FDRDtBQUNELFNBQU8sR0FBRyxDQUFBO0VBQ1YiLCJmaWxlIjoicHJpdmF0ZS9wYXJzZS9wYXJzZVNwYWNlZC5qcyIsInNvdXJjZXNDb250ZW50IjpbbnVsbCwiaW1wb3J0IHtjb2RlfSBmcm9tICcuLi8uLi9Db21waWxlRXJyb3InXG5pbXBvcnQge2ZhaWx9IGZyb20gJy4uL2NvbnRleHQnXG5pbXBvcnQge0NhbGwsIExhenksIExvY2FsQWNjZXNzLCBNZW1iZXIsIFF1b3RlVGVtcGxhdGUsIFNwbGF0LCBTdXBlckNhbGwsIFN1cGVyTWVtYmVyXG5cdH0gZnJvbSAnLi4vTXNBc3QnXG5pbXBvcnQge0dyb3VwLCBHcm91cHMsIGlzR3JvdXAsIGlzS2V5d29yZCwgS2V5d29yZCwgS2V5d29yZHN9IGZyb20gJy4uL1Rva2VuJ1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4uL3V0aWwnXG5pbXBvcnQge2NoZWNrRW1wdHksIHVuZXhwZWN0ZWR9IGZyb20gJy4vY2hlY2tzJ1xuaW1wb3J0IHtwYXJzZUV4cHJQYXJ0c30gZnJvbSAnLi9wYXJzZSonXG5pbXBvcnQgcGFyc2VNZW1iZXJOYW1lIGZyb20gJy4vcGFyc2VNZW1iZXJOYW1lJ1xuaW1wb3J0IHBhcnNlTmFtZSBmcm9tICcuL3BhcnNlTmFtZSdcbmltcG9ydCBwYXJzZVF1b3RlIGZyb20gJy4vcGFyc2VRdW90ZSdcbmltcG9ydCBwYXJzZVNpbmdsZSBmcm9tICcuL3BhcnNlU2luZ2xlJ1xuaW1wb3J0IFNsaWNlIGZyb20gJy4vU2xpY2UnXG5cbi8qKlxuUGFyc2UgdG9rZW5zIGluIGEge0BsaW5rIEdyb3Vwcy5TcGFjZX0uXG5AcmV0dXJuIHtWYWx9XG4qL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGFyc2VTcGFjZWQodG9rZW5zKSB7XG5cdGNvbnN0IGggPSB0b2tlbnMuaGVhZCgpLCByZXN0ID0gdG9rZW5zLnRhaWwoKVxuXHRpZiAoaXNLZXl3b3JkKEtleXdvcmRzLlR5cGUsIGgpKVxuXHRcdHJldHVybiBDYWxsLmNvbnRhaW5zKGgubG9jLCBwYXJzZVNwYWNlZChyZXN0KSwgTG9jYWxBY2Nlc3MuZm9jdXMoaC5sb2MpKVxuXHRlbHNlIGlmIChpc0tleXdvcmQoS2V5d29yZHMuTGF6eSwgaCkpXG5cdFx0cmV0dXJuIG5ldyBMYXp5KGgubG9jLCBwYXJzZVNwYWNlZChyZXN0KSlcblx0ZWxzZSBpZiAoaXNLZXl3b3JkKEtleXdvcmRzLkRvdCwgaCkpIHtcblx0XHRjb25zdCBuYW1lID0gcGFyc2VOYW1lKHJlc3QuaGVhZCgpKVxuXHRcdGNvbnN0IHJlc3QyID0gcmVzdC50YWlsKClcblx0XHRjb25zdCBtZW1iZXIgPSBuZXcgTWVtYmVyKGgubG9jLCBMb2NhbEFjY2Vzcy50aGlzKGgubG9jKSwgbmFtZSlcblx0XHRyZXR1cm4gcmVzdDIuaXNFbXB0eSgpID8gbWVtYmVyIDogcGFyc2VTcGFjZWRGb2xkKG1lbWJlciwgcmVzdC50YWlsKCkpXG5cdH0gZWxzZSBpZiAoaXNLZXl3b3JkKEtleXdvcmRzLkVsbGlwc2lzLCBoKSlcblx0XHRyZXR1cm4gbmV3IFNwbGF0KHRva2Vucy5sb2MsIHBhcnNlU3BhY2VkRm9sZChwYXJzZVNpbmdsZShyZXN0LmhlYWQoKSksIHJlc3QudGFpbCkpXG5cdGVsc2UgaWYgKGlzS2V5d29yZChLZXl3b3Jkcy5TdXBlclZhbCwgaCkpIHtcblx0XHQvLyBUT0RPOiBoYW5kbGUgc3ViIGhlcmUgYXMgd2VsbFxuXHRcdGNvbnN0IGgyID0gcmVzdC5oZWFkKClcblx0XHRpZiAoaXNLZXl3b3JkKEtleXdvcmRzLkRvdCwgaDIpKSB7XG5cdFx0XHRjb25zdCB0YWlsID0gcmVzdC50YWlsKClcblx0XHRcdGNvbnN0IHN1cCA9IG5ldyBTdXBlck1lbWJlcihoMi5sb2MsIHBhcnNlTWVtYmVyTmFtZSh0YWlsLmhlYWQoKSkpXG5cdFx0XHRyZXR1cm4gcGFyc2VTcGFjZWRGb2xkKHN1cCwgdGFpbC50YWlsKCkpXG5cdFx0fSBlbHNlIGlmIChpc0dyb3VwKEdyb3Vwcy5QYXJlbnRoZXNpcywgaDIpICYmIFNsaWNlLmdyb3VwKGgyKS5pc0VtcHR5KCkpIHtcblx0XHRcdGNvbnN0IHggPSBuZXcgU3VwZXJDYWxsKGgyLmxvYywgW10pXG5cdFx0XHRyZXR1cm4gcGFyc2VTcGFjZWRGb2xkKHgsIHJlc3QudGFpbCgpKVxuXHRcdH0gZWxzZVxuXHRcdFx0ZmFpbChgRXhwZWN0ZWQgJHtjb2RlKCcuJyl9IG9yICR7Y29kZSgnKCknKX0gYWZ0ZXIgJHtjb2RlKCdzdXBlcicpfWApXG5cdH0gZWxzZVxuXHRcdHJldHVybiBwYXJzZVNwYWNlZEZvbGQocGFyc2VTaW5nbGUoaCksIHJlc3QpXG59XG5cbmZ1bmN0aW9uIHBhcnNlU3BhY2VkRm9sZChzdGFydCwgcmVzdCkge1xuXHRsZXQgYWNjID0gc3RhcnRcblx0Zm9yIChsZXQgaSA9IHJlc3QuX3N0YXJ0OyBpIDwgcmVzdC5fZW5kOyBpID0gaSArIDEpIHtcblx0XHRjb25zdCB0b2tlbiA9IHJlc3QuX3Rva2Vuc1tpXVxuXHRcdGNvbnN0IGxvYyA9IHRva2VuLmxvY1xuXHRcdGlmIChpc0tleXdvcmQoS2V5d29yZHMuRG90LCB0b2tlbikpIHtcblx0XHRcdC8vIElmIHRoaXMgd2FzIHRoZSBsYXN0IG9uZSwgaXQgd291bGQgbm90IGJlIGEgS2V5d29yZHMuRG90IGJ1dCBhIEtleXdvcmRzLk9iakFzc2lnblxuXHRcdFx0YXNzZXJ0KGkgPCByZXN0Ll9lbmQgLSAxKVxuXHRcdFx0aSA9IGkgKyAxXG5cdFx0XHRjb25zdCBuZXh0ID0gcmVzdC5fdG9rZW5zW2ldXG5cdFx0XHRhY2MgPSBuZXcgTWVtYmVyKHRva2VuLmxvYywgYWNjLCBwYXJzZU1lbWJlck5hbWUobmV4dCkpXG5cdFx0fSBlbHNlIGlmICh0b2tlbiBpbnN0YW5jZW9mIEtleXdvcmQpXG5cdFx0XHRzd2l0Y2ggKHRva2VuLmtpbmQpIHtcblx0XHRcdFx0Y2FzZSBLZXl3b3Jkcy5Gb2N1czpcblx0XHRcdFx0XHRhY2MgPSBuZXcgQ2FsbCh0b2tlbi5sb2MsIGFjYywgW0xvY2FsQWNjZXNzLmZvY3VzKGxvYyldKVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGNhc2UgS2V5d29yZHMuVHlwZToge1xuXHRcdFx0XHRcdGNvbnN0IHR5cGUgPSBwYXJzZVNwYWNlZChyZXN0Ll9jaG9wU3RhcnQoaSArIDEpKVxuXHRcdFx0XHRcdHJldHVybiBDYWxsLmNvbnRhaW5zKHRva2VuLmxvYywgdHlwZSwgYWNjKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dW5leHBlY3RlZCh0b2tlbilcblx0XHRcdH1cblx0XHRlbHNlIGlmICh0b2tlbiBpbnN0YW5jZW9mIEdyb3VwKSB7XG5cdFx0XHRjb25zdCBzbGljZSA9IFNsaWNlLmdyb3VwKHRva2VuKVxuXHRcdFx0c3dpdGNoICh0b2tlbi5raW5kKSB7XG5cdFx0XHRcdGNhc2UgR3JvdXBzLkJyYWNrZXQ6XG5cdFx0XHRcdFx0YWNjID0gQ2FsbC5zdWIobG9jLCBhY2MsIHBhcnNlRXhwclBhcnRzKHNsaWNlKSlcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIEdyb3Vwcy5QYXJlbnRoZXNpczpcblx0XHRcdFx0XHRjaGVja0VtcHR5KHNsaWNlLCAoKSA9PiBgVXNlICR7Y29kZSgnKGEgYiknKX0sIG5vdCAke2NvZGUoJ2EoYiknKX1gKVxuXHRcdFx0XHRcdGFjYyA9IG5ldyBDYWxsKGxvYywgYWNjLCBbXSlcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIEdyb3Vwcy5RdW90ZTpcblx0XHRcdFx0XHRhY2MgPSBuZXcgUXVvdGVUZW1wbGF0ZShsb2MsIGFjYywgcGFyc2VRdW90ZShzbGljZSkpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHR1bmV4cGVjdGVkKHRva2VuKVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gYWNjXG59XG4iXSwic291cmNlUm9vdCI6Ii9zcmMifQ==
