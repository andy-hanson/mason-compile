'use strict';

(function (global, factory) {
	if (typeof define === "function" && define.amd) {
		define(['exports', './context'], factory);
	} else if (typeof exports !== "undefined") {
		factory(exports, require('./context'));
	} else {
		var mod = {
			exports: {}
		};
		factory(mod.exports, global.context);
		global.VerifyResults = mod.exports;
	}
})(this, function (exports, _context) {
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.Modules = exports.Blocks = undefined;

	class VerifyResults {
		constructor() {
			this.localAccessToDeclare = new Map();
			this.localDeclareToAccesses = new Map();
			this.names = new Map();
			this.builtinPathToNames = new Map();
			this.superCallToMethod = new Map();
			this.constructorToSuper = new Map();
			this.blockToKind = new Map();
			this.statements = new Set();
			this.objEntryExports = new Set();
			this.moduleKind = null;
			this.loopsNeedingLabel = new Set();
			this.breaksInSwitch = new Set();
		}

		localDeclareForAccess(localAccess) {
			return this.localAccessToDeclare.get(localAccess);
		}

		name(expr) {
			const name = this.names.get(expr);
			(0, _context.check)(name !== undefined, expr.loc, 'cantDetermineName');
			return name;
		}

		opName(expr) {
			const x = this.names.get(expr);
			return x === undefined ? null : x;
		}

		isStatement(expr) {
			return this.statements.has(expr);
		}

		blockKind(block) {
			return this.blockToKind.get(block);
		}

		isObjEntryExport(objEntry) {
			return this.objEntryExports.has(objEntry);
		}

		constructorHasSuper(ctr) {
			return this.constructorToSuper.has(ctr);
		}

		loopNeedsLabel(loop) {
			return this.loopsNeedingLabel.has(loop);
		}

		isBreakInSwitch(breakAst) {
			return this.breaksInSwitch.has(breakAst);
		}

	}

	exports.default = VerifyResults;
	const Blocks = exports.Blocks = {
		Do: 0,
		Throw: 1,
		Return: 2,
		Bag: 3,
		Map: 4,
		Obj: 5
	};
	const Modules = exports.Modules = {
		Do: 0,
		Val: 1,
		Exports: 2,
		Bag: 3,
		Map: 4
	};
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wcml2YXRlL1ZlcmlmeVJlc3VsdHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FNcUIsYUFBYTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O21CQUFiLGFBQWE7T0FrR3JCLE1BQU0sV0FBTixNQUFNLEdBQUc7QUFDckIsSUFBRSxFQUFFLENBQUM7QUFDTCxPQUFLLEVBQUUsQ0FBQztBQUNSLFFBQU0sRUFBRSxDQUFDO0FBQ1QsS0FBRyxFQUFFLENBQUM7QUFDTixLQUFHLEVBQUUsQ0FBQztBQUNOLEtBQUcsRUFBRSxDQUFDO0VBQ047T0FHWSxPQUFPLFdBQVAsT0FBTyxHQUFHO0FBQ3RCLElBQUUsRUFBRSxDQUFDO0FBQ0wsS0FBRyxFQUFFLENBQUM7QUFDTixTQUFPLEVBQUUsQ0FBQztBQUNWLEtBQUcsRUFBRSxDQUFDO0FBQ04sS0FBRyxFQUFFLENBQUM7RUFDTiIsImZpbGUiOiJWZXJpZnlSZXN1bHRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtjaGVja30gZnJvbSAnLi9jb250ZXh0J1xuXG4vKipcblJlc3VsdHMgb2Yge0BsaW5rIHZlcmlmeX0uXG5UaGlzIGlzIG9ubHkgdGhlIGRhdGEgbmVlZGVkIGJ5IHtAbGluayB0cmFuc3BpbGV9LlxuKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlcmlmeVJlc3VsdHMge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHQvKipcblx0XHRMb2NhbEFjY2VzcyAtPiBMb2NhbERlY2xhcmUuXG5cdFx0TmVlZGVkIGJlY2F1c2UgbGF6eSBhY2Nlc3NlcyBtdXN0IGJlIGNvbXBpbGVkIGRpZmZlcmVudGx5LlxuXHRcdCovXG5cdFx0dGhpcy5sb2NhbEFjY2Vzc1RvRGVjbGFyZSA9IG5ldyBNYXAoKVxuXHRcdC8qKlxuXHRcdExvY2FsRGVjbGFyZSAtPiBBcnJheVtMb2NhbEFjY2Vzc10uXG5cdFx0RGVidWcgbG9jYWxzIHdpbGwgbm90IGJlIG91dHB1dCBpZiBub3QgaW4gZGVidWcgbW9kZS5cblx0XHQqL1xuXHRcdHRoaXMubG9jYWxEZWNsYXJlVG9BY2Nlc3NlcyA9IG5ldyBNYXAoKVxuXHRcdC8qKlxuXHRcdE1hcHMgQ2xhc3MvRnVuIHRvIG5hbWUgaWYgb25lIGlzIGFwcHJvcHJpYXRlLlxuXHRcdE1hcHMgKmV2ZXJ5KiB7QGxpbmsgU3BlY2lhbFZhbHMuTmFtZX0gdG8gdGhlIG5lYXJlc3QgbmFtZS5cblx0XHQqL1xuXHRcdHRoaXMubmFtZXMgPSBuZXcgTWFwKClcblx0XHQvKipcblx0XHRTdHJpbmcgLT4gU2V0LlxuXHRcdEZvciBlYWNoIHBhdGgsIHRoZSBuYW1lcyBvZiBlYWNoIGJ1aWx0aW4gaW1wb3J0ZWQuXG5cdFx0TGlrZSB0aGUgaW52ZXJzZSBvZiBjb250ZXh0Lm9wdHMuYnVpbHRpbk5hbWVUb1BhdGgsXG5cdFx0YnV0IG9ubHkgaW5jbHVkZXMgbmFtZXMgYWN0dWFsbHkgdXNlZC5cblx0XHQqL1xuXHRcdHRoaXMuYnVpbHRpblBhdGhUb05hbWVzID0gbmV3IE1hcCgpXG5cdFx0LyoqIFZhbHVlcyBhcmUgZWl0aGVyIE1ldGhvZEltcGwgb3IgdGhlIHN0cmluZyAnY29uc3RydWN0b3InICovXG5cdFx0dGhpcy5zdXBlckNhbGxUb01ldGhvZCA9IG5ldyBNYXAoKVxuXHRcdC8qKiBMaW5rcyBhIGNvbnN0cnVjdG9yIHRvIGl0cyBzdXBlciEgY2FsbC4gKi9cblx0XHR0aGlzLmNvbnN0cnVjdG9yVG9TdXBlciA9IG5ldyBNYXAoKVxuXHRcdC8qKiBTdG9yZXMgdmVyaWZpZWQgYmxvY2sga2luZCAoc2VlIHZlcmlmeUJsb2NrLmpzKSAqL1xuXHRcdHRoaXMuYmxvY2tUb0tpbmQgPSBuZXcgTWFwKClcblx0XHQvKipcblx0XHRTZXQgb2YgTXNBc3RzIHRoYXQgaGF2ZSBiZWVuIG1hcmtlZCBhcyBiZWluZyBzdGF0ZW1lbnRzLlxuXHRcdFRob3NlIHdoaWNoIGFyZSBhbHdheXMgc3RhdGVtZW50cyAobGlrZSBUaHJvdykgYXJlIG5vdCBtYXJrZWQuXG5cdFx0VXNlIGEgc2V0IG9mIHN0YXRlbWVudHMgYmVjYXVzZSB0aGVyZSBhcmUgdXN1YWxseSBtYW55IG1vcmUgdmFscyB0aGFuIHN0YXRlbWVudHMuXG5cdFx0Ki9cblx0XHR0aGlzLnN0YXRlbWVudHMgPSBuZXcgU2V0KClcblx0XHQvKiogT2JqRW50cnlfcyB0aGF0IGFyZSBtb2R1bGUgZXhwb3J0cyAqL1xuXHRcdHRoaXMub2JqRW50cnlFeHBvcnRzID0gbmV3IFNldCgpXG5cdFx0LyoqIEB0eXBlIHtNb2R1bGVzfSAqL1xuXHRcdHRoaXMubW9kdWxlS2luZCA9IG51bGxcblx0XHQvKiogU2V0IG9mIHtAbGluayBMb29wfXMgd2l0aCBhdCBsZWFzdCBvbmUge0BsaW5rIEJyZWFrfSBpbiBhIHtAbGluayBTd2l0Y2h9LiAqL1xuXHRcdHRoaXMubG9vcHNOZWVkaW5nTGFiZWwgPSBuZXcgU2V0KClcblx0XHQvKiogU2V0IG9mIHtAbGluayBCcmVha31zIHRoYXQgYXJlIGluc2lkZSB7QGxpbmsgU3dpdGNofWVzLiAqL1xuXHRcdHRoaXMuYnJlYWtzSW5Td2l0Y2ggPSBuZXcgU2V0KClcblx0fVxuXG5cdC8qKiBHZXRzIHRoZSBMb2NhbERlY2xhcmUgdGhhdCB3YXMgdmVyaWZpZWQgdG8gYmUgdGhlIG9uZSBhY2Nlc3NlZC4gKi9cblx0bG9jYWxEZWNsYXJlRm9yQWNjZXNzKGxvY2FsQWNjZXNzKSB7XG5cdFx0cmV0dXJuIHRoaXMubG9jYWxBY2Nlc3NUb0RlY2xhcmUuZ2V0KGxvY2FsQWNjZXNzKVxuXHR9XG5cblx0LyoqIEdldCBjbG9zZXN0IGFzc2lnbm1lbnQgbmFtZSB0byBhbiBleHByZXNzaW9uLiAqL1xuXHRuYW1lKGV4cHIpIHtcblx0XHRjb25zdCBuYW1lID0gdGhpcy5uYW1lcy5nZXQoZXhwcilcblx0XHRjaGVjayhuYW1lICE9PSB1bmRlZmluZWQsIGV4cHIubG9jLCAnY2FudERldGVybWluZU5hbWUnKVxuXHRcdHJldHVybiBuYW1lXG5cdH1cblxuXHQvKipcblx0R2V0IGNsb3Nlc3QgYXNzaWdubWVudCBuYW1lIHRvIGFuIGV4cHJlc3Npb24sXG5cdG9yIGBudWxsYCBpZiBub25lIGlzIGF2YWlsYWJsZS5cblx0Ki9cblx0b3BOYW1lKGV4cHIpIHtcblx0XHRjb25zdCB4ID0gdGhpcy5uYW1lcy5nZXQoZXhwcilcblx0XHRyZXR1cm4geCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHhcblx0fVxuXG5cdC8qKiBDZXJ0YWluIGV4cHJlc3Npb25zIChzdWNoIGFzIGBpZmApIGFyZSBtYXJrZWQgaWYgdGhleSBhcmUgc3RhdGVtZW50cy4gKi9cblx0aXNTdGF0ZW1lbnQoZXhwcikge1xuXHRcdHJldHVybiB0aGlzLnN0YXRlbWVudHMuaGFzKGV4cHIpXG5cdH1cblxuXHQvKiogV2hhdCBraW5kIG9mIGJsb2NrIHRoZSB2ZXJpZmllciBkZXRlcm1pbmVkIHRoaXMgdG8gYmUuICovXG5cdGJsb2NrS2luZChibG9jaykge1xuXHRcdHJldHVybiB0aGlzLmJsb2NrVG9LaW5kLmdldChibG9jaylcblx0fVxuXG5cdC8qKiBXaGV0aGVyIGFuIE9iakVudHJ5IGlzIGEgbW9kdWxlIGV4cG9ydC4gKi9cblx0aXNPYmpFbnRyeUV4cG9ydChvYmpFbnRyeSkge1xuXHRcdHJldHVybiB0aGlzLm9iakVudHJ5RXhwb3J0cy5oYXMob2JqRW50cnkpXG5cdH1cblxuXHRjb25zdHJ1Y3Rvckhhc1N1cGVyKGN0cikge1xuXHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yVG9TdXBlci5oYXMoY3RyKVxuXHR9XG5cblx0LyoqIFdoZXRoZXIgc29tZSBgYnJlYWtgIGluIHRoaXMgbG9vcCBpcyBpbiBhIGBzd2l0Y2hgLiAqL1xuXHRsb29wTmVlZHNMYWJlbChsb29wKSB7XG5cdFx0cmV0dXJuIHRoaXMubG9vcHNOZWVkaW5nTGFiZWwuaGFzKGxvb3ApXG5cdH1cblxuXHQvKiogUmV0dXJucyB3aGV0aGVyIHRoZXJlIGlzIGEgYHN3aXRjaGAgaW4gYmV0d2VlbiB0aGlzIGBicmVha2AgYW5kIGl0cyBsb29wLiAqL1xuXHRpc0JyZWFrSW5Td2l0Y2goYnJlYWtBc3QpIHtcblx0XHRyZXR1cm4gdGhpcy5icmVha3NJblN3aXRjaC5oYXMoYnJlYWtBc3QpXG5cdH1cbn1cblxuLyoqIEtpbmRzIG9mIHtAbGluayBCbG9ja30uICovXG5leHBvcnQgY29uc3QgQmxvY2tzID0ge1xuXHREbzogMCxcblx0VGhyb3c6IDEsXG5cdFJldHVybjogMixcblx0QmFnOiAzLFxuXHRNYXA6IDQsXG5cdE9iajogNVxufVxuXG4vKiogS2luZHMgb2Yge0BsaW5rIE1vZHVsZX0uICovXG5leHBvcnQgY29uc3QgTW9kdWxlcyA9IHtcblx0RG86IDAsXG5cdFZhbDogMSxcblx0RXhwb3J0czogMixcblx0QmFnOiAzLFxuXHRNYXA6IDRcbn1cbiJdfQ==