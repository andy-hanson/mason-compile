if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports', './util'], function (exports, _util) {
	'use strict';

	Object.defineProperty(exports, '__esModule', {
		value: true
	});

	class VerifyResults {
		constructor() {
			// LocalAccess -> LocalDeclare.
			// Needed because lazy accesses must be compiled differently.
			this.localAccessToDeclare = new Map();
			// LocalDeclare -> VrLocalInfo.
			// Debug locals will not be output if not in debug mode.
			this.localDeclareToInfo = new Map();
			// TODO:ES6 Can use do `export { a, b, ... }` at the end, so shouldn't need this.
			// Includes both Assigns and AssignDestructures.
			this.exportAssigns = new Set();
			// Maps Class/Fun to name if one is appropriate.
			// Maps *every* SV_Name to the nearest name.
			this.names = new Map();
			// String -> Set.
			// For each path, the names of each builtin used.
			// Like the inverse of context.opts.builtinNameToPath,
			// but only includes names actually used.
			this.builtinPathToNames = new Map();
		}

		isDebugLocal(localDeclare) {
			return this.localDeclareToInfo.get(localDeclare).isInDebug;
		}

		isAccessed(localDeclare) {
			const info = this.localDeclareToInfo.get(localDeclare);
			return !((0, _util.isEmpty)(info.debugAccesses) && (0, _util.isEmpty)(info.nonDebugAccesses));
		}

		isExportAssign(assign) {
			return this.exportAssigns.has(assign);
		}

		localDeclareForAccess(localAccess) {
			return this.localAccessToDeclare.get(localAccess);
		}

		name(expr) {
			return this.names.get(expr);
		}

		opName(expr) {
			const x = this.names.get(expr);
			return x === undefined ? null : x;
		}
	}

	exports.default = VerifyResults;

	class LocalInfo {
		static empty(isInDebug) {
			return new LocalInfo(isInDebug, [], []);
		}

		constructor(isInDebug, /* Boolean */
		debugAccesses, /* LocalAccess */
		nonDebugAccesses /* Array[LocalAccess] */) {
			this.isInDebug = isInDebug;
			this.debugAccesses = debugAccesses;
			this.nonDebugAccesses = nonDebugAccesses;
		}
	}

	exports.LocalInfo = LocalInfo;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlZlcmlmeVJlc3VsdHMuanMiLCJwcml2YXRlL1ZlcmlmeVJlc3VsdHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7QUNFZSxPQUFNLGFBQWEsQ0FBQztBQUNsQyxhQUFXLEdBQUc7OztBQUdiLE9BQUksQ0FBQyxvQkFBb0IsR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFBOzs7QUFHckMsT0FBSSxDQUFDLGtCQUFrQixHQUFHLElBQUksR0FBRyxFQUFFLENBQUE7OztBQUduQyxPQUFJLENBQUMsYUFBYSxHQUFHLElBQUksR0FBRyxFQUFFLENBQUE7OztBQUc5QixPQUFJLENBQUMsS0FBSyxHQUFHLElBQUksR0FBRyxFQUFFLENBQUE7Ozs7O0FBS3RCLE9BQUksQ0FBQyxrQkFBa0IsR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFBO0dBQ25DOztBQUVELGNBQVksQ0FBQyxZQUFZLEVBQUU7QUFDMUIsVUFBTyxJQUFJLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDLFNBQVMsQ0FBQTtHQUMxRDs7QUFFRCxZQUFVLENBQUMsWUFBWSxFQUFFO0FBQ3hCLFNBQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLENBQUE7QUFDdEQsVUFBTyxFQUFFLFVBN0JGLE9BQU8sRUE2QkcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLFVBN0JqQyxPQUFPLEVBNkJrQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQSxBQUFDLENBQUE7R0FDdkU7O0FBRUQsZ0JBQWMsQ0FBQyxNQUFNLEVBQUU7QUFDdEIsVUFBTyxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQTtHQUNyQzs7QUFFRCx1QkFBcUIsQ0FBQyxXQUFXLEVBQUU7QUFDbEMsVUFBTyxJQUFJLENBQUMsb0JBQW9CLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFBO0dBQ2pEOztBQUVELE1BQUksQ0FBQyxJQUFJLEVBQUU7QUFDVixVQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFBO0dBQzNCOztBQUVELFFBQU0sQ0FBQyxJQUFJLEVBQUU7QUFDWixTQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQTtBQUM5QixVQUFPLENBQUMsS0FBSyxTQUFTLEdBQUcsSUFBSSxHQUFHLENBQUMsQ0FBQTtHQUNqQztFQUNEOzttQkE5Q29CLGFBQWE7O0FBZ0QzQixPQUFNLFNBQVMsQ0FBQztBQUN0QixTQUFPLEtBQUssQ0FBQyxTQUFTLEVBQUU7QUFDdkIsVUFBTyxJQUFJLFNBQVMsQ0FBQyxTQUFTLEVBQUUsRUFBRyxFQUFFLEVBQUcsQ0FBQyxDQUFBO0dBQ3pDOztBQUVELGFBQVcsQ0FDVixTQUFTO0FBQ1QsZUFBYTtBQUNiLGtCQUFnQiwyQkFBMkI7QUFDM0MsT0FBSSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUE7QUFDMUIsT0FBSSxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUE7QUFDbEMsT0FBSSxDQUFDLGdCQUFnQixHQUFHLGdCQUFnQixDQUFBO0dBQ3hDO0VBQ0QiLCJmaWxlIjoicHJpdmF0ZS9WZXJpZnlSZXN1bHRzLmpzIiwic291cmNlc0NvbnRlbnQiOltudWxsLCJpbXBvcnQgeyBpc0VtcHR5IH0gZnJvbSAnLi91dGlsJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWZXJpZnlSZXN1bHRzIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0Ly8gTG9jYWxBY2Nlc3MgLT4gTG9jYWxEZWNsYXJlLlxuXHRcdC8vIE5lZWRlZCBiZWNhdXNlIGxhenkgYWNjZXNzZXMgbXVzdCBiZSBjb21waWxlZCBkaWZmZXJlbnRseS5cblx0XHR0aGlzLmxvY2FsQWNjZXNzVG9EZWNsYXJlID0gbmV3IE1hcCgpXG5cdFx0Ly8gTG9jYWxEZWNsYXJlIC0+IFZyTG9jYWxJbmZvLlxuXHRcdC8vIERlYnVnIGxvY2FscyB3aWxsIG5vdCBiZSBvdXRwdXQgaWYgbm90IGluIGRlYnVnIG1vZGUuXG5cdFx0dGhpcy5sb2NhbERlY2xhcmVUb0luZm8gPSBuZXcgTWFwKClcblx0XHQvLyBUT0RPOkVTNiBDYW4gdXNlIGRvIGBleHBvcnQgeyBhLCBiLCAuLi4gfWAgYXQgdGhlIGVuZCwgc28gc2hvdWxkbid0IG5lZWQgdGhpcy5cblx0XHQvLyBJbmNsdWRlcyBib3RoIEFzc2lnbnMgYW5kIEFzc2lnbkRlc3RydWN0dXJlcy5cblx0XHR0aGlzLmV4cG9ydEFzc2lnbnMgPSBuZXcgU2V0KClcblx0XHQvLyBNYXBzIENsYXNzL0Z1biB0byBuYW1lIGlmIG9uZSBpcyBhcHByb3ByaWF0ZS5cblx0XHQvLyBNYXBzICpldmVyeSogU1ZfTmFtZSB0byB0aGUgbmVhcmVzdCBuYW1lLlxuXHRcdHRoaXMubmFtZXMgPSBuZXcgTWFwKClcblx0XHQvLyBTdHJpbmcgLT4gU2V0LlxuXHRcdC8vIEZvciBlYWNoIHBhdGgsIHRoZSBuYW1lcyBvZiBlYWNoIGJ1aWx0aW4gdXNlZC5cblx0XHQvLyBMaWtlIHRoZSBpbnZlcnNlIG9mIGNvbnRleHQub3B0cy5idWlsdGluTmFtZVRvUGF0aCxcblx0XHQvLyBidXQgb25seSBpbmNsdWRlcyBuYW1lcyBhY3R1YWxseSB1c2VkLlxuXHRcdHRoaXMuYnVpbHRpblBhdGhUb05hbWVzID0gbmV3IE1hcCgpXG5cdH1cblxuXHRpc0RlYnVnTG9jYWwobG9jYWxEZWNsYXJlKSB7XG5cdFx0cmV0dXJuIHRoaXMubG9jYWxEZWNsYXJlVG9JbmZvLmdldChsb2NhbERlY2xhcmUpLmlzSW5EZWJ1Z1xuXHR9XG5cblx0aXNBY2Nlc3NlZChsb2NhbERlY2xhcmUpIHtcblx0XHRjb25zdCBpbmZvID0gdGhpcy5sb2NhbERlY2xhcmVUb0luZm8uZ2V0KGxvY2FsRGVjbGFyZSlcblx0XHRyZXR1cm4gIShpc0VtcHR5KGluZm8uZGVidWdBY2Nlc3NlcykgJiYgaXNFbXB0eShpbmZvLm5vbkRlYnVnQWNjZXNzZXMpKVxuXHR9XG5cblx0aXNFeHBvcnRBc3NpZ24oYXNzaWduKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXhwb3J0QXNzaWducy5oYXMoYXNzaWduKVxuXHR9XG5cblx0bG9jYWxEZWNsYXJlRm9yQWNjZXNzKGxvY2FsQWNjZXNzKSB7XG5cdFx0cmV0dXJuIHRoaXMubG9jYWxBY2Nlc3NUb0RlY2xhcmUuZ2V0KGxvY2FsQWNjZXNzKVxuXHR9XG5cblx0bmFtZShleHByKSB7XG5cdFx0cmV0dXJuIHRoaXMubmFtZXMuZ2V0KGV4cHIpXG5cdH1cblxuXHRvcE5hbWUoZXhwcikge1xuXHRcdGNvbnN0IHggPSB0aGlzLm5hbWVzLmdldChleHByKVxuXHRcdHJldHVybiB4ID09PSB1bmRlZmluZWQgPyBudWxsIDogeFxuXHR9XG59XG5cbmV4cG9ydCBjbGFzcyBMb2NhbEluZm8ge1xuXHRzdGF0aWMgZW1wdHkoaXNJbkRlYnVnKSB7XG5cdFx0cmV0dXJuIG5ldyBMb2NhbEluZm8oaXNJbkRlYnVnLCBbIF0sIFsgXSlcblx0fVxuXG5cdGNvbnN0cnVjdG9yKFxuXHRcdGlzSW5EZWJ1ZyAvKiBCb29sZWFuICovLFxuXHRcdGRlYnVnQWNjZXNzZXMgLyogTG9jYWxBY2Nlc3MgKi8sXG5cdFx0bm9uRGVidWdBY2Nlc3NlcyAvKiBBcnJheVtMb2NhbEFjY2Vzc10gKi8pIHtcblx0XHR0aGlzLmlzSW5EZWJ1ZyA9IGlzSW5EZWJ1Z1xuXHRcdHRoaXMuZGVidWdBY2Nlc3NlcyA9IGRlYnVnQWNjZXNzZXNcblx0XHR0aGlzLm5vbkRlYnVnQWNjZXNzZXMgPSBub25EZWJ1Z0FjY2Vzc2VzXG5cdH1cbn1cbiJdLCJzb3VyY2VSb290IjoiL3NyYyJ9