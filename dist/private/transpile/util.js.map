{"version":3,"sources":["private/transpile/util.js","private/transpile/util.ts"],"names":[],"mappings":"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","file":"private/transpile/util.js","sourcesContent":["(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", 'esast/lib/ast', 'esast-create-util/lib/util', 'op/Op', '../context', '../MsAst', '../util', './ast-constants', './context'], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    var ast_1 = require('esast/lib/ast');\n    var util_1 = require('esast-create-util/lib/util');\n    var Op_1 = require('op/Op');\n    var context_1 = require('../context');\n    var MsAst_1 = require('../MsAst');\n    var util_2 = require('../util');\n    var ast_constants_1 = require('./ast-constants');\n    var context_2 = require('./context');\n    function t0(expr) {\n        return util_1.loc(expr.transpile(), expr.loc);\n    }\n    exports.t0 = t0;\n    function t1(expr, arg) {\n        return util_1.loc(expr.transpile(arg), expr.loc);\n    }\n    exports.t1 = t1;\n    function t2(expr, arg, arg2) {\n        return util_1.loc(expr.transpile(arg, arg2), expr.loc);\n    }\n    exports.t2 = t2;\n    function t3(expr, arg, arg2, arg3) {\n        return util_1.loc(expr.transpile(arg, arg2, arg3), expr.loc);\n    }\n    exports.t3 = t3;\n    function tLines(exprs) {\n        const out = [];\n        for (const expr of exprs) {\n            const ast = expr.transpile();\n            if (ast instanceof Array)\n                for (const _ of ast)\n                    out.push(util_1.toLineContent(_));\n            else\n                out.push(util_1.loc(util_1.toLineContent(ast), expr.loc));\n        }\n        return out;\n    }\n    exports.tLines = tLines;\n    function accessLocalDeclare(localDeclare) {\n        const id = idForDeclareCached(localDeclare);\n        return localDeclare.isLazy ? msCall('unlazy', id) : new ast_1.Identifier(id.name);\n    }\n    exports.accessLocalDeclare = accessLocalDeclare;\n    function makeDeclare(localDeclare, val) {\n        return new ast_1.VariableDeclaration('let', [new ast_1.VariableDeclarator(idForDeclareCached(localDeclare), val)]);\n    }\n    exports.makeDeclare = makeDeclare;\n    const declareToId = new WeakMap();\n    function idForDeclareCached(localDeclare) {\n        let _ = declareToId.get(localDeclare);\n        if (_ === undefined) {\n            _ = util_1.identifier(localDeclare.name);\n            declareToId.set(localDeclare, _);\n        }\n        return _;\n    }\n    exports.idForDeclareCached = idForDeclareCached;\n    function opTypeCheckForLocalDeclare(localDeclare) {\n        return Op_1.opIf(!localDeclare.isLazy, () => Op_1.opMap(localDeclare.opType, type => new ast_1.ExpressionStatement(msCall('checkInstance', t0(type), accessLocalDeclare(localDeclare), new ast_1.LiteralString(localDeclare.name)))));\n    }\n    exports.opTypeCheckForLocalDeclare = opTypeCheckForLocalDeclare;\n    function throwErrorFromString(message) {\n        return new ast_1.ThrowStatement(new ast_1.NewExpression(new ast_1.Identifier('Error'), [new ast_1.LiteralString(message)]));\n    }\n    exports.throwErrorFromString = throwErrorFromString;\n    function makeDeclarator(assignee, value, valueIsAlreadyLazy) {\n        const { name, opType } = assignee;\n        const isLazy = assignee.isLazy;\n        value = isLazy ? value : maybeWrapInCheckInstance(value, opType, name);\n        const val = isLazy && !valueIsAlreadyLazy ? lazyWrap(value) : value;\n        util_2.assert(isLazy || !valueIsAlreadyLazy);\n        return new ast_1.VariableDeclarator(idForDeclareCached(assignee), val);\n    }\n    exports.makeDeclarator = makeDeclarator;\n    function maybeWrapInCheckInstance(ast, opType, name) {\n        return context_1.options.checks && Op_1.nonNull(opType) ?\n            msCall('checkInstance', t0(opType), ast, new ast_1.LiteralString(name)) :\n            ast;\n    }\n    exports.maybeWrapInCheckInstance = maybeWrapInCheckInstance;\n    function doThrow(thrown) {\n        return new ast_1.ThrowStatement(thrown instanceof MsAst_1.QuoteAbstract ?\n            new ast_1.NewExpression(ast_constants_1.GlobalError, [t0(thrown)]) :\n            t0(thrown));\n    }\n    exports.doThrow = doThrow;\n    function transpileName(name) {\n        return typeof name === 'string' ? new ast_1.LiteralString(name) : t0(name);\n    }\n    exports.transpileName = transpileName;\n    function memberStringOrVal(object, memberName) {\n        return typeof memberName === 'string' ?\n            util_1.member(object, memberName) :\n            new ast_1.MemberExpressionComputed(object, t0(memberName));\n    }\n    exports.memberStringOrVal = memberStringOrVal;\n    function lazyWrap(value) {\n        return msCall('lazy', new ast_1.ArrowFunctionExpression([], value));\n    }\n    exports.lazyWrap = lazyWrap;\n    const IdMs = new ast_1.Identifier('_ms');\n    function msCall(name, ...args) {\n        return new ast_1.CallExpression(util_1.member(IdMs, name), args);\n    }\n    exports.msCall = msCall;\n    function msMember(name) {\n        return util_1.member(IdMs, name);\n    }\n    exports.msMember = msMember;\n    function makeDestructureDeclarators(assignees, isLazy, value, isModule) {\n        const id = context_2.getDestructuredId();\n        const destructuredName = `_$${id}`;\n        const idDestructured = new ast_1.Identifier(destructuredName);\n        const declarators = assignees.map(assignee => {\n            const get = getMember(idDestructured, assignee.name, isLazy, isModule);\n            return makeDeclarator(assignee, get, isLazy);\n        });\n        const val = isLazy && !isModule ? lazyWrap(value) : value;\n        return util_2.cat(new ast_1.VariableDeclarator(idDestructured, val), declarators);\n    }\n    exports.makeDestructureDeclarators = makeDestructureDeclarators;\n    function getMember(astObject, gotName, isLazy, isModule) {\n        return isLazy ?\n            msCall('lazyProp', astObject, new ast_1.LiteralString(gotName)) :\n            isModule && context_1.options.checks ?\n                msCall('get', astObject, new ast_1.LiteralString(gotName)) :\n                util_1.member(astObject, gotName);\n    }\n    function blockWrap(block) {\n        const thunk = context_2.funKind === 0 ?\n            new ast_1.ArrowFunctionExpression([], block) :\n            new ast_1.FunctionExpression(null, [], block, { generator: true });\n        return callPreservingFunKind(new ast_1.CallExpression(thunk, []));\n    }\n    exports.blockWrap = blockWrap;\n    function callFocusFun(value, calledOn) {\n        const fun = context_2.funKind === 0 ?\n            new ast_1.ArrowFunctionExpression([ast_constants_1.IdFocus], value) :\n            new ast_1.FunctionExpression(null, [ast_constants_1.IdFocus], new ast_1.BlockStatement([new ast_1.ReturnStatement(value)]), { generator: true });\n        return callPreservingFunKind(new ast_1.CallExpression(fun, [calledOn]));\n    }\n    exports.callFocusFun = callFocusFun;\n    function callPreservingFunKind(call) {\n        return context_2.funKind === 0 ? call : new ast_1.YieldExpression(call, true);\n    }\n    function blockWrapIfBlock(value) {\n        return value instanceof MsAst_1.Block ? blockWrap(t0(value)) : t0(value);\n    }\n    exports.blockWrapIfBlock = blockWrapIfBlock;\n    function blockWrapIfVal(ast, statement) {\n        return context_2.verifyResults.isStatement(ast) ?\n            statement :\n            blockWrap(new ast_1.BlockStatement(util_2.toArray(statement)));\n    }\n    exports.blockWrapIfVal = blockWrapIfVal;\n    function focusFun(value) {\n        return new ast_1.ArrowFunctionExpression([ast_constants_1.IdFocus], value);\n    }\n    exports.focusFun = focusFun;\n    function plainLet(identifier, value) {\n        return new ast_1.VariableDeclaration('let', [new ast_1.VariableDeclarator(identifier, value)]);\n    }\n    exports.plainLet = plainLet;\n});\n","import Node, {ArrowFunctionExpression, BlockStatement, CallExpression, Expression, ExpressionStatement,\n\tFunctionExpression, Identifier, LiteralString, MemberExpression, MemberExpressionComputed, NewExpression, ReturnStatement, Statement,\n\tThrowStatement, VariableDeclarator, VariableDeclaration, YieldExpression} from 'esast/lib/ast'\nimport {identifier, loc, member, toLineContent} from 'esast-create-util/lib/util'\nimport Op, {nonNull, opIf, opMap} from 'op/Op'\nimport {options} from '../context'\nimport MsAst, {Block, Val, Funs, LineContent, LocalDeclare, Name, QuoteAbstract, ValOrDo} from '../MsAst'\nimport {assert, cat, toArray} from '../util'\nimport {IdFocus, GlobalError} from './ast-constants'\nimport {funKind, getDestructuredId, verifyResults} from './context'\n\nexport function t0(expr: MsAst): any {\n\treturn loc(expr.transpile(), expr.loc)\n}\nexport function t1(expr: MsAst, arg: any): any {\n\treturn loc(expr.transpile(arg), expr.loc)\n}\nexport function t2(expr: MsAst, arg: any, arg2: any): any {\n\treturn loc(expr.transpile(arg, arg2), expr.loc)\n}\nexport function t3(expr: MsAst, arg: any, arg2: any, arg3: any): any {\n\treturn loc(expr.transpile(arg, arg2, arg3), expr.loc)\n}\nexport function tLines(exprs: Array<LineContent>): Array<Statement> {\n\tconst out: Array<Statement> = []\n\tfor (const expr of exprs) {\n\t\tconst ast = expr.transpile()\n\t\tif (ast instanceof Array)\n\t\t\t// Ignore produces 0 statements and Region produces many.\n\t\t\tfor (const _ of ast)\n\t\t\t\tout.push(toLineContent(_))\n\t\telse\n\t\t\tout.push(loc(toLineContent(ast), expr.loc))\n\t}\n\treturn out\n}\n\nexport function accessLocalDeclare(localDeclare: LocalDeclare): Expression {\n\tconst id = idForDeclareCached(localDeclare)\n\treturn localDeclare.isLazy ? msCall('unlazy', id) : new Identifier(id.name)\n}\n\nexport function makeDeclare(localDeclare: LocalDeclare, val: Node): VariableDeclaration {\n\treturn new VariableDeclaration('let',\n\t\t[new VariableDeclarator(idForDeclareCached(localDeclare), val)])\n}\n\nconst declareToId: WeakMap<LocalDeclare, Identifier> = new WeakMap()\nexport function idForDeclareCached(localDeclare: LocalDeclare): Identifier {\n\tlet _ = declareToId.get(localDeclare)\n\tif (_ === undefined) {\n\t\t_ = identifier(localDeclare.name)\n\t\tdeclareToId.set(localDeclare, _)\n\t}\n\treturn _\n}\n\nexport function opTypeCheckForLocalDeclare(localDeclare: LocalDeclare): Op<Statement> {\n\t// TODO: Way to typecheck lazies\n\treturn opIf(!localDeclare.isLazy, () =>\n\t\topMap(localDeclare.opType, type =>\n\t\t\tnew ExpressionStatement(msCall(\n\t\t\t\t'checkInstance',\n\t\t\t\tt0(type),\n\t\t\t\taccessLocalDeclare(localDeclare),\n\t\t\t\tnew LiteralString(localDeclare.name)))))\n}\n\nexport function throwErrorFromString(message: string): ThrowStatement {\n\t// TODO:ES6 Should be able to use IdError in ast-constants without recursive module problems\n\treturn new ThrowStatement(\n\t\tnew NewExpression(new Identifier('Error'), [new LiteralString(message)]))\n}\n\nexport function makeDeclarator(assignee: LocalDeclare, value: Expression, valueIsAlreadyLazy: boolean): VariableDeclarator {\n\tconst {name, opType} = assignee\n\tconst isLazy = assignee.isLazy\n\t// TODO: assert(assignee.opType === null)\n\t// or TODO: Allow type check on lazy value?\n\tvalue = isLazy ? value : maybeWrapInCheckInstance(value, opType, name)\n\tconst val = isLazy && !valueIsAlreadyLazy ? lazyWrap(value) : value\n\tassert(isLazy || !valueIsAlreadyLazy)\n\treturn new VariableDeclarator(idForDeclareCached(assignee), val)\n}\n\nexport function maybeWrapInCheckInstance(ast: Expression, opType: Op<Val>, name: string): Expression {\n\treturn options.checks && nonNull(opType) ?\n\t\tmsCall('checkInstance', t0(opType), ast, new LiteralString(name)) :\n\t\tast\n}\n\nexport function doThrow(thrown: Val): ThrowStatement {\n\treturn new ThrowStatement(thrown instanceof QuoteAbstract ?\n\t\tnew NewExpression(GlobalError, [t0(thrown)]) :\n\t\tt0(thrown))\n}\n\nexport function transpileName(name: Name): Expression {\n\treturn typeof name === 'string' ? new LiteralString(name) : t0(name)\n}\n\nexport function memberStringOrVal(object: Expression, memberName: Name): MemberExpression {\n\treturn typeof memberName === 'string' ?\n\t\tmember(object, memberName) :\n\t\tnew MemberExpressionComputed(object, t0(memberName))\n}\n\nexport function lazyWrap(value: Expression): Expression {\n\treturn msCall('lazy', new ArrowFunctionExpression([], value))\n}\n\nconst IdMs = new Identifier('_ms')\nexport function msCall(name: string, ...args: Array<Expression>): Expression {\n\treturn new CallExpression(member(IdMs, name), args)\n}\n\nexport function msMember(name: string): Expression {\n\treturn member(IdMs, name)\n}\n\nexport function makeDestructureDeclarators(\n\tassignees: Array<LocalDeclare>,\n\tisLazy: boolean,\n\tvalue: Expression,\n\tisModule: boolean): Array<VariableDeclarator> {\n\tconst id = getDestructuredId()\n\tconst destructuredName = `_$${id}`\n\tconst idDestructured = new Identifier(destructuredName)\n\tconst declarators = assignees.map(assignee => {\n\t\tconst get = getMember(idDestructured, assignee.name, isLazy, isModule)\n\t\treturn makeDeclarator(assignee, get, isLazy)\n\t})\n\t// Getting lazy module is done by ms.lazyGetModule.\n\tconst val = isLazy && !isModule ? lazyWrap(value) : value\n\treturn cat(new VariableDeclarator(idDestructured, val), declarators)\n}\nfunction getMember(astObject: Expression, gotName: string, isLazy: boolean, isModule: boolean): Expression {\n\treturn isLazy ?\n\t\tmsCall('lazyProp', astObject, new LiteralString(gotName)) :\n\t\tisModule && options.checks ?\n\t\tmsCall('get', astObject, new LiteralString(gotName)) :\n\t\tmember(astObject, gotName)\n}\n\n/** Wraps a block (with `return` statements in it) in an IIFE. */\nexport function blockWrap(block: BlockStatement): Expression {\n\tconst thunk = funKind === Funs.Plain ?\n\t\tnew ArrowFunctionExpression([], block) :\n\t\tnew FunctionExpression(null, [], block, {generator: true})\n\treturn callPreservingFunKind(new CallExpression(thunk, []))\n}\n\n/** Create a focus fun returning `value` and call it on `calledOn`, preserving generator/async. */\nexport function callFocusFun(value: Expression, calledOn: Expression): Expression {\n\tconst fun = funKind === Funs.Plain ?\n\t\tnew ArrowFunctionExpression([IdFocus], value) :\n\t\tnew FunctionExpression(\n\t\t\tnull, [IdFocus], new BlockStatement([new ReturnStatement(value)]), {generator: true})\n\treturn callPreservingFunKind(new CallExpression(fun, [calledOn]))\n}\n\n/**\nCall a function created by `blockWrap` or `callFocusFun`.\nThis looks like:\n\tFuns.Plain: `(_ => foo(_))(1)`.\n\tFuns.Generator, Funs.Async: `yield* function*(_) { return foo(_) }(1)`\n*/\nfunction callPreservingFunKind(call: Expression): Expression {\n\treturn funKind === Funs.Plain ? call : new YieldExpression(call, true)\n}\n\nexport function blockWrapIfBlock(value: Block | Val): Expression {\n\t// todo: in first case, block transpiles to BlockStatement\n\t// in second case, transpiles to Expression\n\treturn value instanceof Block ? blockWrap(<any> t0(value)) : (<any> t0(value))\n}\n\n/** Wraps a statement in an IIFE if its MsAst is a value. */\nexport function blockWrapIfVal(ast: ValOrDo, statement: Statement | Array<Statement>): Expression | Statement | Array<Statement> {\n\treturn verifyResults.isStatement(ast) ?\n\t\tstatement :\n\t\tblockWrap(new BlockStatement(toArray(statement)))\n}\n\nexport function focusFun(value: Expression): ArrowFunctionExpression {\n\treturn new ArrowFunctionExpression([IdFocus], value)\n}\n\nexport function plainLet(identifier: Identifier, value: Expression): VariableDeclaration {\n\treturn new VariableDeclaration('let', [new VariableDeclarator(identifier, value)])\n}\n"],"sourceRoot":"/source/"}