if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports', '../context', '../MsAst', '../Token', '../util', './checks', './parseBlock', './parseCase', './parseExcept', './parseFor', './parseLocalDeclares', './parseMemberName', './parseQuote', './parse*', './Slice'], function (exports, _context, _MsAst, _Token, _util, _checks, _parseBlock, _parseCase, _parseExcept, _parseFor, _parseLocalDeclares, _parseMemberName, _parseQuote, _parse, _Slice) {
	'use strict';

	Object.defineProperty(exports, '__esModule', {
		value: true
	});

	var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

	exports.default = parseLine;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _parseCase2 = _interopRequireDefault(_parseCase);

	var _parseExcept2 = _interopRequireDefault(_parseExcept);

	var _parseLocalDeclares2 = _interopRequireDefault(_parseLocalDeclares);

	var _parseMemberName2 = _interopRequireDefault(_parseMemberName);

	var _parseQuote2 = _interopRequireDefault(_parseQuote);

	var _Slice2 = _interopRequireDefault(_Slice);

	/** Parse the content of a line. */

	function parseLine(tokens) {
		const head = tokens.head();
		const rest = tokens.tail();

		const noRest = () => (0, _checks.checkEmpty)(rest, () => `Did not expect anything after ${ head }.`);

		// We only deal with mutable expressions here, otherwise we fall back to parseExpr.
		if (head instanceof _Token.Keyword) switch (head.kind) {
			case _Token.Keywords.Assert:case _Token.Keywords.AssertNot:
				return parseAssert(head.kind === _Token.Keywords.AssertNot, rest);
			case _Token.Keywords.ExceptDo:
				return (0, _parseExcept2.default)(_Token.Keywords.ExceptDo, rest);
			case _Token.Keywords.Break:
				noRest();
				return new _MsAst.Break(tokens.loc);
			case _Token.Keywords.BreakWithVal:
				return new _MsAst.BreakWithVal(tokens.loc, (0, _parse.parseExpr)(rest));
			case _Token.Keywords.CaseDo:
				return (0, _parseCase2.default)(false, false, rest);
			case _Token.Keywords.Debugger:
				noRest();
				return new _MsAst.SpecialDo(tokens.loc, _MsAst.SpecialDos.Debugger);
			case _Token.Keywords.Ellipsis:
				return new _MsAst.BagEntryMany(tokens.loc, (0, _parse.parseExpr)(rest));
			case _Token.Keywords.ForDo:
				return (0, _parseFor.parseForDo)(rest);
			case _Token.Keywords.Ignore:
				return new _MsAst.Ignore(tokens.loc, rest.map(_parseLocalDeclares.parseLocalName));
			case _Token.Keywords.IfDo:case _Token.Keywords.UnlessDo:
				{
					var _beforeAndBlock = (0, _parseBlock.beforeAndBlock)(rest);

					var _beforeAndBlock2 = _slicedToArray(_beforeAndBlock, 2);

					const before = _beforeAndBlock2[0];
					const block = _beforeAndBlock2[1];

					return new _MsAst.ConditionalDo(tokens.loc, (0, _parse.parseExpr)(before), (0, _parseBlock.parseBlockDo)(block), head.kind === _Token.Keywords.UnlessDo);
				}
			case _Token.Keywords.ObjAssign:
				return new _MsAst.BagEntry(tokens.loc, (0, _parse.parseExpr)(rest));
			case _Token.Keywords.Pass:
				noRest();
				return [];
			case _Token.Keywords.Region:
				return (0, _parseBlock.parseLinesFromBlock)(tokens);
			case _Token.Keywords.SuperDo:
				return new _MsAst.SuperCallDo(tokens.loc, (0, _parse.parseExprParts)(rest));
			case _Token.Keywords.SwitchDo:
				return (0, _parse.parseSwitch)(false, false, rest);
			case _Token.Keywords.Throw:
				return new _MsAst.Throw(tokens.loc, (0, _util.opIf)(!rest.isEmpty(), () => (0, _parse.parseExpr)(rest)));
			case _Token.Keywords.Name:
				if ((0, _Token.isKeyword)(_Token.Keywords.ObjAssign, rest.head())) {
					const r = rest.tail();
					const val = r.isEmpty() ? new _MsAst.SpecialVal(tokens.loc, _MsAst.SpecialVals.Name) : (0, _parse.parseExpr)(r);
					return _MsAst.ObjEntryPlain.name(tokens.loc, val);
				}
			// else fall through
			default:
			// fall through
		}

		return (0, _util.ifElse)(tokens.opSplitOnce(_ => (0, _Token.isAnyKeyword)(lineSplitKeywords, _)), _ref => {
			let before = _ref.before;
			let at = _ref.at;
			let after = _ref.after;
			return parseAssignLike(before, at, after, tokens.loc);
		}, () => (0, _parse.parseExpr)(tokens));
	}

	const parseLineOrLines = tokens => {
		const _ = parseLine(tokens);
		return _ instanceof Array ? _ : [_];
	};

	exports.parseLineOrLines = parseLineOrLines;
	const lineSplitKeywords = new Set([_Token.Keywords.Assign, _Token.Keywords.AssignMutable, _Token.Keywords.LocalMutate, _Token.Keywords.MapEntry, _Token.Keywords.ObjAssign, _Token.Keywords.Yield, _Token.Keywords.YieldTo]);

	function parseAssignLike(before, at, after, loc) {
		const kind = at.kind;
		if (kind === _Token.Keywords.MapEntry) return new _MsAst.MapEntry(loc, (0, _parse.parseExpr)(before), (0, _parse.parseExpr)(after));

		if (before.size() === 1) {
			const token = before.head();
			// `a.b = c`, `.b = c`, `a."b" = c`, `."b" = c`, `a[b] = c`
			if ((0, _Token.isGroup)(_Token.Groups.Space, token)) {
				const spaced = _Slice2.default.group(token);

				var _ifElse = (0, _util.ifElse)(spaced.opSplitOnce(_ => (0, _Token.isKeyword)(_Token.Keywords.Type, _)), _ref2 => {
					let before = _ref2.before;
					let after = _ref2.after;
					return [before, (0, _parse.parseExpr)(after)];
				}, () => [spaced, null]);

				var _ifElse2 = _slicedToArray(_ifElse, 2);

				const value = _ifElse2[0];
				const opType = _ifElse2[1];

				const last = value.last();
				const object = obj => obj.isEmpty() ? _MsAst.LocalAccess.this(obj.loc) : (0, _parse.parseSpaced)(obj);

				if ((0, _Token.isKeyword)(_Token.Keywords.Dot, value.nextToLast())) {
					const name = (0, _parseMemberName2.default)(last);
					const set = object(value.rtail().rtail());
					return new _MsAst.MemberSet(loc, set, name, opType, setKind(at), (0, _parse.parseExpr)(after));
				} else if ((0, _Token.isGroup)(_Token.Groups.Bracket, last)) {
					const set = object(value.rtail());
					return parseSubSet(set, _Slice2.default.group(last), opType, at, after, loc);
				}
				// `"1". 1`
			} else if ((0, _Token.isGroup)(_Token.Groups.Quote, token) && kind === _Token.Keywords.ObjAssign) return new _MsAst.ObjEntryComputed(loc, (0, _parseQuote2.default)(_Slice2.default.group(token)), (0, _parse.parseExpr)(after));
		}

		return kind === _Token.Keywords.LocalMutate ? parseLocalMutate(before, after, loc) : parseAssign(before, kind, after, loc);
	}

	function setKind(keyword) {
		switch (keyword.kind) {
			case _Token.Keywords.Assign:
				return _MsAst.Setters.Init;
			case _Token.Keywords.AssignMutable:
				return _MsAst.Setters.InitMutable;
			case _Token.Keywords.LocalMutate:
				return _MsAst.Setters.Mutate;
			default:
				(0, _checks.unexpected)(keyword);
		}
	}

	function parseSubSet(object, subbed, opType, at, after, loc) {
		const subbeds = (0, _parse.parseExprParts)(subbed);
		return new _MsAst.SetSub(loc, object, subbeds, opType, setKind(at), (0, _parse.parseExpr)(after));
	}

	function parseLocalMutate(localsTokens, valueTokens, loc) {
		const locals = (0, _parseLocalDeclares.parseLocalDeclaresJustNames)(localsTokens);
		(0, _context.check)(locals.length === 1, loc, 'TODO: LocalDestructureMutate');
		const name = locals[0].name;
		const value = (0, _parse.parseExpr)(valueTokens);
		return new _MsAst.LocalMutate(loc, name, value);
	}

	function parseAssign(localsTokens, kind, valueTokens, loc) {
		const locals = (0, _parseLocalDeclares2.default)(localsTokens);

		// Handle `a.` which moves an outer local into an ObjEntry.
		if (kind === _Token.Keywords.ObjAssign && valueTokens.isEmpty() && locals.length === 1) {
			const local = locals[0];
			(0, _context.check)(local.opType === null, local.loc, () => `Type declaration should go with initial declaration of ${ local.name }.`);
			return _MsAst.ObjEntryPlain.access(loc, local.name);
		}

		const value = parseAssignValue(kind, valueTokens);

		const isYield = kind === _Token.Keywords.Yield || kind === _Token.Keywords.YieldTo;
		if ((0, _util.isEmpty)(locals)) {
			(0, _context.check)(isYield, localsTokens.loc, 'Assignment to nothing');
			return value;
		} else {
			if (isYield) for (const _ of locals) (0, _context.check)(!_.isLazy(), _.loc, 'Can not yield to lazy variable.');

			const isObjAssign = kind === _Token.Keywords.ObjAssign;

			if (kind === _Token.Keywords.AssignMutable) for (let _ of locals) {
				(0, _context.check)(!_.isLazy(), _.loc, 'Lazy local can not be mutable.');
				_.kind = _MsAst.LocalDeclares.Mutable;
			}

			const wrap = _ => isObjAssign ? new _MsAst.ObjEntryAssign(loc, _) : _;

			if (locals.length === 1) {
				const assignee = locals[0];
				const assign = new _MsAst.AssignSingle(loc, assignee, value);
				return wrap(assign);
			} else {
				const kind = locals[0].kind;
				for (const _ of locals) (0, _context.check)(_.kind === kind, _.loc, 'All locals of destructuring assignment must be of the same kind.');
				return wrap(new _MsAst.AssignDestructure(loc, locals, value, kind));
			}
		}
	}

	function parseAssignValue(kind, valueTokens) {
		const value = (0, _parse.parseExpr)(valueTokens);
		switch (kind) {
			case _Token.Keywords.Yield:
				return new _MsAst.Yield(value.loc, value);
			case _Token.Keywords.YieldTo:
				return new _MsAst.YieldTo(value.loc, value);
			default:
				return value;
		}
	}

	function parseAssert(negate, tokens) {
		(0, _checks.checkNonEmpty)(tokens, () => `Expected something after ${ (0, _Token.keywordName)(_Token.Keywords.Assert) }.`);

		var _ifElse3 = (0, _util.ifElse)(tokens.opSplitOnce(_ => (0, _Token.isKeyword)(_Token.Keywords.Throw, _)), _ref3 => {
			let before = _ref3.before;
			let after = _ref3.after;
			return [before, (0, _parse.parseExpr)(after)];
		}, () => [tokens, null]);

		var _ifElse32 = _slicedToArray(_ifElse3, 2);

		const condTokens = _ifElse32[0];
		const opThrown = _ifElse32[1];

		const parts = (0, _parse.parseExprParts)(condTokens);
		const cond = parts.length === 1 ? parts[0] : new _MsAst.Call(condTokens.loc, parts[0], (0, _util.tail)(parts));
		return new _MsAst.Assert(tokens.loc, negate, cond, opThrown);
	}
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhcnNlTGluZS5qcyIsInByaXZhdGUvcGFyc2UvcGFyc2VMaW5lLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7bUJDbUJ3QixTQUFTOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBbEIsVUFBUyxTQUFTLENBQUMsTUFBTSxFQUFFO0FBQ3pDLFFBQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQTtBQUMxQixRQUFNLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUE7O0FBRTFCLFFBQU0sTUFBTSxHQUFHLE1BQ2QsWUFqQk0sVUFBVSxFQWlCTCxJQUFJLEVBQUUsTUFBTSxDQUFDLDhCQUE4QixHQUFFLElBQUksRUFBQyxDQUFDLENBQUMsQ0FBQyxDQUFBOzs7QUFHakUsTUFBSSxJQUFJLG1CQXRCeUMsT0FBTyxBQXNCN0IsRUFDMUIsUUFBUSxJQUFJLENBQUMsSUFBSTtBQUNoQixRQUFLLE9BeEJnRSxRQUFRLENBd0IvRCxNQUFNLENBQUMsQUFBQyxLQUFLLE9BeEIwQyxRQUFRLENBd0J6QyxTQUFTO0FBQzVDLFdBQU8sV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssT0F6Qm1DLFFBQVEsQ0F5QmxDLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQTtBQUFBLEFBQzNELFFBQUssT0ExQmdFLFFBQVEsQ0EwQi9ELFFBQVE7QUFDckIsV0FBTywyQkFBWSxPQTNCaUQsUUFBUSxDQTJCaEQsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFBO0FBQUEsQUFDNUMsUUFBSyxPQTVCZ0UsUUFBUSxDQTRCL0QsS0FBSztBQUNsQixVQUFNLEVBQUUsQ0FBQTtBQUNSLFdBQU8sV0FsQzhELEtBQUssQ0FrQ3pELE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQTtBQUFBLEFBQzdCLFFBQUssT0EvQmdFLFFBQVEsQ0ErQi9ELFlBQVk7QUFDekIsV0FBTyxXQXBDcUUsWUFBWSxDQW9DaEUsTUFBTSxDQUFDLEdBQUcsRUFBRSxXQXRCaEMs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QyxDQUFDLENBQUMsQ0FBQTs7aUJBR3ZGLFVBdk5NLE1BQU0sRUF1TkwsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDLElBQUksV0F4Tk0sU0FBUyxFQXdOTCxPQXhONkIsUUFBUSxDQXdONUIsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQzNELEFBQUMsS0FBZTtPQUFkLE1BQU0sR0FBUCxLQUFlLENBQWQsTUFBTTtPQUFFLEtBQUssR0FBZCxLQUFlLENBQU4sS0FBSztVQUFNLENBQUMsTUFBTSxFQUFFLFdBL016QixTQUFTLEVBK00wQixLQUFLLENBQUMsQ0FBQztHQUFBLEVBQy9DLE1BQU0sQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7Ozs7UUFIaEIsVUFBVTtRQUFFLFFBQVE7O0FBSzNCLFFBQU0sS0FBSyxHQUFHLFdBbE5JLGNBQWMsRUFrTkgsVUFBVSxDQUFDLENBQUE7QUFDeEMsUUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLFdBak9nRCxJQUFJLENBaU8zQyxVQUFVLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxVQTVObEQsSUFBSSxFQTRObUQsS0FBSyxDQUFDLENBQUMsQ0FBQTtBQUM1RixTQUFPLFdBbE9BLE1BQU0sQ0FrT0ssTUFBTSxDQUFDLEdBQUcsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFBO0VBQ3JEIiwiZmlsZSI6InByaXZhdGUvcGFyc2UvcGFyc2VMaW5lLmpzIiwic291cmNlc0NvbnRlbnQiOltudWxsLCJpbXBvcnQge2NoZWNrfSBmcm9tICcuLi9jb250ZXh0J1xuaW1wb3J0IHtBc3NlcnQsIEFzc2lnblNpbmdsZSwgQXNzaWduRGVzdHJ1Y3R1cmUsIEJhZ0VudHJ5LCBCYWdFbnRyeU1hbnksIEJyZWFrLCBCcmVha1dpdGhWYWwsIENhbGwsXG5cdENvbmRpdGlvbmFsRG8sIElnbm9yZSwgTG9jYWxBY2Nlc3MsIExvY2FsRGVjbGFyZXMsIExvY2FsTXV0YXRlLCBNYXBFbnRyeSwgTWVtYmVyU2V0LFxuXHRPYmpFbnRyeUFzc2lnbiwgT2JqRW50cnlDb21wdXRlZCwgT2JqRW50cnlQbGFpbiwgU2V0U3ViLCBTZXR0ZXJzLCBTcGVjaWFsRG8sIFNwZWNpYWxEb3MsXG5cdFNwZWNpYWxWYWwsIFNwZWNpYWxWYWxzLCBTdXBlckNhbGxEbywgVGhyb3csIFlpZWxkLCBZaWVsZFRvfSBmcm9tICcuLi9Nc0FzdCdcbmltcG9ydCB7R3JvdXBzLCBpc0dyb3VwLCBpc0FueUtleXdvcmQsIGlzS2V5d29yZCwgS2V5d29yZCwga2V5d29yZE5hbWUsIEtleXdvcmRzfSBmcm9tICcuLi9Ub2tlbidcbmltcG9ydCB7aWZFbHNlLCBpc0VtcHR5LCBvcElmLCB0YWlsfSBmcm9tICcuLi91dGlsJ1xuaW1wb3J0IHtjaGVja0VtcHR5LCBjaGVja05vbkVtcHR5LCB1bmV4cGVjdGVkfSBmcm9tICcuL2NoZWNrcydcbmltcG9ydCB7YmVmb3JlQW5kQmxvY2ssIHBhcnNlQmxvY2tEbywgcGFyc2VMaW5lc0Zyb21CbG9ja30gZnJvbSAnLi9wYXJzZUJsb2NrJ1xuaW1wb3J0IHBhcnNlQ2FzZSBmcm9tICcuL3BhcnNlQ2FzZSdcbmltcG9ydCBwYXJzZUV4Y2VwdCBmcm9tICcuL3BhcnNlRXhjZXB0J1xuaW1wb3J0IHtwYXJzZUZvckRvfSBmcm9tICcuL3BhcnNlRm9yJ1xuaW1wb3J0IHBhcnNlTG9jYWxEZWNsYXJlcywge3BhcnNlTG9jYWxEZWNsYXJlc0p1c3ROYW1lcywgcGFyc2VMb2NhbE5hbWV9IGZyb20gJy4vcGFyc2VMb2NhbERlY2xhcmVzJ1xuaW1wb3J0IHBhcnNlTWVtYmVyTmFtZSBmcm9tICcuL3BhcnNlTWVtYmVyTmFtZSdcbmltcG9ydCBwYXJzZVF1b3RlIGZyb20gJy4vcGFyc2VRdW90ZSdcbmltcG9ydCB7cGFyc2VFeHByLCBwYXJzZUV4cHJQYXJ0cywgcGFyc2VTcGFjZWQsIHBhcnNlU3dpdGNofSBmcm9tICcuL3BhcnNlKidcbmltcG9ydCBTbGljZSBmcm9tICcuL1NsaWNlJ1xuXG4vKiogUGFyc2UgdGhlIGNvbnRlbnQgb2YgYSBsaW5lLiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGFyc2VMaW5lKHRva2Vucykge1xuXHRjb25zdCBoZWFkID0gdG9rZW5zLmhlYWQoKVxuXHRjb25zdCByZXN0ID0gdG9rZW5zLnRhaWwoKVxuXG5cdGNvbnN0IG5vUmVzdCA9ICgpID0+XG5cdFx0Y2hlY2tFbXB0eShyZXN0LCAoKSA9PiBgRGlkIG5vdCBleHBlY3QgYW55dGhpbmcgYWZ0ZXIgJHtoZWFkfS5gKVxuXG5cdC8vIFdlIG9ubHkgZGVhbCB3aXRoIG11dGFibGUgZXhwcmVzc2lvbnMgaGVyZSwgb3RoZXJ3aXNlIHdlIGZhbGwgYmFjayB0byBwYXJzZUV4cHIuXG5cdGlmIChoZWFkIGluc3RhbmNlb2YgS2V5d29yZClcblx0XHRzd2l0Y2ggKGhlYWQua2luZCkge1xuXHRcdFx0Y2FzZSBLZXl3b3Jkcy5Bc3NlcnQ6IGNhc2UgS2V5d29yZHMuQXNzZXJ0Tm90OlxuXHRcdFx0XHRyZXR1cm4gcGFyc2VBc3NlcnQoaGVhZC5raW5kID09PSBLZXl3b3Jkcy5Bc3NlcnROb3QsIHJlc3QpXG5cdFx0XHRjYXNlIEtleXdvcmRzLkV4Y2VwdERvOlxuXHRcdFx0XHRyZXR1cm4gcGFyc2VFeGNlcHQoS2V5d29yZHMuRXhjZXB0RG8sIHJlc3QpXG5cdFx0XHRjYXNlIEtleXdvcmRzLkJyZWFrOlxuXHRcdFx0XHRub1Jlc3QoKVxuXHRcdFx0XHRyZXR1cm4gbmV3IEJyZWFrKHRva2Vucy5sb2MpXG5cdFx0XHRjYXNlIEtleXdvcmRzLkJyZWFrV2l0aFZhbDpcblx0XHRcdFx0cmV0dXJuIG5ldyBCcmVha1dpdGhWYWwodG9rZW5zLmxvYywgcGFyc2VFeHByKHJlc3QpKVxuXHRcdFx0Y2FzZSBLZXl3b3Jkcy5DYXNlRG86XG5cdFx0XHRcdHJldHVybiBwYXJzZUNhc2UoZmFsc2UsIGZhbHNlLCByZXN0KVxuXHRcdFx0Y2FzZSBLZXl3b3Jkcy5EZWJ1Z2dlcjpcblx0XHRcdFx0bm9SZXN0KClcblx0XHRcdFx0cmV0dXJuIG5ldyBTcGVjaWFsRG8odG9rZW5zLmxvYywgU3BlY2lhbERvcy5EZWJ1Z2dlcilcblx0XHRcdGNhc2UgS2V5d29yZHMuRWxsaXBzaXM6XG5cdFx0XHRcdHJldHVybiBuZXcgQmFnRW50cnlNYW55KHRva2Vucy5sb2MsIHBhcnNlRXhwcihyZXN0KSlcblx0XHRcdGNhc2UgS2V5d29yZHMuRm9yRG86XG5cdFx0XHRcdHJldHVybiBwYXJzZUZvckRvKHJlc3QpXG5cdFx0XHRjYXNlIEtleXdvcmRzLklnbm9yZTpcblx0XHRcdFx0cmV0dXJuIG5ldyBJZ25vcmUodG9rZW5zLmxvYywgcmVzdC5tYXAocGFyc2VMb2NhbE5hbWUpKVxuXHRcdFx0Y2FzZSBLZXl3b3Jkcy5JZkRvOiBjYXNlIEtleXdvcmRzLlVubGVzc0RvOiB7XG5cdFx0XHRcdGNvbnN0IFtiZWZvcmUsIGJsb2NrXSA9IGJlZm9yZUFuZEJsb2NrKHJlc3QpXG5cdFx0XHRcdHJldHVybiBuZXcgQ29uZGl0aW9uYWxEbyh0b2tlbnMubG9jLFxuXHRcdFx0XHRcdHBhcnNlRXhwcihiZWZvcmUpLFxuXHRcdFx0XHRcdHBhcnNlQmxvY2tEbyhibG9jayksXG5cdFx0XHRcdFx0aGVhZC5raW5kID09PSBLZXl3b3Jkcy5Vbmxlc3NEbylcblx0XHRcdH1cblx0XHRcdGNhc2UgS2V5d29yZHMuT2JqQXNzaWduOlxuXHRcdFx0XHRyZXR1cm4gbmV3IEJhZ0VudHJ5KHRva2Vucy5sb2MsIHBhcnNlRXhwcihyZXN0KSlcblx0XHRcdGNhc2UgS2V5d29yZHMuUGFzczpcblx0XHRcdFx0bm9SZXN0KClcblx0XHRcdFx0cmV0dXJuIFtdXG5cdFx0XHRjYXNlIEtleXdvcmRzLlJlZ2lvbjpcblx0XHRcdFx0cmV0dXJuIHBhcnNlTGluZXNGcm9tQmxvY2sodG9rZW5zKVxuXHRcdFx0Y2FzZSBLZXl3b3Jkcy5TdXBlckRvOlxuXHRcdFx0XHRyZXR1cm4gbmV3IFN1cGVyQ2FsbERvKHRva2Vucy5sb2MsIHBhcnNlRXhwclBhcnRzKHJlc3QpKVxuXHRcdFx0Y2FzZSBLZXl3b3Jkcy5Td2l0Y2hEbzpcblx0XHRcdFx0cmV0dXJuIHBhcnNlU3dpdGNoKGZhbHNlLCBmYWxzZSwgcmVzdClcblx0XHRcdGNhc2UgS2V5d29yZHMuVGhyb3c6XG5cdFx0XHRcdHJldHVybiBuZXcgVGhyb3codG9rZW5zLmxvYywgb3BJZighcmVzdC5pc0VtcHR5KCksICgpID0+IHBhcnNlRXhwcihyZXN0KSkpXG5cdFx0XHRjYXNlIEtleXdvcmRzLk5hbWU6XG5cdFx0XHRcdGlmIChpc0tleXdvcmQoS2V5d29yZHMuT2JqQXNzaWduLCByZXN0LmhlYWQoKSkpIHtcblx0XHRcdFx0XHRjb25zdCByID0gcmVzdC50YWlsKClcblx0XHRcdFx0XHRjb25zdCB2YWwgPSByLmlzRW1wdHkoKSA/XG5cdFx0XHRcdFx0XHRuZXcgU3BlY2lhbFZhbCh0b2tlbnMubG9jLCBTcGVjaWFsVmFscy5OYW1lKSA6XG5cdFx0XHRcdFx0XHRwYXJzZUV4cHIocilcblx0XHRcdFx0XHRyZXR1cm4gT2JqRW50cnlQbGFpbi5uYW1lKHRva2Vucy5sb2MsIHZhbClcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBlbHNlIGZhbGwgdGhyb3VnaFxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0Ly8gZmFsbCB0aHJvdWdoXG5cdFx0fVxuXG5cdHJldHVybiBpZkVsc2UodG9rZW5zLm9wU3BsaXRPbmNlKF8gPT4gaXNBbnlLZXl3b3JkKGxpbmVTcGxpdEtleXdvcmRzLCBfKSksXG5cdFx0KHtiZWZvcmUsIGF0LCBhZnRlcn0pID0+IHBhcnNlQXNzaWduTGlrZShiZWZvcmUsIGF0LCBhZnRlciwgdG9rZW5zLmxvYyksXG5cdFx0KCkgPT4gcGFyc2VFeHByKHRva2VucykpXG59XG5cbmV4cG9ydCBjb25zdCBwYXJzZUxpbmVPckxpbmVzID0gdG9rZW5zID0+IHtcblx0Y29uc3QgXyA9IHBhcnNlTGluZSh0b2tlbnMpXG5cdHJldHVybiBfIGluc3RhbmNlb2YgQXJyYXkgPyBfIDogW19dXG59XG5cbmNvbnN0IGxpbmVTcGxpdEtleXdvcmRzID0gbmV3IFNldChbXG5cdEtleXdvcmRzLkFzc2lnbiwgS2V5d29yZHMuQXNzaWduTXV0YWJsZSwgS2V5d29yZHMuTG9jYWxNdXRhdGUsIEtleXdvcmRzLk1hcEVudHJ5LFxuXHRLZXl3b3Jkcy5PYmpBc3NpZ24sIEtleXdvcmRzLllpZWxkLCBLZXl3b3Jkcy5ZaWVsZFRvXG5dKVxuXG5mdW5jdGlvbiBwYXJzZUFzc2lnbkxpa2UoYmVmb3JlLCBhdCwgYWZ0ZXIsIGxvYykge1xuXHRjb25zdCBraW5kID0gYXQua2luZFxuXHRpZiAoa2luZCA9PT0gS2V5d29yZHMuTWFwRW50cnkpXG5cdFx0cmV0dXJuIG5ldyBNYXBFbnRyeShsb2MsIHBhcnNlRXhwcihiZWZvcmUpLCBwYXJzZUV4cHIoYWZ0ZXIpKVxuXG5cdGlmIChiZWZvcmUuc2l6ZSgpID09PSAxKSB7XG5cdFx0Y29uc3QgdG9rZW4gPSBiZWZvcmUuaGVhZCgpXG5cdFx0Ly8gYGEuYiA9IGNgLCBgLmIgPSBjYCwgYGEuXCJiXCIgPSBjYCwgYC5cImJcIiA9IGNgLCBgYVtiXSA9IGNgXG5cdFx0aWYgKGlzR3JvdXAoR3JvdXBzLlNwYWNlLCB0b2tlbikpIHtcblx0XHRcdGNvbnN0IHNwYWNlZCA9IFNsaWNlLmdyb3VwKHRva2VuKVxuXHRcdFx0Y29uc3QgW3ZhbHVlLCBvcFR5cGVdID0gaWZFbHNlKHNwYWNlZC5vcFNwbGl0T25jZShfID0+IGlzS2V5d29yZChLZXl3b3Jkcy5UeXBlLCBfKSksXG5cdFx0XHRcdCh7YmVmb3JlLCBhZnRlcn0pID0+IFtiZWZvcmUsIHBhcnNlRXhwcihhZnRlcildLFxuXHRcdFx0XHQoKSA9PiBbc3BhY2VkLCBudWxsXSlcblxuXHRcdFx0Y29uc3QgbGFzdCA9IHZhbHVlLmxhc3QoKVxuXHRcdFx0Y29uc3Qgb2JqZWN0ID0gb2JqID0+XG5cdFx0XHRcdG9iai5pc0VtcHR5KCkgPyBMb2NhbEFjY2Vzcy50aGlzKG9iai5sb2MpIDogcGFyc2VTcGFjZWQob2JqKVxuXG5cdFx0XHRpZiAoaXNLZXl3b3JkKEtleXdvcmRzLkRvdCwgdmFsdWUubmV4dFRvTGFzdCgpKSkge1xuXHRcdFx0XHRjb25zdCBuYW1lID0gcGFyc2VNZW1iZXJOYW1lKGxhc3QpXG5cdFx0XHRcdGNvbnN0IHNldCA9IG9iamVjdCh2YWx1ZS5ydGFpbCgpLnJ0YWlsKCkpXG5cdFx0XHRcdHJldHVybiBuZXcgTWVtYmVyU2V0KGxvYywgc2V0LCBuYW1lLCBvcFR5cGUsIHNldEtpbmQoYXQpLCBwYXJzZUV4cHIoYWZ0ZXIpKVxuXHRcdFx0fSBlbHNlIGlmIChpc0dyb3VwKEdyb3Vwcy5CcmFja2V0LCBsYXN0KSkge1xuXHRcdFx0XHRjb25zdCBzZXQgPSBvYmplY3QodmFsdWUucnRhaWwoKSlcblx0XHRcdFx0cmV0dXJuIHBhcnNlU3ViU2V0KHNldCwgU2xpY2UuZ3JvdXAobGFzdCksIG9wVHlwZSwgYXQsIGFmdGVyLCBsb2MpXG5cdFx0XHR9XG5cdFx0Ly8gYFwiMVwiLiAxYFxuXHRcdH0gZWxzZSBpZiAoaXNHcm91cChHcm91cHMuUXVvdGUsIHRva2VuKSAmJiBraW5kID09PSBLZXl3b3Jkcy5PYmpBc3NpZ24pXG5cdFx0XHRyZXR1cm4gbmV3IE9iakVudHJ5Q29tcHV0ZWQobG9jLCBwYXJzZVF1b3RlKFNsaWNlLmdyb3VwKHRva2VuKSksIHBhcnNlRXhwcihhZnRlcikpXG5cdH1cblxuXHRyZXR1cm4ga2luZCA9PT0gS2V5d29yZHMuTG9jYWxNdXRhdGUgP1xuXHRcdHBhcnNlTG9jYWxNdXRhdGUoYmVmb3JlLCBhZnRlciwgbG9jKSA6XG5cdFx0cGFyc2VBc3NpZ24oYmVmb3JlLCBraW5kLCBhZnRlciwgbG9jKVxufVxuXG5mdW5jdGlvbiBzZXRLaW5kKGtleXdvcmQpIHtcblx0c3dpdGNoIChrZXl3b3JkLmtpbmQpIHtcblx0XHRjYXNlIEtleXdvcmRzLkFzc2lnbjpcblx0XHRcdHJldHVybiBTZXR0ZXJzLkluaXRcblx0XHRjYXNlIEtleXdvcmRzLkFzc2lnbk11dGFibGU6XG5cdFx0XHRyZXR1cm4gU2V0dGVycy5Jbml0TXV0YWJsZVxuXHRcdGNhc2UgS2V5d29yZHMuTG9jYWxNdXRhdGU6XG5cdFx0XHRyZXR1cm4gU2V0dGVycy5NdXRhdGVcblx0XHRkZWZhdWx0OlxuXHRcdFx0dW5leHBlY3RlZChrZXl3b3JkKVxuXHR9XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3ViU2V0KG9iamVjdCwgc3ViYmVkLCBvcFR5cGUsIGF0LCBhZnRlciwgbG9jKSB7XG5cdGNvbnN0IHN1YmJlZHMgPSBwYXJzZUV4cHJQYXJ0cyhzdWJiZWQpXG5cdHJldHVybiBuZXcgU2V0U3ViKGxvYywgb2JqZWN0LCBzdWJiZWRzLCBvcFR5cGUsIHNldEtpbmQoYXQpLCBwYXJzZUV4cHIoYWZ0ZXIpKVxufVxuXG5mdW5jdGlvbiBwYXJzZUxvY2FsTXV0YXRlKGxvY2Fsc1Rva2VucywgdmFsdWVUb2tlbnMsIGxvYykge1xuXHRjb25zdCBsb2NhbHMgPSBwYXJzZUxvY2FsRGVjbGFyZXNKdXN0TmFtZXMobG9jYWxzVG9rZW5zKVxuXHRjaGVjayhsb2NhbHMubGVuZ3RoID09PSAxLCBsb2MsICdUT0RPOiBMb2NhbERlc3RydWN0dXJlTXV0YXRlJylcblx0Y29uc3QgbmFtZSA9IGxvY2Fsc1swXS5uYW1lXG5cdGNvbnN0IHZhbHVlID0gcGFyc2VFeHByKHZhbHVlVG9rZW5zKVxuXHRyZXR1cm4gbmV3IExvY2FsTXV0YXRlKGxvYywgbmFtZSwgdmFsdWUpXG59XG5cbmZ1bmN0aW9uIHBhcnNlQXNzaWduKGxvY2Fsc1Rva2Vucywga2luZCwgdmFsdWVUb2tlbnMsIGxvYykge1xuXHRjb25zdCBsb2NhbHMgPSBwYXJzZUxvY2FsRGVjbGFyZXMobG9jYWxzVG9rZW5zKVxuXG5cdC8vIEhhbmRsZSBgYS5gIHdoaWNoIG1vdmVzIGFuIG91dGVyIGxvY2FsIGludG8gYW4gT2JqRW50cnkuXG5cdGlmIChraW5kID09PSBLZXl3b3Jkcy5PYmpBc3NpZ24gJiYgdmFsdWVUb2tlbnMuaXNFbXB0eSgpICYmIGxvY2Fscy5sZW5ndGggPT09IDEpIHtcblx0XHRjb25zdCBsb2NhbCA9IGxvY2Fsc1swXVxuXHRcdGNoZWNrKGxvY2FsLm9wVHlwZSA9PT0gbnVsbCwgbG9jYWwubG9jLCAoKSA9PlxuXHRcdFx0YFR5cGUgZGVjbGFyYXRpb24gc2hvdWxkIGdvIHdpdGggaW5pdGlhbCBkZWNsYXJhdGlvbiBvZiAke2xvY2FsLm5hbWV9LmApXG5cdFx0cmV0dXJuIE9iakVudHJ5UGxhaW4uYWNjZXNzKGxvYywgbG9jYWwubmFtZSlcblx0fVxuXG5cdGNvbnN0IHZhbHVlID0gcGFyc2VBc3NpZ25WYWx1ZShraW5kLCB2YWx1ZVRva2VucylcblxuXHRjb25zdCBpc1lpZWxkID0ga2luZCA9PT0gS2V5d29yZHMuWWllbGQgfHwga2luZCA9PT0gS2V5d29yZHMuWWllbGRUb1xuXHRpZiAoaXNFbXB0eShsb2NhbHMpKSB7XG5cdFx0Y2hlY2soaXNZaWVsZCwgbG9jYWxzVG9rZW5zLmxvYywgJ0Fzc2lnbm1lbnQgdG8gbm90aGluZycpXG5cdFx0cmV0dXJuIHZhbHVlXG5cdH0gZWxzZSB7XG5cdFx0aWYgKGlzWWllbGQpXG5cdFx0XHRmb3IgKGNvbnN0IF8gb2YgbG9jYWxzKVxuXHRcdFx0XHRjaGVjayghXy5pc0xhenkoKSwgXy5sb2MsICdDYW4gbm90IHlpZWxkIHRvIGxhenkgdmFyaWFibGUuJylcblxuXHRcdGNvbnN0IGlzT2JqQXNzaWduID0ga2luZCA9PT0gS2V5d29yZHMuT2JqQXNzaWduXG5cblx0XHRpZiAoa2luZCA9PT0gS2V5d29yZHMuQXNzaWduTXV0YWJsZSlcblx0XHRcdGZvciAobGV0IF8gb2YgbG9jYWxzKSB7XG5cdFx0XHRcdGNoZWNrKCFfLmlzTGF6eSgpLCBfLmxvYywgJ0xhenkgbG9jYWwgY2FuIG5vdCBiZSBtdXRhYmxlLicpXG5cdFx0XHRcdF8ua2luZCA9IExvY2FsRGVjbGFyZXMuTXV0YWJsZVxuXHRcdFx0fVxuXG5cdFx0Y29uc3Qgd3JhcCA9IF8gPT4gaXNPYmpBc3NpZ24gPyBuZXcgT2JqRW50cnlBc3NpZ24obG9jLCBfKSA6IF9cblxuXHRcdGlmIChsb2NhbHMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRjb25zdCBhc3NpZ25lZSA9IGxvY2Fsc1swXVxuXHRcdFx0Y29uc3QgYXNzaWduID0gbmV3IEFzc2lnblNpbmdsZShsb2MsIGFzc2lnbmVlLCB2YWx1ZSlcblx0XHRcdHJldHVybiB3cmFwKGFzc2lnbilcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3Qga2luZCA9IGxvY2Fsc1swXS5raW5kXG5cdFx0XHRmb3IgKGNvbnN0IF8gb2YgbG9jYWxzKVxuXHRcdFx0XHRjaGVjayhfLmtpbmQgPT09IGtpbmQsIF8ubG9jLFxuXHRcdFx0XHRcdCdBbGwgbG9jYWxzIG9mIGRlc3RydWN0dXJpbmcgYXNzaWdubWVudCBtdXN0IGJlIG9mIHRoZSBzYW1lIGtpbmQuJylcblx0XHRcdHJldHVybiB3cmFwKG5ldyBBc3NpZ25EZXN0cnVjdHVyZShsb2MsIGxvY2FscywgdmFsdWUsIGtpbmQpKVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBwYXJzZUFzc2lnblZhbHVlKGtpbmQsIHZhbHVlVG9rZW5zKSB7XG5cdGNvbnN0IHZhbHVlID0gcGFyc2VFeHByKHZhbHVlVG9rZW5zKVxuXHRzd2l0Y2ggKGtpbmQpIHtcblx0XHRjYXNlIEtleXdvcmRzLllpZWxkOlxuXHRcdFx0cmV0dXJuIG5ldyBZaWVsZCh2YWx1ZS5sb2MsIHZhbHVlKVxuXHRcdGNhc2UgS2V5d29yZHMuWWllbGRUbzpcblx0XHRcdHJldHVybiBuZXcgWWllbGRUbyh2YWx1ZS5sb2MsIHZhbHVlKVxuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gdmFsdWVcblx0fVxufVxuXG5mdW5jdGlvbiBwYXJzZUFzc2VydChuZWdhdGUsIHRva2Vucykge1xuXHRjaGVja05vbkVtcHR5KHRva2VucywgKCkgPT4gYEV4cGVjdGVkIHNvbWV0aGluZyBhZnRlciAke2tleXdvcmROYW1lKEtleXdvcmRzLkFzc2VydCl9LmApXG5cblx0Y29uc3QgW2NvbmRUb2tlbnMsIG9wVGhyb3duXSA9XG5cdFx0aWZFbHNlKHRva2Vucy5vcFNwbGl0T25jZShfID0+IGlzS2V5d29yZChLZXl3b3Jkcy5UaHJvdywgXykpLFxuXHRcdFx0KHtiZWZvcmUsIGFmdGVyfSkgPT4gW2JlZm9yZSwgcGFyc2VFeHByKGFmdGVyKV0sXG5cdFx0XHQoKSA9PiBbdG9rZW5zLCBudWxsXSlcblxuXHRjb25zdCBwYXJ0cyA9IHBhcnNlRXhwclBhcnRzKGNvbmRUb2tlbnMpXG5cdGNvbnN0IGNvbmQgPSBwYXJ0cy5sZW5ndGggPT09IDEgPyBwYXJ0c1swXSA6IG5ldyBDYWxsKGNvbmRUb2tlbnMubG9jLCBwYXJ0c1swXSwgdGFpbChwYXJ0cykpXG5cdHJldHVybiBuZXcgQXNzZXJ0KHRva2Vucy5sb2MsIG5lZ2F0ZSwgY29uZCwgb3BUaHJvd24pXG59XG4iXSwic291cmNlUm9vdCI6Ii9zcmMifQ==
