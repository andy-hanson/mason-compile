{"version":3,"sources":["private/verify/verify.js","private/verify/verify.ts"],"names":[],"mappings":"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","file":"private/verify/verify.js","sourcesContent":["(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", 'op/Op', '../context', '../MsAst', '../MsAst', '../util', './context', './locals', './SK', './util', './verifyBlock'], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    var Op_1 = require('op/Op');\n    var context_1 = require('../context');\n    var MsAstTypes = require('../MsAst');\n    var MsAst_1 = require('../MsAst');\n    var util_1 = require('../util');\n    var context_2 = require('./context');\n    var locals_1 = require('./locals');\n    var SK_1 = require('./SK');\n    var util_2 = require('./util');\n    var verifyBlock_1 = require('./verifyBlock');\n    function verify(module) {\n        context_2.setup();\n        module.verify();\n        locals_1.warnUnusedLocals();\n        const res = context_2.results;\n        context_2.tearDown();\n        return res;\n    }\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = verify;\n    function verifyOpVal(_) {\n        if (Op_1.nonNull(_))\n            _.verify(1);\n    }\n    function verifyOpDo(_) {\n        if (Op_1.nonNull(_))\n            _.verify(0);\n    }\n    function verifyEachVal(vals) {\n        for (const _ of vals)\n            _.verify(1);\n    }\n    util_1.implementMany(MsAstTypes, 'verify', {\n        Assert(sk) {\n            SK_1.checkDo(this, sk);\n            this.condition.verify(1);\n            verifyOpVal(this.opThrown);\n        },\n        AssignSingle(sk) {\n            SK_1.checkDo(this, sk);\n            context_2.withName(this.assignee.name, () => {\n                const doV = () => {\n                    if (this.value instanceof MsAst_1.Class ||\n                        this.value instanceof MsAst_1.Fun ||\n                        this.value instanceof MsAst_1.Method ||\n                        this.value instanceof MsAst_1.Trait)\n                        util_2.setName(this.value);\n                    this.assignee.verify();\n                    this.value.verify(1);\n                };\n                if (this.assignee.isLazy)\n                    locals_1.withBlockLocals(doV);\n                else\n                    doV();\n            });\n        },\n        AssignDestructure(sk) {\n            SK_1.checkDo(this, sk);\n            for (const _ of this.assignees)\n                _.verify();\n            this.value.verify(1);\n        },\n        Await(_sk) {\n            context_1.check(context_2.funKind === 1, this.loc, _ => _.misplacedAwait);\n            this.value.verify(1);\n        },\n        BagEntry(sk) {\n            SK_1.checkDo(this, sk);\n            locals_1.accessLocal(this, 'built');\n            this.value.verify(1);\n        },\n        BagSimple(sk) {\n            SK_1.checkVal(this, sk);\n            util_2.verifyEachValOrSpread(this.parts);\n        },\n        Block: verifyBlock_1.default,\n        BlockWrap(sk) {\n            SK_1.checkVal(this, sk);\n            context_2.withIife(() => this.block.verify(sk));\n        },\n        Break(sk) {\n            SK_1.checkDo(this, sk);\n            verifyOpVal(this.opValue);\n            const loop = Op_1.orThrow(context_2.opLoop, () => context_1.fail(this.loc, _ => _.misplacedBreak));\n            if (loop instanceof MsAst_1.For)\n                if (context_2.results.isStatement(loop))\n                    context_1.check(this.opValue === null, this.loc, _ => _.breakCantHaveValue);\n                else\n                    context_1.check(this.opValue !== null, this.loc, _ => _.breakNeedsValue);\n            else {\n                util_1.assert(loop instanceof MsAst_1.ForBag);\n                context_1.check(this.opValue === null, this.loc, _ => _.breakValInForBag);\n            }\n            if (context_2.isInSwitch) {\n                context_2.results.loopsNeedingLabel.add(loop);\n                context_2.results.breaksInSwitch.add(this);\n            }\n        },\n        Call(_sk) {\n            this.called.verify(1);\n            util_2.verifyEachValOrSpread(this.args);\n        },\n        Case(sk) {\n            SK_1.markStatement(this, sk);\n            context_2.withIifeIfVal(sk, () => {\n                const doIt = () => {\n                    util_2.verifyEach(this.parts, sk);\n                    util_2.verifyOp(this.opElse, sk);\n                };\n                Op_1.caseOp(this.opCased, _ => {\n                    _.verify(0);\n                    locals_1.verifyAndPlusLocal(_.assignee, doIt);\n                }, doIt);\n            });\n        },\n        CasePart(sk) {\n            if (this.test instanceof MsAst_1.Pattern) {\n                this.test.type.verify(1);\n                this.test.patterned.verify(1);\n                locals_1.verifyAndPlusLocals(this.test.locals, () => this.result.verify(sk));\n            }\n            else {\n                this.test.verify(1);\n                this.result.verify(sk);\n            }\n        },\n        Catch(sk) {\n            util_2.makeUseOptionalIfFocus(this.caught);\n            util_2.verifyNotLazy(this.caught, _ => _.noLazyCatch);\n            locals_1.verifyAndPlusLocal(this.caught, () => {\n                this.block.verify(sk);\n            });\n        },\n        Class(sk) {\n            SK_1.checkVal(this, sk);\n            Op_1.opEach(this.opFields, fields => {\n                for (const _ of fields)\n                    _.verify();\n            });\n            verifyOpVal(this.opSuperClass);\n            verifyEachVal(this.traits);\n            context_2.withIife(() => {\n                Op_1.opEach(this.opDo, _ => _.verify());\n            });\n            context_2.withMethods(() => {\n                for (const _ of this.statics)\n                    _.verify();\n                Op_1.opEach(this.opConstructor, _ => _.verify(this.opSuperClass !== null));\n                for (const _ of this.methods)\n                    _.verify();\n            });\n        },\n        ClassTraitDo() {\n            locals_1.verifyAndPlusLocal(this.declareFocus, () => this.block.verify(0));\n        },\n        Cond(sk) {\n            this.test.verify(1);\n            this.ifTrue.verify(sk);\n            this.ifFalse.verify(sk);\n        },\n        Conditional(sk) {\n            SK_1.markStatement(this, sk);\n            this.test.verify(1);\n            context_2.withIifeIf(this.result instanceof MsAst_1.Block && sk === 1, () => {\n                this.result.verify(sk);\n            });\n        },\n        Constructor(classHasSuper) {\n            util_2.makeUseOptional(this.fun.opDeclareThis);\n            context_2.withMethod(this, () => {\n                this.fun.verify(1);\n            });\n            const superCall = context_2.results.constructorToSuper.get(this);\n            if (classHasSuper)\n                context_1.check(superCall !== undefined, this.loc, _ => _.superNeeded);\n            else\n                context_1.check(superCall === undefined, () => superCall.loc, _ => _.superForbidden);\n            for (const _ of this.memberArgs)\n                locals_1.setDeclareAccessed(_, this);\n        },\n        Del(_sk) {\n            this.subbed.verify(1);\n            verifyEachVal(this.args);\n        },\n        Except(sk) {\n            SK_1.markStatement(this, sk);\n            if (this.opElse === null)\n                this.try.verify(sk);\n            else {\n                locals_1.plusLocals(verifyBlock_1.verifyDoBlock(this.try), () => this.opElse.verify(sk));\n                if (util_1.isEmpty(this.allCatches))\n                    context_1.warn(this.loc, _ => _.elseRequiresCatch);\n            }\n            if (util_1.isEmpty(this.allCatches) && this.opFinally === null)\n                context_1.warn(this.loc, _ => _.uselessExcept);\n            util_2.verifyEach(this.typedCatches, sk);\n            util_2.verifyOp(this.opCatchAll, sk);\n            verifyOpDo(this.opFinally);\n        },\n        Field() {\n            verifyOpVal(this.opType);\n        },\n        For(sk) {\n            SK_1.markStatement(this, sk);\n            verifyFor(this);\n        },\n        ForAsync(sk) {\n            SK_1.markStatement(this, sk);\n            context_1.check(sk !== 0 || context_2.funKind === 1, this.loc, _ => _.forAsyncNeedsAsync);\n            withVerifyIteratee(this.iteratee, () => {\n                context_2.withFun(1, () => {\n                    this.block.verify(SK_1.getSK(this.block));\n                });\n            });\n        },\n        ForBag(sk) {\n            SK_1.checkVal(this, sk);\n            locals_1.verifyAndPlusLocal(this.built, () => verifyFor(this));\n        },\n        Fun(sk) {\n            SK_1.checkVal(this, sk);\n            context_1.check(this.opReturnType === null || !this.isDo, this.loc, _ => _.doFuncCantHaveType);\n            verifyOpVal(this.opReturnType);\n            const args = util_1.cat(this.opDeclareThis, this.args, this.opRestArg);\n            context_2.withFun(this.kind, () => {\n                locals_1.verifyAndPlusLocals(args, () => {\n                    this.block.verify(this.isDo ? 0 : 1);\n                });\n            });\n        },\n        FunAbstract() {\n            for (const _ of this.args)\n                _.verify();\n            Op_1.opEach(this.opRestArg, _ => _.verify());\n            Op_1.opEach(this.opReturnType, _ => _.verify());\n        },\n        GetterFun(sk) {\n            SK_1.checkVal(this, sk);\n            util_2.verifyName(this.name);\n        },\n        Ignore(sk) {\n            SK_1.checkDo(this, sk);\n            for (const _ of this.ignoredNames)\n                locals_1.accessLocal(this, _);\n        },\n        Import() {\n            function addUseLocal(ld) {\n                const prev = context_2.locals.get(ld.name);\n                context_1.check(prev === undefined, ld.loc, _ => _.duplicateImport(ld.name, prev.loc));\n                locals_1.verifyLocalDeclare(ld);\n                locals_1.setLocal(ld);\n            }\n            for (const _ of this.imported)\n                addUseLocal(_);\n            Op_1.opEach(this.opImportDefault, addUseLocal);\n        },\n        InstanceOf(sk) {\n            SK_1.checkVal(this, sk);\n            this.instance.verify(1);\n            this.type.verify(1);\n        },\n        Lazy(sk) {\n            SK_1.checkVal(this, sk);\n            locals_1.withBlockLocals(() => this.value.verify(1));\n        },\n        LocalAccess(sk) {\n            SK_1.checkVal(this, sk);\n            const declare = context_2.locals.get(this.name);\n            if (declare === undefined) {\n                const builtinPath = Op_1.orThrow(context_1.options.opBuiltinPath(this.name), () => locals_1.missingLocalFail(this.loc, this.name));\n                context_2.results.accessBuiltin(this.name, builtinPath);\n            }\n            else {\n                context_2.results.localAccessToDeclare.set(this, declare);\n                locals_1.setDeclareAccessed(declare, this);\n            }\n        },\n        LocalDeclare() {\n            Op_1.opEach(context_1.options.opBuiltinPath(this.name), path => {\n                context_1.warn(this.loc, _ => _.overriddenBuiltin(this.name, path));\n            });\n            Op_1.opEach(this.opType, _ => _.verify());\n        },\n        LocalMutate(sk) {\n            SK_1.checkDo(this, sk);\n            this.value.verify(1);\n        },\n        Logic(sk) {\n            SK_1.checkVal(this, sk);\n            context_1.check(this.args.length > 1, this.loc, _ => _.argsLogic);\n            verifyEachVal(this.args);\n        },\n        Not(sk) {\n            SK_1.checkVal(this, sk);\n            this.arg.verify(1);\n        },\n        NumberLiteral(sk) {\n            SK_1.checkVal(this, sk);\n        },\n        MapEntry(sk) {\n            SK_1.checkDo(this, sk);\n            locals_1.accessLocal(this, 'built');\n            this.key.verify(1);\n            this.val.verify(1);\n        },\n        Member(sk) {\n            SK_1.checkVal(this, sk);\n            this.object.verify(1);\n            util_2.verifyName(this.name);\n        },\n        MemberFun(sk) {\n            SK_1.checkVal(this, sk);\n            verifyOpVal(this.opObject);\n            util_2.verifyName(this.name);\n        },\n        MemberSet(sk) {\n            SK_1.checkDo(this, sk);\n            this.object.verify(1);\n            util_2.verifyName(this.name);\n            verifyOpVal(this.opType);\n            this.value.verify(1);\n        },\n        Method(sk) {\n            SK_1.checkVal(this, sk);\n            util_2.makeUseOptional(this.fun.opDeclareThis);\n            this.fun.args.forEach(util_2.makeUseOptional);\n            Op_1.opEach(this.fun.opRestArg, util_2.makeUseOptional);\n            this.fun.verify(1);\n        },\n        MethodImpl() {\n            verifyMethodImpl(this, () => {\n                util_2.makeUseOptional(this.fun.opDeclareThis);\n                this.fun.verify(1);\n            });\n        },\n        MethodGetter() {\n            verifyMethodImpl(this, () => {\n                util_2.makeUseOptional(this.declareThis);\n                locals_1.verifyAndPlusLocals([this.declareThis], () => {\n                    this.block.verify(1);\n                });\n            });\n        },\n        MethodSetter() {\n            verifyMethodImpl(this, () => {\n                locals_1.verifyAndPlusLocals([this.declareThis, this.declareFocus], () => {\n                    this.block.verify(0);\n                });\n            });\n        },\n        Module() {\n            for (const _ of this.imports)\n                _.verify();\n            context_2.withName(context_1.pathOptions.moduleName, () => {\n                verifyBlock_1.verifyModuleLines(this.lines, this.loc);\n            });\n        },\n        MsRegExp(sk) {\n            SK_1.checkVal(this, sk);\n            this.parts.forEach(util_2.verifyName);\n            if (this.parts.length === 1 && typeof this.parts[0] === 'string')\n                try {\n                    new RegExp(this.parts[0]);\n                }\n                catch (err) {\n                    if (!(err instanceof SyntaxError))\n                        throw err;\n                    throw context_1.fail(this.loc, _ => _.badRegExp(this.parts[0]));\n                }\n        },\n        New(sk) {\n            SK_1.checkVal(this, sk);\n            this.type.verify(1);\n            util_2.verifyEachValOrSpread(this.args);\n        },\n        ObjEntryAssign(sk) {\n            SK_1.checkDo(this, sk);\n            if (!context_2.results.isObjEntryExport(this))\n                locals_1.accessLocal(this, 'built');\n            this.assign.verify(0);\n            for (const _ of this.assign.allAssignees())\n                locals_1.setDeclareAccessed(_, this);\n        },\n        ObjEntryPlain(sk) {\n            SK_1.checkDo(this, sk);\n            if (context_2.results.isObjEntryExport(this))\n                context_1.check(typeof this.name === 'string', this.loc, _ => _.exportName);\n            else {\n                locals_1.accessLocal(this, 'built');\n                util_2.verifyName(this.name);\n            }\n            this.value.verify(1);\n        },\n        ObjSimple(sk) {\n            SK_1.checkVal(this, sk);\n            const keys = new Set();\n            for (const { key, value, loc } of this.pairs) {\n                context_1.check(!keys.has(key), loc, _ => _.duplicateKey(key));\n                keys.add(key);\n                value.verify(1);\n            }\n        },\n        Pass(sk) {\n            SK_1.checkDo(this, sk);\n            this.ignored.verify(1);\n        },\n        Pipe(sk) {\n            SK_1.checkVal(this, sk);\n            this.startValue.verify();\n            for (const pipe of this.pipes)\n                locals_1.registerAndPlusLocal(MsAst_1.LocalDeclare.focus(this.loc), () => {\n                    pipe.verify(1);\n                });\n        },\n        QuotePlain(sk) {\n            SK_1.checkVal(this, sk);\n            this.parts.forEach(util_2.verifyName);\n        },\n        QuoteSimple(sk) {\n            SK_1.checkVal(this, sk);\n        },\n        QuoteTaggedTemplate(sk) {\n            SK_1.checkVal(this, sk);\n            this.tag.verify(1);\n            this.quote.verify(1);\n        },\n        Range(sk) {\n            SK_1.checkVal(this, sk);\n            this.start.verify(1);\n            verifyOpVal(this.end);\n        },\n        SetSub(sk) {\n            SK_1.checkDo(this, sk);\n            this.object.verify(1);\n            verifyEachVal(this.subbeds);\n            verifyOpVal(this.opType);\n            this.value.verify(1);\n        },\n        SimpleFun(sk) {\n            SK_1.checkVal(this, sk);\n            context_2.withFun(0, () => {\n                locals_1.registerAndPlusLocal(MsAst_1.LocalDeclare.focus(this.loc), () => {\n                    this.value.verify();\n                });\n            });\n        },\n        SpecialDo(sk) {\n            SK_1.checkDo(this, sk);\n        },\n        SpecialVal(sk) {\n            SK_1.checkVal(this, sk);\n            util_2.setName(this);\n        },\n        Spread(sk) {\n            context_1.check(sk === null, this.loc, _ => sk === 1 ? _.misplacedSpreadVal : _.misplacedSpreadDo);\n            this.spreaded.verify(1);\n        },\n        Sub(sk) {\n            SK_1.checkVal(this, sk);\n            this.subbed.verify(1);\n            verifyEachVal(this.args);\n        },\n        SuperCall(sk) {\n            const meth = Op_1.orThrow(context_2.method, () => context_1.fail(this.loc, _ => _.superNeedsMethod));\n            context_2.results.superCallToMethod.set(this, meth);\n            if (meth instanceof MsAst_1.Constructor) {\n                context_1.check(sk === 0, this.loc, _ => _.superMustBeStatement);\n                context_2.results.constructorToSuper.set(meth, this);\n            }\n            verifyEachVal(this.args);\n        },\n        SuperMember(sk) {\n            SK_1.checkVal(this, sk);\n            context_1.check(context_2.method !== null, this.loc, _ => _.superNeedsMethod);\n            util_2.verifyName(this.name);\n        },\n        Switch(sk) {\n            SK_1.markStatement(this, sk);\n            context_2.withIifeIfVal(sk, () => {\n                context_2.withInSwitch(true, () => {\n                    this.switched.verify(1);\n                    util_2.verifyEach(this.parts, sk);\n                    util_2.verifyOp(this.opElse, sk);\n                });\n            });\n        },\n        SwitchPart(sk) {\n            SK_1.markStatement(this, sk);\n            verifyEachVal(this.values);\n            this.result.verify(sk);\n        },\n        Throw() {\n            verifyOpVal(this.opThrown);\n        },\n        Trait(sk) {\n            SK_1.checkVal(this, sk);\n            verifyEachVal(this.superTraits);\n            verifyOpDo(this.opDo);\n            context_2.withMethods(() => {\n                for (const _ of this.statics)\n                    _.verify();\n                for (const _ of this.methods)\n                    _.verify();\n            });\n        },\n        TraitDo(sk) {\n            SK_1.checkDo(this, sk);\n            this.implementor.verify(1);\n            this.trait.verify(1);\n            context_2.withMethods(() => {\n                for (const _ of this.statics)\n                    _.verify();\n                for (const _ of this.methods)\n                    _.verify();\n            });\n        },\n        With(sk) {\n            SK_1.markStatement(this, sk);\n            this.value.verify(1);\n            context_2.withIifeIfVal(sk, () => {\n                if (sk === 1)\n                    util_2.makeUseOptionalIfFocus(this.declare);\n                locals_1.verifyAndPlusLocal(this.declare, () => {\n                    this.block.verify(0);\n                });\n            });\n        },\n        Yield(_sk) {\n            context_1.check(context_2.funKind === 2, this.loc, _ => _.misplacedYield(112));\n            verifyOpVal(this.opValue);\n        },\n        YieldTo(_sk) {\n            context_1.check(context_2.funKind === 2, this.loc, _ => _.misplacedYield(113));\n            this.value.verify(1);\n        }\n    });\n    function verifyFor(forLoop) {\n        function verifyForBlock() {\n            context_2.withLoop(forLoop, () => {\n                forLoop.block.verify(0);\n            });\n        }\n        Op_1.caseOp(forLoop.opIteratee, (_) => {\n            withVerifyIteratee(_, verifyForBlock);\n        }, verifyForBlock);\n    }\n    function withVerifyIteratee({ element, bag }, action) {\n        bag.verify(1);\n        util_2.verifyNotLazy(element, _ => _.noLazyIteratee);\n        locals_1.verifyAndPlusLocal(element, action);\n    }\n    function verifyMethodImpl(_, doVerify) {\n        util_2.verifyName(_.symbol);\n        context_2.withMethod(_, doVerify);\n    }\n});\n","import Op, {caseOp, nonNull, opEach, orThrow} from 'op/Op'\nimport {check, fail, options, pathOptions, warn} from '../context'\nimport MsAst from '../MsAst'\nimport * as MsAstTypes from '../MsAst'\nimport {Block, Class, Constructor, Do, For, ForBag, Fun, Funs, Iteratee, LocalDeclare, Loop, Method, MethodImplLike, Module, Pattern, Trait, Val\n\t} from '../MsAst'\nimport {Keywords} from '../Token'\nimport {assert, cat, implementMany, isEmpty} from '../util'\nimport VerifyResults from '../VerifyResults'\nimport {funKind, isInSwitch, locals, method, opLoop, results, setup, tearDown, withFun, withIife,\n\twithIifeIf, withIifeIfVal, withInSwitch, withMethod, withMethods, withLoop, withName\n\t} from './context'\nimport {accessLocal, missingLocalFail, plusLocals, registerAndPlusLocal, setDeclareAccessed,\n\tsetLocal, verifyAndPlusLocal, verifyAndPlusLocals, verifyLocalDeclare, warnUnusedLocals,\n\twithBlockLocals} from './locals'\nimport SK, {checkDo, checkVal, getSK, markStatement} from './SK'\nimport {makeUseOptional, makeUseOptionalIfFocus, setName, verifyEach, verifyEachValOrSpread,\n\tverifyName, verifyNotLazy, verifyOp} from './util'\nimport verifyBlock, {verifyDoBlock, verifyModuleLines} from './verifyBlock'\n\n/**\nGenerates information needed during transpiling, the VerifyResults.\nAlso checks for existence of local variables and warns for unused locals.\n*/\nexport default function verify(module: Module): VerifyResults {\n\tsetup()\n\tmodule.verify()\n\twarnUnusedLocals()\n\tconst res = results\n\ttearDown()\n\treturn res\n}\n\n//todo\nfunction verifyOpVal(_: Op<Val>): void {\n\tif (nonNull(_))\n\t\t_.verify(SK.Val)\n}\nfunction verifyOpDo(_: Op<Do>): void {\n\tif (nonNull(_))\n\t\t_.verify(SK.Do)\n}\nfunction verifyEachVal(vals: Array<Val>): void {\n\tfor (const _ of vals)\n\t\t_.verify(SK.Val)\n}\n\n//todo\n//verifyModule\n//verifyDo (was doing: sk = SK.Do, now that's implied)\n//verifyVal (was doing: sk = SK.Val, now that's implied)\n//and specific verifies\n//e.g.:\n/*\nfunction verifyVal(_) {\n\t...\n\telse if (_ instanceof Conditional)\n\t\t//appears in multiple places so reuse that code\n\t\tverifyConditional(_)\n\t...\n\telse if (_ instanceof Sub)\n\t\t<<inline, only appears here>>\n\t...\n\telse\n\t\t<<error from checkVal>>\n}\n\nfunction verifyDo(_) {\n\t...\n\telse if (_ instanceof Conditional)\n\t\tverifyConditional(_)\n\t...\n\telse\n\t\t<<error from checkDo>>\n}\n*/\n\nimplementMany(MsAstTypes, 'verify', {\n\tAssert(sk: SK): void {\n\t\tcheckDo(this, sk)\n\t\tthis.condition.verify(SK.Val)\n\t\tverifyOpVal(this.opThrown)\n\t},\n\n\tAssignSingle(sk: SK): void {\n\t\tcheckDo(this, sk)\n\t\twithName(this.assignee.name, () => {\n\t\t\tconst doV = () => {\n\t\t\t\t/*\n\t\t\t\tFun and Class only get name if they are immediately after the assignment.\n\t\t\t\tso in `x = $after-time 1000 |` the function is not named.\n\t\t\t\t*/\n\t\t\t\tif (this.value instanceof Class ||\n\t\t\t\t\tthis.value instanceof Fun ||\n\t\t\t\t\tthis.value instanceof Method ||\n\t\t\t\t\tthis.value instanceof Trait)\n\t\t\t\t\tsetName(this.value)\n\n\t\t\t\t// Assignee registered by verifyLines.\n\t\t\t\tthis.assignee.verify()\n\t\t\t\tthis.value.verify(SK.Val)\n\t\t\t}\n\t\t\tif (this.assignee.isLazy)\n\t\t\t\twithBlockLocals(doV)\n\t\t\telse\n\t\t\t\tdoV()\n\t\t})\n\t},\n\n\tAssignDestructure(sk: SK): void {\n\t\tcheckDo(this, sk)\n\t\t// Assignees registered by verifyLines.\n\t\tfor (const _ of this.assignees)\n\t\t\t_.verify()\n\t\tthis.value.verify(SK.Val)\n\t},\n\n\tAwait(_sk: SK): void {\n\t\tcheck(funKind === Funs.Async, this.loc, _ => _.misplacedAwait)\n\t\tthis.value.verify(SK.Val)\n\t},\n\n\tBagEntry(sk: SK): void {\n\t\tcheckDo(this, sk)\n\t\taccessLocal(this, 'built')\n\t\tthis.value.verify(SK.Val)\n\t},\n\n\tBagSimple(sk: SK): void {\n\t\tcheckVal(this, sk)\n\t\tverifyEachValOrSpread(this.parts)\n\t},\n\n\tBlock: verifyBlock,\n\n\tBlockWrap(sk: SK): void {\n\t\tcheckVal(this, sk)\n\t\twithIife(() => this.block.verify(sk))\n\t},\n\n\tBreak(sk: SK): void {\n\t\tcheckDo(this, sk)\n\t\tverifyOpVal(this.opValue)\n\t\tconst loop = orThrow(opLoop, () => fail(this.loc, _ => _.misplacedBreak))\n\n\t\tif (loop instanceof For)\n\t\t\tif (results.isStatement(loop))\n\t\t\t\tcheck(this.opValue === null, this.loc, _ => _.breakCantHaveValue)\n\t\t\telse\n\t\t\t\tcheck(this.opValue !== null, this.loc, _ => _.breakNeedsValue)\n\t\telse {\n\t\t\t// (ForAsync isn't really a loop)\n\t\t\tassert(loop instanceof ForBag)\n\t\t\tcheck(this.opValue === null, this.loc, _ => _.breakValInForBag)\n\t\t}\n\n\t\tif (isInSwitch) {\n\t\t\tresults.loopsNeedingLabel.add(loop)\n\t\t\tresults.breaksInSwitch.add(this)\n\t\t}\n\t},\n\n\tCall(_sk: SK): void {\n\t\t// Call can be either SK.Val or SK.Do\n\t\tthis.called.verify(SK.Val)\n\t\tverifyEachValOrSpread(this.args)\n\t},\n\n\tCase(sk: SK): void {\n\t\tmarkStatement(this, sk)\n\t\twithIifeIfVal(sk, () => {\n\t\t\tconst doIt = () => {\n\t\t\t\tverifyEach(this.parts, sk)\n\t\t\t\tverifyOp(this.opElse, sk)\n\t\t\t}\n\t\t\tcaseOp(this.opCased,\n\t\t\t\t_ => {\n\t\t\t\t\t_.verify(SK.Do)\n\t\t\t\t\tverifyAndPlusLocal(_.assignee, doIt)\n\t\t\t\t},\n\t\t\t\tdoIt)\n\t\t})\n\t},\n\n\tCasePart(sk: SK): void {\n\t\tif (this.test instanceof Pattern) {\n\t\t\tthis.test.type.verify(SK.Val)\n\t\t\tthis.test.patterned.verify(SK.Val)\n\t\t\tverifyAndPlusLocals(this.test.locals, () => this.result.verify(sk))\n\t\t} else {\n\t\t\tthis.test.verify(SK.Val)\n\t\t\tthis.result.verify(sk)\n\t\t}\n\t},\n\n\tCatch(sk: SK): void {\n\t\t// No need to do anything with `sk` except pass it to my block.\n\t\tmakeUseOptionalIfFocus(this.caught)\n\t\tverifyNotLazy(this.caught, _ => _.noLazyCatch)\n\t\tverifyAndPlusLocal(this.caught, () => {\n\t\t\tthis.block.verify(sk)\n\t\t})\n\t},\n\n\tClass(sk: SK): void {\n\t\tcheckVal(this, sk)\n\t\topEach(this.opFields, fields => {\n\t\t\tfor (const _ of fields)\n\t\t\t\t_.verify()\n\t\t})\n\t\tverifyOpVal(this.opSuperClass)\n\t\tverifyEachVal(this.traits)\n\n\t\twithIife(() => {\n\t\t\topEach(this.opDo, _ => _.verify())\n\t\t})\n\n\t\t// Class acts like a Fun: loop/generator context is lost and we get block locals.\n\t\twithMethods(() => {\n\t\t\tfor (const _ of this.statics)\n\t\t\t\t_.verify()\n\t\t\topEach(this.opConstructor, _ => _.verify(this.opSuperClass !== null))\n\t\t\tfor (const _ of this.methods)\n\t\t\t\t_.verify()\n\t\t})\n\t\t// name set by AssignSingle\n\t},\n\n\tClassTraitDo(): void {\n\t\tverifyAndPlusLocal(this.declareFocus, () => this.block.verify(SK.Do))\n\t},\n\n\tCond(sk: SK): void {\n\t\t// Could be a statement if both results are.\n\t\tthis.test.verify(SK.Val)\n\t\tthis.ifTrue.verify(sk)\n\t\tthis.ifFalse.verify(sk)\n\t},\n\n\tConditional(sk: SK): void {\n\t\tmarkStatement(this, sk)\n\t\tthis.test.verify(SK.Val)\n\t\twithIifeIf(this.result instanceof Block && sk === SK.Val, () => {\n\t\t\tthis.result.verify(sk)\n\t\t})\n\t},\n\n\tConstructor(classHasSuper: boolean): void {\n\t\tmakeUseOptional(this.fun.opDeclareThis)\n\t\twithMethod(this, () => {\n\t\t\tthis.fun.verify(SK.Val)\n\t\t})\n\n\t\tconst superCall = results.constructorToSuper.get(this)\n\n\t\tif (classHasSuper)\n\t\t\tcheck(superCall !== undefined, this.loc, _ => _.superNeeded)\n\t\telse\n\t\t\tcheck(superCall === undefined, () => superCall.loc, _ => _.superForbidden)\n\n\t\tfor (const _ of this.memberArgs)\n\t\t\tsetDeclareAccessed(_, this)\n\t},\n\n\tDel(_sk: SK): void {\n\t\t// DelSub can be either SK.Val or SK.Do\n\t\tthis.subbed.verify(SK.Val)\n\t\tverifyEachVal(this.args)\n\t},\n\n\tExcept(sk: SK): void {\n\t\tmarkStatement(this, sk)\n\t\tif (this.opElse === null)\n\t\t\tthis.try.verify(sk)\n\t\telse {\n\t\t\tplusLocals(verifyDoBlock(this.try), () => this.opElse.verify(sk))\n\t\t\tif (isEmpty(this.allCatches))\n\t\t\t\twarn(this.loc, _ => _.elseRequiresCatch)\n\t\t}\n\n\t\tif (isEmpty(this.allCatches) && this.opFinally === null)\n\t\t\twarn(this.loc, _ => _.uselessExcept)\n\n\t\tverifyEach(this.typedCatches, sk)\n\t\tverifyOp(this.opCatchAll, sk)\n\t\tverifyOpDo(this.opFinally)\n\t},\n\n\tField(): void {\n\t\tverifyOpVal(this.opType)\n\t},\n\n\tFor(sk: SK): void {\n\t\tmarkStatement(this, sk)\n\t\tverifyFor(this)\n\t},\n\n\tForAsync(sk: SK): void {\n\t\tmarkStatement(this, sk)\n\t\tcheck(sk !== SK.Do || funKind === Funs.Async, this.loc, _ => _.forAsyncNeedsAsync)\n\t\twithVerifyIteratee(this.iteratee, () => {\n\t\t\twithFun(Funs.Async, () => {\n\t\t\t\t// Default block to returning a value, but OK if it doesn't.\n\t\t\t\t// If a statement, statement, the compiled code will make a Promise\n\t\t\t\t// that resolves to an array full of `undefined`.\n\t\t\t\tthis.block.verify(getSK(this.block))\n\t\t\t})\n\t\t})\n\t},\n\n\tForBag(sk: SK): void {\n\t\tcheckVal(this, sk)\n\t\tverifyAndPlusLocal(this.built, () => verifyFor(this))\n\t},\n\n\tFun(sk: SK): void {\n\t\tcheckVal(this, sk)\n\t\tcheck(this.opReturnType === null || !this.isDo, this.loc, _ => _.doFuncCantHaveType)\n\t\tverifyOpVal(this.opReturnType)\n\t\tconst args = cat(this.opDeclareThis, this.args, this.opRestArg)\n\t\twithFun(this.kind, () => {\n\t\t\tverifyAndPlusLocals(args, () => {\n\t\t\t\tthis.block.verify(this.isDo ? SK.Do : SK.Val)\n\t\t\t})\n\t\t})\n\t\t// name set by AssignSingle\n\t},\n\n\tFunAbstract(): void {\n\t\tfor (const _ of this.args)\n\t\t\t_.verify()\n\t\topEach(this.opRestArg, _ => _.verify())\n\t\topEach(this.opReturnType, _ => _.verify())\n\t},\n\n\tGetterFun(sk: SK): void {\n\t\tcheckVal(this, sk)\n\t\tverifyName(this.name)\n\t},\n\n\tIgnore(sk: SK): void {\n\t\tcheckDo(this, sk)\n\t\tfor (const _ of this.ignoredNames)\n\t\t\taccessLocal(this, _)\n\t},\n\n\tImport(): void {\n\t\t// Since Uses are always in the outermost scope, don't have to worry about shadowing.\n\t\t// So we mutate `locals` directly.\n\t\tfunction addUseLocal(ld: LocalDeclare) {\n\t\t\tconst prev = locals.get(ld.name)\n\t\t\tcheck(prev === undefined, ld.loc, _ => _.duplicateImport(ld.name, prev.loc))\n\t\t\tverifyLocalDeclare(ld)\n\t\t\tsetLocal(ld)\n\t\t}\n\t\tfor (const _ of this.imported)\n\t\t\taddUseLocal(_)\n\t\topEach(this.opImportDefault, addUseLocal)\n\t},\n\n\tInstanceOf(sk: SK): void {\n\t\tcheckVal(this, sk)\n\t\tthis.instance.verify(SK.Val)\n\t\tthis.type.verify(SK.Val)\n\t},\n\n\tLazy(sk: SK): void {\n\t\tcheckVal(this, sk)\n\t\twithBlockLocals(() => this.value.verify(SK.Val))\n\t},\n\n\tLocalAccess(sk: SK): void {\n\t\tcheckVal(this, sk)\n\t\tconst declare = locals.get(this.name)\n\t\tif (declare === undefined) {\n\t\t\tconst builtinPath = orThrow(\n\t\t\t\toptions.opBuiltinPath(this.name),\n\t\t\t\t() => missingLocalFail(this.loc, this.name))\n\t\t\tresults.accessBuiltin(this.name, builtinPath)\n\t\t} else {\n\t\t\tresults.localAccessToDeclare.set(this, declare)\n\t\t\tsetDeclareAccessed(declare, this)\n\t\t}\n\t},\n\n\t// Adding LocalDeclares to the available locals is done by Fun or lineNewLocals.\n\tLocalDeclare(): void {\n\t\topEach(options.opBuiltinPath(this.name), path => {\n\t\t\twarn(this.loc, _ => _.overriddenBuiltin(this.name, path))\n\t\t})\n\t\topEach(this.opType, _ => _.verify())\n\t},\n\n\tLocalMutate(sk: SK): void {\n\t\tcheckDo(this, sk)\n\t\tthis.value.verify(SK.Val)\n\t},\n\n\tLogic(sk: SK): void {\n\t\tcheckVal(this, sk)\n\t\tcheck(this.args.length > 1, this.loc, _ => _.argsLogic)\n\t\tverifyEachVal(this.args)\n\t},\n\n\tNot(sk: SK): void {\n\t\tcheckVal(this, sk)\n\t\tthis.arg.verify(SK.Val)\n\t},\n\n\tNumberLiteral(sk: SK): void {\n\t\tcheckVal(this, sk)\n\t},\n\n\tMapEntry(sk: SK): void {\n\t\tcheckDo(this, sk)\n\t\taccessLocal(this, 'built')\n\t\tthis.key.verify(SK.Val)\n\t\tthis.val.verify(SK.Val)\n\t},\n\n\tMember(sk: SK): void {\n\t\tcheckVal(this, sk)\n\t\tthis.object.verify(SK.Val)\n\t\tverifyName(this.name)\n\t},\n\n\tMemberFun(sk: SK): void {\n\t\tcheckVal(this, sk)\n\t\tverifyOpVal(this.opObject)\n\t\tverifyName(this.name)\n\t},\n\n\tMemberSet(sk: SK): void {\n\t\tcheckDo(this, sk)\n\t\tthis.object.verify(SK.Val)\n\t\tverifyName(this.name)\n\t\tverifyOpVal(this.opType)\n\t\tthis.value.verify(SK.Val)\n\t},\n\n\tMethod(sk: SK): void {\n\t\tcheckVal(this, sk)\n\t\tmakeUseOptional(this.fun.opDeclareThis)\n\t\tthis.fun.args.forEach(makeUseOptional)\n\t\topEach(this.fun.opRestArg, makeUseOptional)\n\t\tthis.fun.verify(SK.Val)\n\t\t// name set by AssignSingle\n\t},\n\n\tMethodImpl(): void {\n\t\tverifyMethodImpl(this, () => {\n\t\t\tmakeUseOptional(this.fun.opDeclareThis)\n\t\t\tthis.fun.verify(SK.Val)\n\t\t})\n\t},\n\tMethodGetter(): void {\n\t\tverifyMethodImpl(this, () => {\n\t\t\tmakeUseOptional(this.declareThis)\n\t\t\tverifyAndPlusLocals([this.declareThis], () => {\n\t\t\t\tthis.block.verify(SK.Val)\n\t\t\t})\n\t\t})\n\t},\n\tMethodSetter(): void {\n\t\tverifyMethodImpl(this, () => {\n\t\t\tverifyAndPlusLocals([this.declareThis, this.declareFocus], () => {\n\t\t\t\tthis.block.verify(SK.Do)\n\t\t\t})\n\t\t})\n\t},\n\n\tModule(): void {\n\t\t// No need to verify this.doImports.\n\t\tfor (const _ of this.imports)\n\t\t\t_.verify()\n\t\twithName(pathOptions.moduleName, () => {\n\t\t\tverifyModuleLines(this.lines, this.loc)\n\t\t})\n\t},\n\n\tMsRegExp(sk: SK): void {\n\t\tcheckVal(this, sk)\n\t\tthis.parts.forEach(verifyName)\n\t\t// Check RegExp validity; only possible if this has a single part.\n\t\tif (this.parts.length === 1 && typeof this.parts[0] === 'string')\n\t\t\ttry {\n\t\t\t\t/* eslint-disable no-new */\n\t\t\t\tnew RegExp(this.parts[0])\n\t\t\t} catch (err) {\n\t\t\t\tif (!(err instanceof SyntaxError))\n\t\t\t\t\t// This should never happen.\n\t\t\t\t\tthrow err\n\t\t\t\tthrow fail(this.loc, _ => _.badRegExp(this.parts[0]))\n\t\t\t}\n\t},\n\n\tNew(sk: SK): void {\n\t\tcheckVal(this, sk)\n\t\tthis.type.verify(SK.Val)\n\t\tverifyEachValOrSpread(this.args)\n\t},\n\n\tObjEntryAssign(sk: SK): void {\n\t\tcheckDo(this, sk)\n\t\tif (!results.isObjEntryExport(this))\n\t\t\taccessLocal(this, 'built')\n\t\tthis.assign.verify(SK.Do)\n\t\tfor (const _ of this.assign.allAssignees())\n\t\t\tsetDeclareAccessed(_, this)\n\t},\n\n\tObjEntryPlain(sk: SK): void {\n\t\tcheckDo(this, sk)\n\t\tif (results.isObjEntryExport(this))\n\t\t\tcheck(typeof this.name === 'string', this.loc, _ => _.exportName)\n\t\telse {\n\t\t\taccessLocal(this, 'built')\n\t\t\tverifyName(this.name)\n\t\t}\n\t\tthis.value.verify(SK.Val)\n\t},\n\n\tObjSimple(sk: SK): void {\n\t\tcheckVal(this, sk)\n\t\tconst keys = new Set()\n\t\tfor (const {key, value, loc} of this.pairs) {\n\t\t\tcheck(!keys.has(key), loc, _ => _.duplicateKey(key))\n\t\t\tkeys.add(key)\n\t\t\tvalue.verify(SK.Val)\n\t\t}\n\t},\n\n\tPass(sk: SK): void {\n\t\tcheckDo(this, sk)\n\t\tthis.ignored.verify(SK.Val)\n\t},\n\n\tPipe(sk: SK): void {\n\t\tcheckVal(this, sk)\n\t\tthis.startValue.verify()\n\t\tfor (const pipe of this.pipes)\n\t\t\tregisterAndPlusLocal(LocalDeclare.focus(this.loc), () => {\n\t\t\t\tpipe.verify(SK.Val)\n\t\t\t})\n\t},\n\n\tQuotePlain(sk: SK): void {\n\t\tcheckVal(this, sk)\n\t\tthis.parts.forEach(verifyName)\n\t},\n\n\tQuoteSimple(sk: SK): void {\n\t\tcheckVal(this, sk)\n\t},\n\n\tQuoteTaggedTemplate(sk: SK): void {\n\t\tcheckVal(this, sk)\n\t\tthis.tag.verify(SK.Val)\n\t\tthis.quote.verify(SK.Val)\n\t},\n\n\tRange(sk: SK): void {\n\t\tcheckVal(this, sk)\n\t\tthis.start.verify(SK.Val)\n\t\tverifyOpVal(this.end)\n\t},\n\n\tSetSub(sk: SK): void {\n\t\tcheckDo(this, sk)\n\t\tthis.object.verify(SK.Val)\n\t\tverifyEachVal(this.subbeds)\n\t\tverifyOpVal(this.opType)\n\t\tthis.value.verify(SK.Val)\n\t},\n\n\tSimpleFun(sk: SK): void {\n\t\tcheckVal(this, sk)\n\t\twithFun(Funs.Plain, () => {\n\t\t\tregisterAndPlusLocal(LocalDeclare.focus(this.loc), () => {\n\t\t\t\tthis.value.verify()\n\t\t\t})\n\t\t})\n\t},\n\n\tSpecialDo(sk: SK): void {\n\t\tcheckDo(this, sk)\n\t},\n\n\tSpecialVal(sk: SK): void {\n\t\tcheckVal(this, sk)\n\t\tsetName(this)\n\t},\n\n\tSpread(sk: Op<SK>): void {\n\t\tcheck(sk === null, this.loc, _ => sk === SK.Val ? _.misplacedSpreadVal : _.misplacedSpreadDo)\n\t\tthis.spreaded.verify(SK.Val)\n\t},\n\n\tSub(sk: SK): void {\n\t\tcheckVal(this, sk)\n\t\tthis.subbed.verify(SK.Val)\n\t\tverifyEachVal(this.args)\n\t},\n\n\tSuperCall(sk: SK): void {\n\t\tconst meth = orThrow(method, () => fail(this.loc, _ => _.superNeedsMethod))\n\t\tresults.superCallToMethod.set(this, meth)\n\n\t\tif (meth instanceof Constructor) {\n\t\t\tcheck(sk === SK.Do, this.loc, _ => _.superMustBeStatement)\n\t\t\tresults.constructorToSuper.set(meth, this)\n\t\t}\n\n\t\tverifyEachVal(this.args)\n\t},\n\n\tSuperMember(sk: SK): void {\n\t\tcheckVal(this, sk)\n\t\tcheck(method !== null, this.loc, _ => _.superNeedsMethod)\n\t\tverifyName(this.name)\n\t},\n\n\tSwitch(sk: SK): void {\n\t\tmarkStatement(this, sk)\n\t\twithIifeIfVal(sk, () => {\n\t\t\twithInSwitch(true, () => {\n\t\t\t\tthis.switched.verify(SK.Val)\n\t\t\t\tverifyEach(this.parts, sk)\n\t\t\t\tverifyOp(this.opElse, sk)\n\t\t\t})\n\t\t})\n\t},\n\n\tSwitchPart(sk: SK): void {\n\t\tmarkStatement(this, sk)\n\t\tverifyEachVal(this.values)\n\t\tthis.result.verify(sk)\n\t},\n\n\tThrow(): void {\n\t\tverifyOpVal(this.opThrown)\n\t},\n\n\tTrait(sk: SK): void {\n\t\tcheckVal(this, sk)\n\t\tverifyEachVal(this.superTraits)\n\t\tverifyOpDo(this.opDo)\n\t\twithMethods(() => {\n\t\t\tfor (const _ of this.statics)\n\t\t\t\t_.verify()\n\t\t\tfor (const _ of this.methods)\n\t\t\t\t_.verify()\n\t\t})\n\t\t// name set by AssignSingle\n\t},\n\n\tTraitDo(sk: SK): void {\n\t\tcheckDo(this, sk)\n\t\tthis.implementor.verify(SK.Val)\n\t\tthis.trait.verify(SK.Val)\n\t\twithMethods(() => {\n\t\t\tfor (const _ of this.statics)\n\t\t\t\t_.verify()\n\t\t\tfor (const _ of this.methods)\n\t\t\t\t_.verify()\n\t\t})\n\t},\n\n\tWith(sk: SK): void {\n\t\tmarkStatement(this, sk)\n\t\tthis.value.verify(SK.Val)\n\t\twithIifeIfVal(sk, () => {\n\t\t\tif (sk === SK.Val)\n\t\t\t\tmakeUseOptionalIfFocus(this.declare)\n\t\t\tverifyAndPlusLocal(this.declare, () => {\n\t\t\t\tthis.block.verify(SK.Do)\n\t\t\t})\n\t\t})\n\t},\n\n\tYield(_sk: SK): void {\n\t\tcheck(funKind === Funs.Generator, this.loc, _ => _.misplacedYield(Keywords.Yield))\n\t\tverifyOpVal(this.opValue)\n\t},\n\n\tYieldTo(_sk: SK): void {\n\t\tcheck(funKind === Funs.Generator, this.loc, _ => _.misplacedYield(Keywords.YieldTo))\n\t\tthis.value.verify(SK.Val)\n\t}\n})\n\n// Helpers specific to certain MsAst types\n\nfunction verifyFor(forLoop: For | ForBag): void {\n\tfunction verifyForBlock(): void {\n\t\twithLoop(forLoop, () => {\n\t\t\tforLoop.block.verify(SK.Do)\n\t\t})\n\t}\n\tcaseOp(forLoop.opIteratee,\n\t\t(_: Iteratee) => {\n\t\t\twithVerifyIteratee(_, verifyForBlock)\n\t\t},\n\t\tverifyForBlock)\n}\n\nfunction withVerifyIteratee({element, bag}: Iteratee, action: () => void): void {\n\tbag.verify(SK.Val)\n\tverifyNotLazy(element, _ => _.noLazyIteratee)\n\tverifyAndPlusLocal(element, action)\n}\n\nfunction verifyMethodImpl(_: MethodImplLike, doVerify: () => void): void {\n\tverifyName(_.symbol)\n\twithMethod(_, doVerify)\n}\n"],"sourceRoot":"/source/"}