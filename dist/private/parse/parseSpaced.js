if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports', 'module', '../../CompileError', '../context', '../MsAst', '../Token', '../util', './checks', './parse*', './parseMemberName', './parseName', './parseQuote', './parseSingle', './Slice'], function (exports, module, _CompileError, _context, _MsAst, _Token, _util, _checks, _parse, _parseMemberName, _parseName, _parseQuote, _parseSingle, _Slice) {
	'use strict';

	module.exports = parseSpaced;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _parseMemberName2 = _interopRequireDefault(_parseMemberName);

	var _parseName2 = _interopRequireDefault(_parseName);

	var _parseQuote2 = _interopRequireDefault(_parseQuote);

	var _parseSingle2 = _interopRequireDefault(_parseSingle);

	var _Slice2 = _interopRequireDefault(_Slice);

	function parseSpaced(tokens) {
		const h = tokens.head(),
		      rest = tokens.tail();
		if ((0, _Token.isKeyword)(_Token.KW_Type, h)) return _MsAst.Call.contains(h.loc, parseSpaced(rest), _MsAst.LocalAccess.focus(h.loc));else if ((0, _Token.isKeyword)(_Token.KW_Lazy, h)) return new _MsAst.Lazy(h.loc, parseSpaced(rest));else if ((0, _Token.isKeyword)(_Token.KW_Dot, h)) {
			const name = (0, _parseName2.default)(rest.head());
			const rest2 = rest.tail();
			const member = new _MsAst.Member(h.loc, _MsAst.LocalAccess.this(h.loc), name);
			return rest2.isEmpty() ? member : parseSpacedFold(member, rest.tail());
		} else if ((0, _Token.isKeyword)(_Token.KW_Ellipsis, h)) return new _MsAst.Splat(tokens.loc, parseSpacedFold((0, _parseSingle2.default)(rest.head()), rest.tail));else if ((0, _Token.isKeyword)(_Token.KW_SuperVal, h)) {
			// TODO: handle sub here as well
			const h2 = rest.head();
			if ((0, _Token.isKeyword)(_Token.KW_Dot, h2)) {
				const tail = rest.tail();
				const sup = new _MsAst.SuperMember(h2.loc, (0, _parseMemberName2.default)(tail.head()));
				return parseSpacedFold(sup, tail.tail());
			} else if ((0, _Token.isGroup)(_Token.G_Parenthesis, h2) && _Slice2.default.group(h2).isEmpty()) {
				const x = new _MsAst.SuperCall(h2.loc, []);
				return parseSpacedFold(x, rest.tail());
			} else (0, _context.fail)(`Expected ${ (0, _CompileError.code)('.') } or ${ (0, _CompileError.code)('()') } after ${ (0, _CompileError.code)('super') }`);
		} else return parseSpacedFold((0, _parseSingle2.default)(h), rest);
	}

	const parseSpacedFold = (start, rest) => {
		let acc = start;
		for (let i = rest.start; i < rest.end; i = i + 1) {
			const token = rest.tokens[i];
			const loc = token.loc;
			if ((0, _Token.isKeyword)(_Token.KW_Dot, token)) {
				// If this was the last one, it would not be a KW_Dot but a KW_ObjAssign
				(0, _util.assert)(i < rest.end - 1);
				i = i + 1;
				const next = rest.tokens[i];
				acc = new _MsAst.Member(token.loc, acc, (0, _parseMemberName2.default)(next));
			} else if (token instanceof _Token.Keyword) switch (token.kind) {
				case _Token.KW_Focus:
					acc = new _MsAst.Call(token.loc, acc, [_MsAst.LocalAccess.focus(loc)]);
					break;
				case _Token.KW_Type:
					{
						const type = parseSpaced(rest._chopStart(i + 1));
						return _MsAst.Call.contains(token.loc, type, acc);
					}
				default:
					(0, _checks.unexpected)(token);
			} else if (token instanceof _Token.Group) {
				const slice = _Slice2.default.group(token);
				switch (token.kind) {
					case _Token.G_Bracket:
						acc = _MsAst.Call.sub(loc, (0, _util.cat)(acc, (0, _parse.parseExprParts)(slice)));
						break;
					case _Token.G_Parenthesis:
						(0, _checks.checkEmpty)(slice, () => `Use ${ (0, _CompileError.code)('(a b)') }, not ${ (0, _CompileError.code)('a(b)') }`);
						acc = new _MsAst.Call(loc, acc, []);
						break;
					case _Token.G_Quote:
						acc = new _MsAst.QuoteTemplate(loc, acc, (0, _parseQuote2.default)(slice));
						break;
					default:
						(0, _checks.unexpected)(token);
				}
			}
		}
		return acc;
	};
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhcnNlU3BhY2VkLmpzIiwicHJpdmF0ZS9wYXJzZS9wYXJzZVNwYWNlZC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O2tCQ2V3QixXQUFXOzs7Ozs7Ozs7Ozs7OztBQUFwQixVQUFTLFdBQVcsQ0FBQyxNQUFNLEVBQUU7QUFDM0MsUUFBTSxDQUFDLEdBQUcsTUFBTSxDQUFDLElBQUksRUFBRTtRQUFFLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUE7QUFDN0MsTUFBSSxXQWJzRCxTQUFTLFNBQ25DLE9BQU8sRUFZaEIsQ0FBQyxDQUFDLEVBQ3hCLE9BQU8sT0FoQkQsSUFBSSxDQWdCRSxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQUUsT0FoQjdCLFdBQVcsQ0FnQjhCLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQSxLQUNwRSxJQUFJLFdBZmlELFNBQVMsU0FDekQsT0FBTyxFQWNXLENBQUMsQ0FBQyxFQUM3QixPQUFPLFdBbEJLLElBQUksQ0FrQkEsQ0FBQyxDQUFDLEdBQUcsRUFBRSxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQSxLQUNyQyxJQUFJLFdBakJpRCxTQUFTLFNBQVcsTUFBTSxFQWlCekQsQ0FBQyxDQUFDLEVBQUU7QUFDOUIsU0FBTSxJQUFJLEdBQUcseUJBQVUsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUE7QUFDbkMsU0FBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFBO0FBQ3pCLFNBQU0sTUFBTSxHQUFHLFdBdEJnQixNQUFNLENBc0JYLENBQUMsQ0FBQyxHQUFHLEVBQUUsT0F0QmYsV0FBVyxDQXNCZ0IsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQTtBQUMvRCxVQUFPLEtBQUssQ0FBQyxPQUFPLEVBQUUsR0FBRyxNQUFNLEdBQUcsZUFBZSxDQUFDLE1B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RyxXQTVFOEIsYUFBYSxDQTRFekIsR0FBRyxFQUFFLEdBQUcsRUFBRSwwQkFBVyxLQUFLLENBQUMsQ0FBQyxDQUFBO0FBQ3BELFlBQUs7QUFBQSxBQUNOO0FBQ0Msa0JBMUVlLFVBQVUsRUEwRWQsS0FBSyxDQUFDLENBQUE7QUFBQSxLQUNsQjtJQUNEO0dBQ0Q7QUFDRCxTQUFPLEdBQUcsQ0FBQTtFQUNWLENBQUEiLCJmaWxlIjoicHJpdmF0ZS9wYXJzZS9wYXJzZVNwYWNlZC5qcyIsInNvdXJjZXNDb250ZW50IjpbbnVsbCwiaW1wb3J0IHtjb2RlfSBmcm9tICcuLi8uLi9Db21waWxlRXJyb3InXG5pbXBvcnQge2ZhaWx9IGZyb20gJy4uL2NvbnRleHQnXG5pbXBvcnQge0NhbGwsIExhenksIExvY2FsQWNjZXNzLCBNZW1iZXIsIFF1b3RlVGVtcGxhdGUsIFNwbGF0LCBTdXBlckNhbGwsIFN1cGVyTWVtYmVyXG5cdH0gZnJvbSAnLi4vTXNBc3QnXG5pbXBvcnQge0dyb3VwLCBHX0JyYWNrZXQsIEdfUGFyZW50aGVzaXMsIEdfUXVvdGUsIGlzR3JvdXAsIGlzS2V5d29yZCwgS2V5d29yZCwgS1dfRG90LCBLV19FbGxpcHNpcyxcblx0S1dfRm9jdXMsIEtXX0xhenksIEtXX1N1cGVyVmFsLCBLV19UeXBlfSBmcm9tICcuLi9Ub2tlbidcbmltcG9ydCB7YXNzZXJ0LCBjYXR9IGZyb20gJy4uL3V0aWwnXG5pbXBvcnQge2NoZWNrRW1wdHksIHVuZXhwZWN0ZWR9IGZyb20gJy4vY2hlY2tzJ1xuaW1wb3J0IHtwYXJzZUV4cHJQYXJ0c30gZnJvbSAnLi9wYXJzZSonXG5pbXBvcnQgcGFyc2VNZW1iZXJOYW1lIGZyb20gJy4vcGFyc2VNZW1iZXJOYW1lJ1xuaW1wb3J0IHBhcnNlTmFtZSBmcm9tICcuL3BhcnNlTmFtZSdcbmltcG9ydCBwYXJzZVF1b3RlIGZyb20gJy4vcGFyc2VRdW90ZSdcbmltcG9ydCBwYXJzZVNpbmdsZSBmcm9tICcuL3BhcnNlU2luZ2xlJ1xuaW1wb3J0IFNsaWNlIGZyb20gJy4vU2xpY2UnXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBhcnNlU3BhY2VkKHRva2Vucykge1xuXHRjb25zdCBoID0gdG9rZW5zLmhlYWQoKSwgcmVzdCA9IHRva2Vucy50YWlsKClcblx0aWYgKGlzS2V5d29yZChLV19UeXBlLCBoKSlcblx0XHRyZXR1cm4gQ2FsbC5jb250YWlucyhoLmxvYywgcGFyc2VTcGFjZWQocmVzdCksIExvY2FsQWNjZXNzLmZvY3VzKGgubG9jKSlcblx0ZWxzZSBpZiAoaXNLZXl3b3JkKEtXX0xhenksIGgpKVxuXHRcdHJldHVybiBuZXcgTGF6eShoLmxvYywgcGFyc2VTcGFjZWQocmVzdCkpXG5cdGVsc2UgaWYgKGlzS2V5d29yZChLV19Eb3QsIGgpKSB7XG5cdFx0Y29uc3QgbmFtZSA9IHBhcnNlTmFtZShyZXN0LmhlYWQoKSlcblx0XHRjb25zdCByZXN0MiA9IHJlc3QudGFpbCgpXG5cdFx0Y29uc3QgbWVtYmVyID0gbmV3IE1lbWJlcihoLmxvYywgTG9jYWxBY2Nlc3MudGhpcyhoLmxvYyksIG5hbWUpXG5cdFx0cmV0dXJuIHJlc3QyLmlzRW1wdHkoKSA/IG1lbWJlciA6IHBhcnNlU3BhY2VkRm9sZChtZW1iZXIsIHJlc3QudGFpbCgpKVxuXHR9IGVsc2UgaWYgKGlzS2V5d29yZChLV19FbGxpcHNpcywgaCkpXG5cdFx0cmV0dXJuIG5ldyBTcGxhdCh0b2tlbnMubG9jLCBwYXJzZVNwYWNlZEZvbGQocGFyc2VTaW5nbGUocmVzdC5oZWFkKCkpLCByZXN0LnRhaWwpKVxuXHRlbHNlIGlmIChpc0tleXdvcmQoS1dfU3VwZXJWYWwsIGgpKSB7XG5cdFx0Ly8gVE9ETzogaGFuZGxlIHN1YiBoZXJlIGFzIHdlbGxcblx0XHRjb25zdCBoMiA9IHJlc3QuaGVhZCgpXG5cdFx0aWYgKGlzS2V5d29yZChLV19Eb3QsIGgyKSkge1xuXHRcdFx0Y29uc3QgdGFpbCA9IHJlc3QudGFpbCgpXG5cdFx0XHRjb25zdCBzdXAgPSBuZXcgU3VwZXJNZW1iZXIoaDIubG9jLCBwYXJzZU1lbWJlck5hbWUodGFpbC5oZWFkKCkpKVxuXHRcdFx0cmV0dXJuIHBhcnNlU3BhY2VkRm9sZChzdXAsIHRhaWwudGFpbCgpKVxuXHRcdH0gZWxzZSBpZiAoaXNHcm91cChHX1BhcmVudGhlc2lzLCBoMikgJiYgU2xpY2UuZ3JvdXAoaDIpLmlzRW1wdHkoKSkge1xuXHRcdFx0Y29uc3QgeCA9IG5ldyBTdXBlckNhbGwoaDIubG9jLCBbXSlcblx0XHRcdHJldHVybiBwYXJzZVNwYWNlZEZvbGQoeCwgcmVzdC50YWlsKCkpXG5cdFx0fSBlbHNlXG5cdFx0XHRmYWlsKGBFeHBlY3RlZCAke2NvZGUoJy4nKX0gb3IgJHtjb2RlKCcoKScpfSBhZnRlciAke2NvZGUoJ3N1cGVyJyl9YClcblx0fSBlbHNlXG5cdFx0cmV0dXJuIHBhcnNlU3BhY2VkRm9sZChwYXJzZVNpbmdsZShoKSwgcmVzdClcbn1cblxuY29uc3QgcGFyc2VTcGFjZWRGb2xkID0gKHN0YXJ0LCByZXN0KSA9PiB7XG5cdGxldCBhY2MgPSBzdGFydFxuXHRmb3IgKGxldCBpID0gcmVzdC5zdGFydDsgaSA8IHJlc3QuZW5kOyBpID0gaSArIDEpIHtcblx0XHRjb25zdCB0b2tlbiA9IHJlc3QudG9rZW5zW2ldXG5cdFx0Y29uc3QgbG9jID0gdG9rZW4ubG9jXG5cdFx0aWYgKGlzS2V5d29yZChLV19Eb3QsIHRva2VuKSkge1xuXHRcdFx0Ly8gSWYgdGhpcyB3YXMgdGhlIGxhc3Qgb25lLCBpdCB3b3VsZCBub3QgYmUgYSBLV19Eb3QgYnV0IGEgS1dfT2JqQXNzaWduXG5cdFx0XHRhc3NlcnQoaSA8IHJlc3QuZW5kIC0gMSlcblx0XHRcdGkgPSBpICsgMVxuXHRcdFx0Y29uc3QgbmV4dCA9IHJlc3QudG9rZW5zW2ldXG5cdFx0XHRhY2MgPSBuZXcgTWVtYmVyKHRva2VuLmxvYywgYWNjLCBwYXJzZU1lbWJlck5hbWUobmV4dCkpXG5cdFx0fSBlbHNlIGlmICh0b2tlbiBpbnN0YW5jZW9mIEtleXdvcmQpXG5cdFx0XHRzd2l0Y2ggKHRva2VuLmtpbmQpIHtcblx0XHRcdFx0Y2FzZSBLV19Gb2N1czpcblx0XHRcdFx0XHRhY2MgPSBuZXcgQ2FsbCh0b2tlbi5sb2MsIGFjYywgW0xvY2FsQWNjZXNzLmZvY3VzKGxvYyldKVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGNhc2UgS1dfVHlwZToge1xuXHRcdFx0XHRcdGNvbnN0IHR5cGUgPSBwYXJzZVNwYWNlZChyZXN0Ll9jaG9wU3RhcnQoaSArIDEpKVxuXHRcdFx0XHRcdHJldHVybiBDYWxsLmNvbnRhaW5zKHRva2VuLmxvYywgdHlwZSwgYWNjKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dW5leHBlY3RlZCh0b2tlbilcblx0XHRcdH1cblx0XHRlbHNlIGlmICh0b2tlbiBpbnN0YW5jZW9mIEdyb3VwKSB7XG5cdFx0XHRjb25zdCBzbGljZSA9IFNsaWNlLmdyb3VwKHRva2VuKVxuXHRcdFx0c3dpdGNoICh0b2tlbi5raW5kKSB7XG5cdFx0XHRcdGNhc2UgR19CcmFja2V0OlxuXHRcdFx0XHRcdGFjYyA9IENhbGwuc3ViKGxvYywgY2F0KGFjYywgcGFyc2VFeHByUGFydHMoc2xpY2UpKSlcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlIEdfUGFyZW50aGVzaXM6XG5cdFx0XHRcdFx0Y2hlY2tFbXB0eShzbGljZSwgKCkgPT4gYFVzZSAke2NvZGUoJyhhIGIpJyl9LCBub3QgJHtjb2RlKCdhKGIpJyl9YClcblx0XHRcdFx0XHRhY2MgPSBuZXcgQ2FsbChsb2MsIGFjYywgW10pXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Y2FzZSBHX1F1b3RlOlxuXHRcdFx0XHRcdGFjYyA9IG5ldyBRdW90ZVRlbXBsYXRlKGxvYywgYWNjLCBwYXJzZVF1b3RlKHNsaWNlKSlcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHVuZXhwZWN0ZWQodG9rZW4pXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiBhY2Ncbn1cbiJdLCJzb3VyY2VSb290IjoiL3NyYyJ9
