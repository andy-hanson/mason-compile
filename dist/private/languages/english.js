'use strict';

(function (global, factory) {
	if (typeof define === "function" && define.amd) {
		define(['exports', '../../CompileError', '../lex/chars', '../Token', '../util'], factory);
	} else if (typeof exports !== "undefined") {
		factory(exports, require('../../CompileError'), require('../lex/chars'), require('../Token'), require('../util'));
	} else {
		var mod = {
			exports: {}
		};
		factory(mod.exports, global.CompileError, global.chars, global.Token, global.util);
		global.english = mod.exports;
	}
})(this, function (exports, _CompileError, _chars, _Token, _util) {
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = {
		// Lex:

		badInterpolation: `${ (0, _CompileError.code)('#') } must be followed by ${ (0, _CompileError.code)('(') }, ${ (0, _CompileError.code)('#') }, or a name.`,
		badSpacedIndent: indent => `Indentation spaces must be a multiple of ${ indent }.`,
		emptyBlock: 'Empty block.',
		extraSpace: 'Unnecessary space.',
		mismatchedGroupClose: (actual, expected) => `Trying to close ${ (0, _Token.showGroupKind)(actual) }, but last opened ${ (0, _Token.showGroupKind)(expected) }.`,
		noLeadingSpace: 'Line begins in a space',
		nonLeadingTab: 'Tab may only be used to indent',
		noNewlineInInterpolation: 'Quote interpolation cannot contain newline.',
		reservedChar: char => `Reserved character ${ (0, _chars.showChar)(char) }.`,
		suggestSimpleQuote: name => `Quoted text could be a simple quote ${ (0, _CompileError.code)(`'${ name }`) }.`,
		tooMuchIndent: 'Line is indented more than once.',
		tooMuchIndentQuote: 'Indented quote must have exactly one more indent than previous line.',
		trailingDocComment: `Doc comment must go on its own line. Did you mean ${ (0, _CompileError.code)('||') }?`,
		trailingSpace: 'Line ends in a space.',
		unclosedQuote: 'Unclosed quote.',

		// Parse:

		assignNothing: 'Assignment to nothing.',
		asToken: `Expected only 1 token after ${ (0, _Token.showKeyword)(_Token.Keywords.As) }.`,
		caseFocusIsImplicit: 'Can\'t make focus — is implicitly provided as first argument.',
		caseSwitchNeedsParts: `Must have at least 1 non-${ (0, _Token.showKeyword)(_Token.Keywords.Else) } test.`,
		condArguments: `${ (0, _Token.showKeyword)(_Token.Keywords.Cond) } takes exactly 3 arguments.`,
		conditionalArguments: kind => `${ (0, _Token.showKeyword)(kind) } with no block takes exactly 2 arguments.`,
		delArgument: `${ (0, _Token.showKeyword)(_Token.Keywords.Del) } takes only one argument.`,
		destructureAllLazy: 'All locals of destructuring assignment must all lazy or all non-lazy.',
		expectedAfterAssert: `Expected something after ${ (0, _Token.showKeyword)(_Token.Keywords.Assert) }.`,
		expectedAfterColon: `Expected something after ${ (0, _Token.showKeyword)(_Token.Keywords.Colon) }.`,
		expectedBlock: 'Expected an indented block.',
		expectedExpression: 'Expected an expression, got nothing.',
		expectedFuncKind: token => `Expected function kind, got ${ token }.`,
		expectedImportModuleName: 'Expected a module name to import.',
		expectedKeyword: keyword => `Expected ${ (0, _Token.showKeyword)(keyword) }`,
		expectedMethodSplit: 'Expected a function keyword somewhere.',
		expectedOneLocal: 'Expected only one local declaration.',
		expectedLocalName: token => `Expected a local name, not ${ token }.`,
		expectedName: token => `Expected a name, not ${ token }`,
		extraParens: `Unnecessary ${ (0, _Token.showGroup)(_Token.Groups.Parenthesis) }`,
		implicitFunctionDot: `Function ${ (0, _chars.showChar)(_chars.Chars.Dot) } is implicit for methods.`,
		infiniteRange: `Use ${ (0, _Token.showKeyword)(_Token.Keywords.Dot3) } for infinite ranges.`,
		invalidImportModule: 'Not a valid module name.',
		noImportFocus: `${ (0, _Token.showKeyword)(_Token.Keywords.Focus) } not allowed as import name.`,
		noSpecialKeyword: kind => `${ (0, _Token.showKeyword)(kind) } is not allowed here.`,
		nothingAfterFinally: `Nothing may come after ${ (0, _Token.showKeyword)(_Token.Keywords.Finally) }.`,
		parensOutsideCall: `Use ${ (0, _CompileError.code)('(a b)') }, not ${ (0, _CompileError.code)('a(b)') }.`,
		reservedWord: token => `Reserved word ${ token }.`,
		switchArgIsImplicit: 'Value to switch on is `_`, the function\'s implicit argument.',
		tokenAfterSuper: `Expected ${ (0, _Token.showKeyword)(_Token.Keywords.Dot) } or ${ (0, _CompileError.code)('()') } after ${ (0, _Token.showKeyword)(_Token.Keywords.Super) }`,
		todoForPattern: 'TODO: pattern in for',
		todoMutateDestructure: 'TODO: LocalDestructureMutate',
		unexpected: token => `Unexpected ${ token }.`,
		unexpectedAfter: token => `Did not expect anything after ${ token }.`,
		unexpectedAfterImportDo: `This is an ${ (0, _Token.showKeyword)(_Token.Keywords.ImportDo) }, so you can't import any values.`,
		unexpectedAfterKind: kind => `Did not expect anything between ${ (0, _Token.showKeyword)(kind) } and block.`,
		unexpectedAfterMethod: `Did not expect anything between ${ (0, _Token.showKeyword)(_Token.Keywords.Method) } and function.`,

		// Verify:

		ambiguousSK: 'Can\'t tell if this is a statement. Some parts are statements but others are values.',
		ambiguousForSK: `Can't tell if ${ (0, _Token.showKeyword)(_Token.Keywords.For) } is a statement. ` + `Some ${ (0, _Token.showKeyword)(_Token.Keywords.Break) }s have a value, others don't.`,
		badRegExp: source => {
			try {
				/* eslint-disable no-new */
				new RegExp(source);
				// This should only be called for bad regexp...
				(0, _util.assert)(false);
			} catch (err) {
				return err.message;
			}
		},
		blockNeedsContent: 'Value block must have some content.',
		breakCantHaveValue: `${ (0, _Token.showKeyword)(_Token.Keywords.Break) } with value needs ${ (0, _Token.showKeyword)(_Token.Keywords.For) } to be in expression position.`,
		breakNeedsValue: `${ (0, _Token.showKeyword)(_Token.Keywords.For) } in expression position must ${ (0, _Token.showKeyword)(_Token.Keywords.Break) } with a value.`,
		breakValInForBag: `${ (0, _Token.showKeyword)(_Token.Keywords.Break) } in ${ (0, _Token.showKeyword)(_Token.Keywords.ForBag) } may not have value.`,
		cantDetermineName: 'Expression must be placed in a position where name can be determined.',
		cantInferBlockKind: 'Block has mixed bag/map/obj entries — can not infer type.',
		doFuncCantHaveType: 'Function with return type must return something.',
		duplicateImport: (name, prevLoc) => `${ (0, _CompileError.code)(name) } already imported at ${ prevLoc }`,
		duplicateKey: key => `Duplicate key ${ key }`,
		duplicateLocal: name => `A local ${ (0, _CompileError.code)(name) } already exists and can't be shadowed.`,
		elseRequiresCatch: `${ (0, _Token.showKeyword)(_Token.Keywords.Else) } must come after a ${ (0, _Token.showKeyword)(_Token.Keywords.Catch) }.`,
		exportName: 'Module export must have a constant name.',
		forAsyncNeedsAsync: `${ (0, _Token.showKeyword)(_Token.Keywords.ForAsync) } as statement must be inside an async function.`,
		logicNeedsArgs: 'Logic expression needs at least 2 arguments.',
		misplacedAwait: `Cannot ${ (0, _Token.showKeyword)(_Token.Keywords.Await) } outside of async function.`,
		misplacedBreak: 'Not in a loop.',
		misplacedYield: kind => `Cannot ${ (0, _Token.showKeyword)(kind) } outside of generator function.`,
		missingLocal: name => `No such local ${ (0, _CompileError.code)(name) }.`,
		noLazyCatch: 'Caught error can not be lazy.',
		noLazyIteratee: 'Iteration element can not be lazy.',
		overriddenBuilder: (name, builtinPath) => `Local ${ (0, _CompileError.code)(undefined.name) } overrides builtin from ${ (0, _CompileError.code)(builtinPath) }.`,
		statementAsValue: 'This can only be used as a statement, but appears in expression context.',
		superForbidden: `Class has no superclass, so ${ (0, _Token.showKeyword)(_Token.Keywords.Super) } is not allowed.`,
		superMustBeStatement: `${ (0, _Token.showKeyword)(_Token.Keywords.Super) } in constructor must appear as a statement.'`,
		superNeeded: `Constructor must contain ${ (0, _Token.showKeyword)(_Token.Keywords.Super) }`,
		superNeedsMethod: `${ (0, _Token.showKeyword)(_Token.Keywords.Super) } must be in a method.`,
		unusedLocal: name => `Unused local variable ${ (0, _CompileError.code)(name) }.`,
		uselessExcept: `${ (0, _Token.showKeyword)(_Token.Keywords.Except) } must have ${ (0, _Token.showKeyword)(_Token.Keywords.Catch) } or ${ (0, _Token.showKeyword)(_Token.Keywords.Finally) }.`,
		valueAsStatement: 'Value appears in statement context, so it does nothing.'
	};
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wcml2YXRlL2xhbmd1YWdlcy9lbmdsaXNoLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OzttQkFLZTs7O0FBR2Qsa0JBQWdCLEVBQ2YsQ0FBQyxHQUFFLGtCQVRHLElBQUksRUFTRixHQUFHLENBQUMsRUFBQyxxQkFBcUIsR0FBRSxrQkFUOUIsSUFBSSxFQVMrQixHQUFHLENBQUMsRUFBQyxFQUFFLEdBQUUsa0JBVDVDLElBQUksRUFTNkMsR0FBRyxDQUFDLEVBQUMsWUFBWSxDQUFDO0FBQzFFLGlCQUFlLEVBQUUsTUFBTSxJQUN0QixDQUFDLHlDQUF5QyxHQUFFLE1BQU0sRUFBQyxDQUFDLENBQUM7QUFDdEQsWUFBVSxFQUNULGNBQWM7QUFDZixZQUFVLEVBQ1Qsb0JBQW9CO0FBQ3JCLHNCQUFvQixFQUFFLENBQUMsTUFBTSxFQUFFLFFBQVEsS0FDdEMsQ0FBQyxnQkFBZ0IsR0FBRSxXQWZnQixhQUFhLEVBZWYsTUFBTSxDQUFDLEVBQUMsa0JBQWtCLEdBQUUsV0FmMUIsYUFBYSxFQWUyQixRQUFRLENBQUMsRUFBQyxDQUFDLENBQUM7QUFDeEYsZ0JBQWMsRUFDYix3QkFBd0I7QUFDekIsZUFBYSxFQUNaLGdDQUFnQztBQUNqQywwQkFBd0IsRUFDdkIsNkNBQTZDO0FBQzlDLGNBQVksRUFBRSxJQUFJLElBQ2pCLENBQUMsbUJBQW1CLEdBQUUsV0F4QlQsUUFBUSxFQXdCVSxJQUFJLENBQUMsRUFBQyxDQUFDLENBQUM7QUFDeEMsb0JBQWtCLEVBQUUsSUFBSSxJQUN2QixDQUFDLG9DQUFvQyxHQUFFLGtCQTNCakMsSUFBSSxFQTJCa0MsQ0FBQyxDQUFDLEdBQUUsSUFBSSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQztBQUMzRCxlQUFhLEVBQ1osa0NBQWtDO0FBQ25DLG9CQUFrQixFQUNqQixzRUFBc0U7QUFDdkUsb0JBQWtCLEVBQ2pCLENBQUMsa0RBQWtELEdBQUUsa0JBakMvQyxJQUFJ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c0NvbnRlbnQiOlsiaW1wb3J0IHtjb2RlfSBmcm9tICcuLi8uLi9Db21waWxlRXJyb3InXG5pbXBvcnQge0NoYXJzLCBzaG93Q2hhcn0gZnJvbSAnLi4vbGV4L2NoYXJzJ1xuaW1wb3J0IHtHcm91cHMsIEtleXdvcmRzLCBzaG93R3JvdXAsIHNob3dHcm91cEtpbmQsIHNob3dLZXl3b3JkIGFzIGt3fSBmcm9tICcuLi9Ub2tlbidcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi91dGlsJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cdC8vIExleDpcblxuXHRiYWRJbnRlcnBvbGF0aW9uOlxuXHRcdGAke2NvZGUoJyMnKX0gbXVzdCBiZSBmb2xsb3dlZCBieSAke2NvZGUoJygnKX0sICR7Y29kZSgnIycpfSwgb3IgYSBuYW1lLmAsXG5cdGJhZFNwYWNlZEluZGVudDogaW5kZW50ID0+XG5cdFx0YEluZGVudGF0aW9uIHNwYWNlcyBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgJHtpbmRlbnR9LmAsXG5cdGVtcHR5QmxvY2s6XG5cdFx0J0VtcHR5IGJsb2NrLicsXG5cdGV4dHJhU3BhY2U6XG5cdFx0J1VubmVjZXNzYXJ5IHNwYWNlLicsXG5cdG1pc21hdGNoZWRHcm91cENsb3NlOiAoYWN0dWFsLCBleHBlY3RlZCkgPT5cblx0XHRgVHJ5aW5nIHRvIGNsb3NlICR7c2hvd0dyb3VwS2luZChhY3R1YWwpfSwgYnV0IGxhc3Qgb3BlbmVkICR7c2hvd0dyb3VwS2luZChleHBlY3RlZCl9LmAsXG5cdG5vTGVhZGluZ1NwYWNlOlxuXHRcdCdMaW5lIGJlZ2lucyBpbiBhIHNwYWNlJyxcblx0bm9uTGVhZGluZ1RhYjpcblx0XHQnVGFiIG1heSBvbmx5IGJlIHVzZWQgdG8gaW5kZW50Jyxcblx0bm9OZXdsaW5lSW5JbnRlcnBvbGF0aW9uOlxuXHRcdCdRdW90ZSBpbnRlcnBvbGF0aW9uIGNhbm5vdCBjb250YWluIG5ld2xpbmUuJyxcblx0cmVzZXJ2ZWRDaGFyOiBjaGFyID0+XG5cdFx0YFJlc2VydmVkIGNoYXJhY3RlciAke3Nob3dDaGFyKGNoYXIpfS5gLFxuXHRzdWdnZXN0U2ltcGxlUXVvdGU6IG5hbWUgPT5cblx0XHRgUXVvdGVkIHRleHQgY291bGQgYmUgYSBzaW1wbGUgcXVvdGUgJHtjb2RlKGAnJHtuYW1lfWApfS5gLFxuXHR0b29NdWNoSW5kZW50OlxuXHRcdCdMaW5lIGlzIGluZGVudGVkIG1vcmUgdGhhbiBvbmNlLicsXG5cdHRvb011Y2hJbmRlbnRRdW90ZTpcblx0XHQnSW5kZW50ZWQgcXVvdGUgbXVzdCBoYXZlIGV4YWN0bHkgb25lIG1vcmUgaW5kZW50IHRoYW4gcHJldmlvdXMgbGluZS4nLFxuXHR0cmFpbGluZ0RvY0NvbW1lbnQ6XG5cdFx0YERvYyBjb21tZW50IG11c3QgZ28gb24gaXRzIG93biBsaW5lLiBEaWQgeW91IG1lYW4gJHtjb2RlKCd8fCcpfT9gLFxuXHR0cmFpbGluZ1NwYWNlOlxuXHRcdCdMaW5lIGVuZHMgaW4gYSBzcGFjZS4nLFxuXHR1bmNsb3NlZFF1b3RlOlxuXHRcdCdVbmNsb3NlZCBxdW90ZS4nLFxuXG5cdC8vIFBhcnNlOlxuXG5cdGFzc2lnbk5vdGhpbmc6XG5cdFx0J0Fzc2lnbm1lbnQgdG8gbm90aGluZy4nLFxuXHRhc1Rva2VuOlxuXHRcdGBFeHBlY3RlZCBvbmx5IDEgdG9rZW4gYWZ0ZXIgJHtrdyhLZXl3b3Jkcy5Bcyl9LmAsXG5cdGNhc2VGb2N1c0lzSW1wbGljaXQ6XG5cdFx0J0NhblxcJ3QgbWFrZSBmb2N1cyDigJQgaXMgaW1wbGljaXRseSBwcm92aWRlZCBhcyBmaXJzdCBhcmd1bWVudC4nLFxuXHRjYXNlU3dpdGNoTmVlZHNQYXJ0czpcblx0XHRgTXVzdCBoYXZlIGF0IGxlYXN0IDEgbm9uLSR7a3coS2V5d29yZHMuRWxzZSl9IHRlc3QuYCxcblx0Y29uZEFyZ3VtZW50czpcblx0XHRgJHtrdyhLZXl3b3Jkcy5Db25kKX0gdGFrZXMgZXhhY3RseSAzIGFyZ3VtZW50cy5gLFxuXHRjb25kaXRpb25hbEFyZ3VtZW50czoga2luZCA9PlxuXHRcdGAke2t3KGtpbmQpfSB3aXRoIG5vIGJsb2NrIHRha2VzIGV4YWN0bHkgMiBhcmd1bWVudHMuYCxcblx0ZGVsQXJndW1lbnQ6XG5cdFx0YCR7a3coS2V5d29yZHMuRGVsKX0gdGFrZXMgb25seSBvbmUgYXJndW1lbnQuYCxcblx0ZGVzdHJ1Y3R1cmVBbGxMYXp5OlxuXHRcdCdBbGwgbG9jYWxzIG9mIGRlc3RydWN0dXJpbmcgYXNzaWdubWVudCBtdXN0IGFsbCBsYXp5IG9yIGFsbCBub24tbGF6eS4nLFxuXHRleHBlY3RlZEFmdGVyQXNzZXJ0OlxuXHRcdGBFeHBlY3RlZCBzb21ldGhpbmcgYWZ0ZXIgJHtrdyhLZXl3b3Jkcy5Bc3NlcnQpfS5gLFxuXHRleHBlY3RlZEFmdGVyQ29sb246XG5cdFx0YEV4cGVjdGVkIHNvbWV0aGluZyBhZnRlciAke2t3KEtleXdvcmRzLkNvbG9uKX0uYCxcblx0ZXhwZWN0ZWRCbG9jazpcblx0XHQnRXhwZWN0ZWQgYW4gaW5kZW50ZWQgYmxvY2suJyxcblx0ZXhwZWN0ZWRFeHByZXNzaW9uOlxuXHRcdCdFeHBlY3RlZCBhbiBleHByZXNzaW9uLCBnb3Qgbm90aGluZy4nLFxuXHRleHBlY3RlZEZ1bmNLaW5kOiB0b2tlbiA9PlxuXHRcdGBFeHBlY3RlZCBmdW5jdGlvbiBraW5kLCBnb3QgJHt0b2tlbn0uYCxcblx0ZXhwZWN0ZWRJbXBvcnRNb2R1bGVOYW1lOlxuXHRcdCdFeHBlY3RlZCBhIG1vZHVsZSBuYW1lIHRvIGltcG9ydC4nLFxuXHRleHBlY3RlZEtleXdvcmQ6IGtleXdvcmQgPT5cblx0XHRgRXhwZWN0ZWQgJHtrdyhrZXl3b3JkKX1gLFxuXHRleHBlY3RlZE1ldGhvZFNwbGl0OlxuXHRcdCdFeHBlY3RlZCBhIGZ1bmN0aW9uIGtleXdvcmQgc29tZXdoZXJlLicsXG5cdGV4cGVjdGVkT25lTG9jYWw6XG5cdFx0J0V4cGVjdGVkIG9ubHkgb25lIGxvY2FsIGRlY2xhcmF0aW9uLicsXG5cdGV4cGVjdGVkTG9jYWxOYW1lOiB0b2tlbiA9PlxuXHRcdGBFeHBlY3RlZCBhIGxvY2FsIG5hbWUsIG5vdCAke3Rva2VufS5gLFxuXHRleHBlY3RlZE5hbWU6IHRva2VuID0+XG5cdFx0YEV4cGVjdGVkIGEgbmFtZSwgbm90ICR7dG9rZW59YCxcblx0ZXh0cmFQYXJlbnM6XG5cdFx0YFVubmVjZXNzYXJ5ICR7c2hvd0dyb3VwKEdyb3Vwcy5QYXJlbnRoZXNpcyl9YCxcblx0aW1wbGljaXRGdW5jdGlvbkRvdDpcblx0XHRgRnVuY3Rpb24gJHtzaG93Q2hhcihDaGFycy5Eb3QpfSBpcyBpbXBsaWNpdCBmb3IgbWV0aG9kcy5gLFxuXHRpbmZpbml0ZVJhbmdlOlxuXHRcdGBVc2UgJHtrdyhLZXl3b3Jkcy5Eb3QzKX0gZm9yIGluZmluaXRlIHJhbmdlcy5gLFxuXHRpbnZhbGlkSW1wb3J0TW9kdWxlOlxuXHRcdCdOb3QgYSB2YWxpZCBtb2R1bGUgbmFtZS4nLFxuXHRub0ltcG9ydEZvY3VzOlxuXHRcdGAke2t3KEtleXdvcmRzLkZvY3VzKX0gbm90IGFsbG93ZWQgYXMgaW1wb3J0IG5hbWUuYCxcblx0bm9TcGVjaWFsS2V5d29yZDoga2luZCA9PlxuXHRcdGAke2t3KGtpbmQpfSBpcyBub3QgYWxsb3dlZCBoZXJlLmAsXG5cdG5vdGhpbmdBZnRlckZpbmFsbHk6XG5cdFx0YE5vdGhpbmcgbWF5IGNvbWUgYWZ0ZXIgJHtrdyhLZXl3b3Jkcy5GaW5hbGx5KX0uYCxcblx0cGFyZW5zT3V0c2lkZUNhbGw6XG5cdFx0YFVzZSAke2NvZGUoJyhhIGIpJyl9LCBub3QgJHtjb2RlKCdhKGIpJyl9LmAsXG5cdHJlc2VydmVkV29yZDogdG9rZW4gPT5cblx0XHRgUmVzZXJ2ZWQgd29yZCAke3Rva2VufS5gLFxuXHRzd2l0Y2hBcmdJc0ltcGxpY2l0OlxuXHRcdCdWYWx1ZSB0byBzd2l0Y2ggb24gaXMgYF9gLCB0aGUgZnVuY3Rpb25cXCdzIGltcGxpY2l0IGFyZ3VtZW50LicsXG5cdHRva2VuQWZ0ZXJTdXBlcjpcblx0XHRgRXhwZWN0ZWQgJHtrdyhLZXl3b3Jkcy5Eb3QpfSBvciAke2NvZGUoJygpJyl9IGFmdGVyICR7a3coS2V5d29yZHMuU3VwZXIpfWAsXG5cdHRvZG9Gb3JQYXR0ZXJuOlxuXHRcdCdUT0RPOiBwYXR0ZXJuIGluIGZvcicsXG5cdHRvZG9NdXRhdGVEZXN0cnVjdHVyZTpcblx0XHQnVE9ETzogTG9jYWxEZXN0cnVjdHVyZU11dGF0ZScsXG5cdHVuZXhwZWN0ZWQ6IHRva2VuID0+XG5cdFx0YFVuZXhwZWN0ZWQgJHt0b2tlbn0uYCxcblx0dW5leHBlY3RlZEFmdGVyOiB0b2tlbiA9PlxuXHRcdGBEaWQgbm90IGV4cGVjdCBhbnl0aGluZyBhZnRlciAke3Rva2VufS5gLFxuXHR1bmV4cGVjdGVkQWZ0ZXJJbXBvcnREbzpcblx0XHRgVGhpcyBpcyBhbiAke2t3KEtleXdvcmRzLkltcG9ydERvKX0sIHNvIHlvdSBjYW4ndCBpbXBvcnQgYW55IHZhbHVlcy5gLFxuXHR1bmV4cGVjdGVkQWZ0ZXJLaW5kOiBraW5kID0+XG5cdFx0YERpZCBub3QgZXhwZWN0IGFueXRoaW5nIGJldHdlZW4gJHtrdyhraW5kKX0gYW5kIGJsb2NrLmAsXG5cdHVuZXhwZWN0ZWRBZnRlck1ldGhvZDpcblx0XHRgRGlkIG5vdCBleHBlY3QgYW55dGhpbmcgYmV0d2VlbiAke2t3KEtleXdvcmRzLk1ldGhvZCl9IGFuZCBmdW5jdGlvbi5gLFxuXG5cdC8vIFZlcmlmeTpcblxuXHRhbWJpZ3VvdXNTSzpcblx0XHQnQ2FuXFwndCB0ZWxsIGlmIHRoaXMgaXMgYSBzdGF0ZW1lbnQuIFNvbWUgcGFydHMgYXJlIHN0YXRlbWVudHMgYnV0IG90aGVycyBhcmUgdmFsdWVzLicsXG5cdGFtYmlndW91c0ZvclNLOlxuXHRcdGBDYW4ndCB0ZWxsIGlmICR7a3coS2V5d29yZHMuRm9yKX0gaXMgYSBzdGF0ZW1lbnQuIGAgK1xuXHRcdGBTb21lICR7a3coS2V5d29yZHMuQnJlYWspfXMgaGF2ZSBhIHZhbHVlLCBvdGhlcnMgZG9uJ3QuYCxcblx0YmFkUmVnRXhwOiBzb3VyY2UgPT4ge1xuXHRcdHRyeSB7XG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXcgKi9cblx0XHRcdG5ldyBSZWdFeHAoc291cmNlKVxuXHRcdFx0Ly8gVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgZm9yIGJhZCByZWdleHAuLi5cblx0XHRcdGFzc2VydChmYWxzZSlcblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdHJldHVybiBlcnIubWVzc2FnZVxuXHRcdH1cblx0fSxcblx0YmxvY2tOZWVkc0NvbnRlbnQ6XG5cdFx0J1ZhbHVlIGJsb2NrIG11c3QgaGF2ZSBzb21lIGNvbnRlbnQuJyxcblx0YnJlYWtDYW50SGF2ZVZhbHVlOlxuXHRcdGAke2t3KEtleXdvcmRzLkJyZWFrKX0gd2l0aCB2YWx1ZSBuZWVkcyAke2t3KEtleXdvcmRzLkZvcil9IHRvIGJlIGluIGV4cHJlc3Npb24gcG9zaXRpb24uYCxcblx0YnJlYWtOZWVkc1ZhbHVlOlxuXHRcdGAke2t3KEtleXdvcmRzLkZvcil9IGluIGV4cHJlc3Npb24gcG9zaXRpb24gbXVzdCAke2t3KEtleXdvcmRzLkJyZWFrKX0gd2l0aCBhIHZhbHVlLmAsXG5cdGJyZWFrVmFsSW5Gb3JCYWc6XG5cdFx0YCR7a3coS2V5d29yZHMuQnJlYWspfSBpbiAke2t3KEtleXdvcmRzLkZvckJhZyl9IG1heSBub3QgaGF2ZSB2YWx1ZS5gLFxuXHRjYW50RGV0ZXJtaW5lTmFtZTpcblx0XHQnRXhwcmVzc2lvbiBtdXN0IGJlIHBsYWNlZCBpbiBhIHBvc2l0aW9uIHdoZXJlIG5hbWUgY2FuIGJlIGRldGVybWluZWQuJyxcblx0Y2FudEluZmVyQmxvY2tLaW5kOlxuXHRcdCdCbG9jayBoYXMgbWl4ZWQgYmFnL21hcC9vYmogZW50cmllcyDigJQgY2FuIG5vdCBpbmZlciB0eXBlLicsXG5cdGRvRnVuY0NhbnRIYXZlVHlwZTpcblx0XHQnRnVuY3Rpb24gd2l0aCByZXR1cm4gdHlwZSBtdXN0IHJldHVybiBzb21ldGhpbmcuJyxcblx0ZHVwbGljYXRlSW1wb3J0OiAobmFtZSwgcHJldkxvYykgPT5cblx0XHRgJHtjb2RlKG5hbWUpfSBhbHJlYWR5IGltcG9ydGVkIGF0ICR7cHJldkxvY31gLFxuXHRkdXBsaWNhdGVLZXk6IGtleSA9PlxuXHRcdGBEdXBsaWNhdGUga2V5ICR7a2V5fWAsXG5cdGR1cGxpY2F0ZUxvY2FsOiBuYW1lID0+XG5cdFx0YEEgbG9jYWwgJHtjb2RlKG5hbWUpfSBhbHJlYWR5IGV4aXN0cyBhbmQgY2FuJ3QgYmUgc2hhZG93ZWQuYCxcblx0ZWxzZVJlcXVpcmVzQ2F0Y2g6XG5cdFx0YCR7a3coS2V5d29yZHMuRWxzZSl9IG11c3QgY29tZSBhZnRlciBhICR7a3coS2V5d29yZHMuQ2F0Y2gpfS5gLFxuXHRleHBvcnROYW1lOlxuXHRcdCdNb2R1bGUgZXhwb3J0IG11c3QgaGF2ZSBhIGNvbnN0YW50IG5hbWUuJyxcblx0Zm9yQXN5bmNOZWVkc0FzeW5jOlxuXHRcdGAke2t3KEtleXdvcmRzLkZvckFzeW5jKX0gYXMgc3RhdGVtZW50IG11c3QgYmUgaW5zaWRlIGFuIGFzeW5jIGZ1bmN0aW9uLmAsXG5cdGxvZ2ljTmVlZHNBcmdzOlxuXHRcdCdMb2dpYyBleHByZXNzaW9uIG5lZWRzIGF0IGxlYXN0IDIgYXJndW1lbnRzLicsXG5cdG1pc3BsYWNlZEF3YWl0OlxuXHRcdGBDYW5ub3QgJHtrdyhLZXl3b3Jkcy5Bd2FpdCl9IG91dHNpZGUgb2YgYXN5bmMgZnVuY3Rpb24uYCxcblx0bWlzcGxhY2VkQnJlYWs6XG5cdFx0J05vdCBpbiBhIGxvb3AuJyxcblx0bWlzcGxhY2VkWWllbGQ6IGtpbmQgPT5cblx0XHRgQ2Fubm90ICR7a3coa2luZCl9IG91dHNpZGUgb2YgZ2VuZXJhdG9yIGZ1bmN0aW9uLmAsXG5cdG1pc3NpbmdMb2NhbDogbmFtZSA9PlxuXHRcdGBObyBzdWNoIGxvY2FsICR7Y29kZShuYW1lKX0uYCxcblx0bm9MYXp5Q2F0Y2g6XG5cdFx0J0NhdWdodCBlcnJvciBjYW4gbm90IGJlIGxhenkuJyxcblx0bm9MYXp5SXRlcmF0ZWU6XG5cdFx0J0l0ZXJhdGlvbiBlbGVtZW50IGNhbiBub3QgYmUgbGF6eS4nLFxuXHRvdmVycmlkZGVuQnVpbGRlcjogKG5hbWUsIGJ1aWx0aW5QYXRoKSA9PlxuXHRcdGBMb2NhbCAke2NvZGUodGhpcy5uYW1lKX0gb3ZlcnJpZGVzIGJ1aWx0aW4gZnJvbSAke2NvZGUoYnVpbHRpblBhdGgpfS5gLFxuXHRzdGF0ZW1lbnRBc1ZhbHVlOlxuXHRcdCdUaGlzIGNhbiBvbmx5IGJlIHVzZWQgYXMgYSBzdGF0ZW1lbnQsIGJ1dCBhcHBlYXJzIGluIGV4cHJlc3Npb24gY29udGV4dC4nLFxuXHRzdXBlckZvcmJpZGRlbjpcblx0XHRgQ2xhc3MgaGFzIG5vIHN1cGVyY2xhc3MsIHNvICR7a3coS2V5d29yZHMuU3VwZXIpfSBpcyBub3QgYWxsb3dlZC5gLFxuXHRzdXBlck11c3RCZVN0YXRlbWVudDpcblx0XHRgJHtrdyhLZXl3b3Jkcy5TdXBlcil9IGluIGNvbnN0cnVjdG9yIG11c3QgYXBwZWFyIGFzIGEgc3RhdGVtZW50LidgLFxuXHRzdXBlck5lZWRlZDpcblx0XHRgQ29uc3RydWN0b3IgbXVzdCBjb250YWluICR7a3coS2V5d29yZHMuU3VwZXIpfWAsXG5cdHN1cGVyTmVlZHNNZXRob2Q6XG5cdFx0YCR7a3coS2V5d29yZHMuU3VwZXIpfSBtdXN0IGJlIGluIGEgbWV0aG9kLmAsXG5cdHVudXNlZExvY2FsOiBuYW1lID0+XG5cdFx0YFVudXNlZCBsb2NhbCB2YXJpYWJsZSAke2NvZGUobmFtZSl9LmAsXG5cdHVzZWxlc3NFeGNlcHQ6XG5cdFx0YCR7a3coS2V5d29yZHMuRXhjZXB0KX0gbXVzdCBoYXZlICR7a3coS2V5d29yZHMuQ2F0Y2gpfSBvciAke2t3KEtleXdvcmRzLkZpbmFsbHkpfS5gLFxuXHR2YWx1ZUFzU3RhdGVtZW50OlxuXHRcdCdWYWx1ZSBhcHBlYXJzIGluIHN0YXRlbWVudCBjb250ZXh0LCBzbyBpdCBkb2VzIG5vdGhpbmcuJ1xufVxuIl19