if (typeof define !== 'function') var define = require('amdefine')(module);define(['exports', '../MsAst', '../Token', '../util', './context', './parseBlock', './parseCase', './parseExcept', './parseFor', './parseLine', './parseLocalDeclares', './parseQuote', './parse*', './Slice'], function (exports, _MsAst, _Token, _util, _context, _parseBlock, _parseCase, _parseExcept, _parseFor, _parseLine, _parseLocalDeclares, _parseQuote, _parse, _Slice) {
	'use strict';

	Object.defineProperty(exports, '__esModule', {
		value: true
	});

	var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _parseCase2 = _interopRequireDefault(_parseCase);

	var _parseExcept2 = _interopRequireDefault(_parseExcept);

	var _parseLine2 = _interopRequireDefault(_parseLine);

	var _parseLocalDeclares2 = _interopRequireDefault(_parseLocalDeclares);

	var _parseQuote2 = _interopRequireDefault(_parseQuote);

	var _Slice2 = _interopRequireDefault(_Slice);

	exports.default = tokens => {
		const head = tokens.head();
		const rest = tokens.tail();

		const noRest = () => (0, _context.checkEmpty)(rest, () => `Did not expect anything after ${ head }.`);

		// We only deal with mutable expressions here, otherwise we fall back to parseExpr.
		if (head instanceof _Token.Keyword) switch (head.kind) {
			case _Token.KW_Assert:case _Token.KW_AssertNot:
				return parseAssert(head.kind === _Token.KW_AssertNot, rest);
			case _Token.KW_ExceptDo:
				return (0, _parseExcept2.default)(_Token.KW_ExceptDo, rest);
			case _Token.KW_Break:
				noRest();
				return new _MsAst.Break(tokens.loc);
			case _Token.KW_BreakWithVal:
				return new _MsAst.BreakWithVal(tokens.loc, (0, _parse.parseExpr)(rest));
			case _Token.KW_CaseDo:
				return (0, _parseCase2.default)(false, false, rest);
			case _Token.KW_Debugger:
				noRest();
				return new _MsAst.SpecialDo(tokens.loc, _MsAst.SD_Debugger);
			case _Token.KW_Ellipsis:
				return new _MsAst.BagEntryMany(tokens.loc, (0, _parse.parseExpr)(rest));
			case _Token.KW_ForDo:
				return (0, _parseFor.parseForDo)(rest);
			case _Token.KW_Ignore:
				return parseIgnore(rest);
			case _Token.KW_IfDo:case _Token.KW_UnlessDo:
				{
					var _beforeAndBlock = (0, _parseBlock.beforeAndBlock)(rest);

					var _beforeAndBlock2 = _slicedToArray(_beforeAndBlock, 2);

					const before = _beforeAndBlock2[0];
					const block = _beforeAndBlock2[1];

					return new _MsAst.ConditionalDo(tokens.loc, (0, _parse.parseExpr)(before), (0, _parseBlock.parseBlockDo)(block), head.kind === _Token.KW_UnlessDo);
				}
			case _Token.KW_ObjAssign:
				return new _MsAst.BagEntry(tokens.loc, (0, _parse.parseExpr)(rest));
			case _Token.KW_Pass:
				noRest();
				return [];
			case _Token.KW_Region:
				return (0, _parseBlock.parseLinesFromBlock)(tokens);
			case _Token.KW_SuperDo:
				return new _MsAst.SuperCallDo(tokens.loc, (0, _parse.parseExprParts)(rest));
			case _Token.KW_SwitchDo:
				return (0, _parse.parseSwitch)(false, false, rest);
			case _Token.KW_Throw:
				return new _MsAst.Throw(tokens.loc, (0, _util.opIf)(!rest.isEmpty(), () => (0, _parse.parseExpr)(rest)));
			case _Token.KW_Name:
				if ((0, _Token.isKeyword)(_Token.KW_ObjAssign, rest.head())) {
					const r = rest.tail();
					const val = r.isEmpty() ? new _MsAst.SpecialVal(tokens.loc, _MsAst.SV_Name) : (0, _parse.parseExpr)(r);
					return _MsAst.ObjEntryComputed.name(tokens.loc, val);
				}
			// else fallthrough
			default:
			// fall through
		}

		return (0, _util.ifElse)(tokens.opSplitOnceWhere(isLineSplitKeyword), _ref => {
			let before = _ref.before;
			let at = _ref.at;
			let after = _ref.after;
			return parseAssignLike(before, at.kind, after, tokens.loc);
		}, () => (0, _parse.parseExpr)(tokens));
	};

	const parseLineOrLines = tokens => {
		const _ = (0, _parseLine2.default)(tokens);
		return _ instanceof Array ? _ : [_];
	};

	exports.parseLineOrLines = parseLineOrLines;
	const isLineSplitKeyword = token => {
		if (token instanceof _Token.Keyword) switch (token.kind) {
			case _Token.KW_Assign:case _Token.KW_AssignMutable:case _Token.KW_LocalMutate:
			case _Token.KW_MapEntry:case _Token.KW_ObjAssign:case _Token.KW_Yield:case _Token.KW_YieldTo:
				return true;
			default:
				return false;
		} else return false;
	},
	      parseAssignLike = (before, kind, after, loc) => {
		if (kind === _Token.KW_MapEntry) return new _MsAst.MapEntry(loc, (0, _parse.parseExpr)(before), (0, _parse.parseExpr)(after));

		//TODO: This code is kind of ugly.
		//It parses `x.y = z` and the like.
		if (before.size() === 1) {
			const token = before.head();
			if (token instanceof _Token.DotName) return parseMemberSet(_MsAst.LocalAccess.this(token.loc), token.name, kind, after, loc);
			if ((0, _Token.isGroup)(_Token.G_Space, token)) {
				const spaced = _Slice2.default.group(token);
				const dot = spaced.last();
				if (dot instanceof _Token.DotName) {
					_context.context.check(dot.nDots === 1, dot.loc, 'Must have only 1 `.`.');
					return parseMemberSet((0, _parse.parseSpaced)(spaced.rtail()), dot.name, kind, after, loc);
				}
			}

			if ((0, _Token.isGroup)(_Token.G_Quote, token)) return new _MsAst.ObjEntryComputed(loc, (0, _parseQuote2.default)(_Slice2.default.group(token)), (0, _parse.parseExpr)(after));
		}

		return kind === _Token.KW_LocalMutate ? parseLocalMutate(before, after, loc) : parseAssign(before, kind, after, loc);
	},
	      parseMemberSet = (object, name, kind, after, loc) => new _MsAst.MemberSet(loc, object, name, memberSetKind(kind), (0, _parse.parseExpr)(after)),
	      memberSetKind = keywordKind => {
		switch (keywordKind) {
			case _Token.KW_Assign:
				return _MsAst.MS_New;
			case _Token.KW_AssignMutable:
				return _MsAst.MS_NewMutable;
			case _Token.KW_LocalMutate:
				return _MsAst.MS_Mutate;
			//TODO: better error
			default:
				throw new Error();
		}
	},
	      parseLocalMutate = (localsTokens, valueTokens, loc) => {
		const locals = (0, _parseLocalDeclares.parseLocalDeclaresJustNames)(localsTokens);
		_context.context.check(locals.length === 1, loc, 'TODO: LocalDestructureMutate');
		const name = locals[0].name;
		const value = (0, _parse.parseExpr)(valueTokens);
		return new _MsAst.LocalMutate(loc, name, value);
	},
	      parseAssign = (localsTokens, kind, valueTokens, loc) => {
		const locals = (0, _parseLocalDeclares2.default)(localsTokens);
		const value = parseAssignValue(kind, valueTokens);

		const isYield = kind === _Token.KW_Yield || kind === _Token.KW_YieldTo;
		if ((0, _util.isEmpty)(locals)) {
			_context.context.check(isYield, localsTokens.loc, 'Assignment to nothing');
			return value;
		} else {
			if (isYield) for (const _ of locals) _context.context.check(!_.isLazy(), _.loc, 'Can not yield to lazy variable.');

			const isObjAssign = kind === _Token.KW_ObjAssign;

			if (kind === _Token.KW_AssignMutable) for (let _ of locals) {
				_context.context.check(!_.isLazy(), _.loc, 'Lazy local can not be mutable.');
				_.kind = _MsAst.LD_Mutable;
			}

			const wrap = _ => isObjAssign ? new _MsAst.ObjEntryAssign(loc, _) : _;

			if (locals.length === 1) {
				const assignee = locals[0];
				const assign = new _MsAst.AssignSingle(loc, assignee, value);
				return wrap(assign);
			} else {
				const kind = locals[0].kind;
				for (const _ of locals) _context.context.check(_.kind === kind, _.loc, 'All locals of destructuring assignment must be of the same kind.');
				return wrap(new _MsAst.AssignDestructure(loc, locals, value, kind));
			}
		}
	},
	      parseAssignValue = (kind, valueTokens) => {
		const value = (0, _parse.parseExpr)(valueTokens);
		switch (kind) {
			case _Token.KW_Yield:
				return new _MsAst.Yield(value.loc, value);
			case _Token.KW_YieldTo:
				return new _MsAst.YieldTo(value.loc, value);
			default:
				return value;
		}
	},
	      parseAssert = (negate, tokens) => {
		(0, _context.checkNonEmpty)(tokens, () => `Expected something after ${ (0, _Token.keywordName)(_Token.KW_Assert) }.`);

		var _ifElse = (0, _util.ifElse)(tokens.opSplitOnceWhere(_ => (0, _Token.isKeyword)(_Token.KW_Throw, _)), _ref2 => {
			let before = _ref2.before;
			let after = _ref2.after;
			return [before, (0, _parse.parseExpr)(after)];
		}, () => [tokens, null]);

		var _ifElse2 = _slicedToArray(_ifElse, 2);

		const condTokens = _ifElse2[0];
		const opThrown = _ifElse2[1];

		const parts = (0, _parse.parseExprParts)(condTokens);
		const cond = parts.length === 1 ? parts[0] : new _MsAst.Call(condTokens.loc, parts[0], (0, _util.tail)(parts));
		return new _MsAst.Assert(tokens.loc, negate, cond, opThrown);
	},
	      parseIgnore = tokens => {
		const ignored = tokens.map(_ => {
			if ((0, _Token.isKeyword)(_Token.KW_Focus, _)) return '_';else {
				_context.context.check(_ instanceof _Token.Name, _.loc, () => `Expected local name, not ${ _ }.`);
				return _.name;
			}
		});
		return new _MsAst.Ignore(tokens.loc, ignored);
	};
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhcnNlTGluZS5qcyIsInByaXZhdGUvcGFyc2UvcGFyc2VMaW5lLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttQkNxQmUsTUFBTSxJQUFJO0FBQ3hCLFFBQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQTtBQUMxQixRQUFNLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUE7O0FBRTFCLFFBQU0sTUFBTSxHQUFHLE1BQ2QsYUFoQk0sVUFBVSxFQWdCTCxJQUFJLEVBQUUsTUFBTSxDQUFDLDhCQUE4QixHQUFFLElBQUksRUFBQyxDQUFDLENBQUMsQ0FBQyxDQUFBOzs7QUFHakUsTUFBSSxJQUFJLG1CQXpCOEMsT0FBTyxBQXlCbEMsRUFDMUIsUUFBUSxJQUFJLENBQUMsSUFBSTtBQUNoQixlQTNCMEUsU0FBUyxDQTJCcEUsQUFBQyxZQTFCbEIsWUFBWTtBQTJCVCxXQUFPLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxZQTNCL0IsWUFBWSxBQTJCb0MsRUFBRSxJQUFJLENBQUMsQ0FBQTtBQUFBLEFBQ3JELGVBM0JXLFdBQVc7QUE0QnJCLFdBQU8sa0NBNUJHLFdBQVcsRUE0QlcsSUFBSSxDQUFDLENBQUE7QUFBQSxBQUN0QyxlQTlCeUMsUUFBUTtBQStCaEQsVUFBTSxFQUFFLENBQUE7QUFDUixXQUFPLFdBckM4RCxLQUFLLENBcUN6RCxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUE7QUFBQSxBQUM3QixlQWpDbUQsZUFBZTtBQWtDakUsV0FBTyxXQXZDcUUsWUFBWSxDQXVDaEUsTUFBTSxDQUFDLEdBQUcsRUFBRSxXQXJCaEMsU0FBUyxFQXFCaUMsSUFBSSxDQUFDLENBQUMsQ0FBQTtBQUFBLEFBQ3JELGVBbkNvRSxTQUFTO0FBb0M1RSxXQUFPLHlCQUFVLEtBQUssRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUE7QUFBQSxBQUNyQyxlQXJDK0UsV0FBVztBQXNDekYs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QyxDQUFDLENBQUMsQ0FBQyxDQUFBO0FBQy9FLFdBQU8sQ0FBQyxDQUFDLElBQUksQ0FBQTtJQUNiO0dBQ0QsQ0FBQyxDQUFBO0FBQ0YsU0FBTyxXQWpPTyxNQUFNLENBaU9GLE1BQU0sQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLENBQUE7RUFDdEMsQ0FBQSIsImZpbGUiOiJwcml2YXRlL3BhcnNlL3BhcnNlTGluZS5qcyIsInNvdXJjZXNDb250ZW50IjpbbnVsbCwiaW1wb3J0IHtBc3NlcnQsIEFzc2lnblNpbmdsZSwgQXNzaWduRGVzdHJ1Y3R1cmUsIEJhZ0VudHJ5LCBCYWdFbnRyeU1hbnksIEJyZWFrLCBCcmVha1dpdGhWYWwsIENhbGwsXG5cdENvbmRpdGlvbmFsRG8sIElnbm9yZSwgTERfTXV0YWJsZSwgTG9jYWxBY2Nlc3MsIExvY2FsTXV0YXRlLCBNYXBFbnRyeSwgTWVtYmVyU2V0LFxuXHRNU19OZXcsIE1TX05ld011dGFibGUsIE1TX011dGF0ZSwgT2JqRW50cnlBc3NpZ24sIE9iakVudHJ5Q29tcHV0ZWQsIFNEX0RlYnVnZ2VyLCBTcGVjaWFsRG8sXG5cdFNwZWNpYWxWYWwsIFN1cGVyQ2FsbERvLCBTVl9OYW1lLCBUaHJvdywgWWllbGQsIFlpZWxkVG99IGZyb20gJy4uL01zQXN0J1xuaW1wb3J0IHtEb3ROYW1lLCBHX1F1b3RlLCBHX1NwYWNlLCBpc0dyb3VwLCBpc0tleXdvcmQsIEtleXdvcmQsIGtleXdvcmROYW1lLCBLV19Bc3NlcnQsXG5cdEtXX0Fzc2VydE5vdCwgS1dfQXNzaWduLCBLV19Bc3NpZ25NdXRhYmxlLCBLV19CcmVhaywgS1dfQnJlYWtXaXRoVmFsLCBLV19DYXNlRG8sIEtXX0RlYnVnZ2VyLFxuXHRLV19FbGxpcHNpcywgS1dfRXhjZXB0RG8sIEtXX0ZvY3VzLCBLV19Gb3JEbywgS1dfSWZEbywgS1dfSWdub3JlLCBLV19Mb2NhbE11dGF0ZSwgS1dfTWFwRW50cnksXG5cdEtXX05hbWUsIEtXX09iakFzc2lnbiwgS1dfUGFzcywgS1dfUmVnaW9uLCBLV19TdXBlckRvLCBLV19Td2l0Y2hEbywgS1dfVGhyb3csIEtXX1VubGVzc0RvLFxuXHRLV19ZaWVsZCwgS1dfWWllbGRUbywgTmFtZX0gZnJvbSAnLi4vVG9rZW4nXG5pbXBvcnQge2lmRWxzZSwgaXNFbXB0eSwgb3BJZiwgdGFpbH0gZnJvbSAnLi4vdXRpbCdcbmltcG9ydCB7Y2hlY2tFbXB0eSwgY2hlY2tOb25FbXB0eSwgY29udGV4dH0gZnJvbSAnLi9jb250ZXh0J1xuaW1wb3J0IHtiZWZvcmVBbmRCbG9jaywgcGFyc2VCbG9ja0RvLCBwYXJzZUxpbmVzRnJvbUJsb2NrfSBmcm9tICcuL3BhcnNlQmxvY2snXG5pbXBvcnQgcGFyc2VDYXNlIGZyb20gJy4vcGFyc2VDYXNlJ1xuaW1wb3J0IHBhcnNlRXhjZXB0IGZyb20gJy4vcGFyc2VFeGNlcHQnXG5pbXBvcnQge3BhcnNlRm9yRG99IGZyb20gJy4vcGFyc2VGb3InXG5pbXBvcnQgcGFyc2VMaW5lIGZyb20gJy4vcGFyc2VMaW5lJ1xuaW1wb3J0IHBhcnNlTG9jYWxEZWNsYXJlcywge3BhcnNlTG9jYWxEZWNsYXJlc0p1c3ROYW1lc30gZnJvbSAnLi9wYXJzZUxvY2FsRGVjbGFyZXMnXG5pbXBvcnQgcGFyc2VRdW90ZSBmcm9tICcuL3BhcnNlUXVvdGUnXG5pbXBvcnQge3BhcnNlRXhwciwgcGFyc2VFeHByUGFydHMsIHBhcnNlU3BhY2VkLCBwYXJzZVN3aXRjaH0gZnJvbSAnLi9wYXJzZSonXG5pbXBvcnQgU2xpY2UgZnJvbSAnLi9TbGljZSdcblxuZXhwb3J0IGRlZmF1bHQgdG9rZW5zID0+IHtcblx0Y29uc3QgaGVhZCA9IHRva2Vucy5oZWFkKClcblx0Y29uc3QgcmVzdCA9IHRva2Vucy50YWlsKClcblxuXHRjb25zdCBub1Jlc3QgPSAoKSA9PlxuXHRcdGNoZWNrRW1wdHkocmVzdCwgKCkgPT4gYERpZCBub3QgZXhwZWN0IGFueXRoaW5nIGFmdGVyICR7aGVhZH0uYClcblxuXHQvLyBXZSBvbmx5IGRlYWwgd2l0aCBtdXRhYmxlIGV4cHJlc3Npb25zIGhlcmUsIG90aGVyd2lzZSB3ZSBmYWxsIGJhY2sgdG8gcGFyc2VFeHByLlxuXHRpZiAoaGVhZCBpbnN0YW5jZW9mIEtleXdvcmQpXG5cdFx0c3dpdGNoIChoZWFkLmtpbmQpIHtcblx0XHRcdGNhc2UgS1dfQXNzZXJ0OiBjYXNlIEtXX0Fzc2VydE5vdDpcblx0XHRcdFx0cmV0dXJuIHBhcnNlQXNzZXJ0KGhlYWQua2luZCA9PT0gS1dfQXNzZXJ0Tm90LCByZXN0KVxuXHRcdFx0Y2FzZSBLV19FeGNlcHREbzpcblx0XHRcdFx0cmV0dXJuIHBhcnNlRXhjZXB0KEtXX0V4Y2VwdERvLCByZXN0KVxuXHRcdFx0Y2FzZSBLV19CcmVhazpcblx0XHRcdFx0bm9SZXN0KClcblx0XHRcdFx0cmV0dXJuIG5ldyBCcmVhayh0b2tlbnMubG9jKVxuXHRcdFx0Y2FzZSBLV19CcmVha1dpdGhWYWw6XG5cdFx0XHRcdHJldHVybiBuZXcgQnJlYWtXaXRoVmFsKHRva2Vucy5sb2MsIHBhcnNlRXhwcihyZXN0KSlcblx0XHRcdGNhc2UgS1dfQ2FzZURvOlxuXHRcdFx0XHRyZXR1cm4gcGFyc2VDYXNlKGZhbHNlLCBmYWxzZSwgcmVzdClcblx0XHRcdGNhc2UgS1dfRGVidWdnZXI6XG5cdFx0XHRcdG5vUmVzdCgpXG5cdFx0XHRcdHJldHVybiBuZXcgU3BlY2lhbERvKHRva2Vucy5sb2MsIFNEX0RlYnVnZ2VyKVxuXHRcdFx0Y2FzZSBLV19FbGxpcHNpczpcblx0XHRcdFx0cmV0dXJuIG5ldyBCYWdFbnRyeU1hbnkodG9rZW5zLmxvYywgcGFyc2VFeHByKHJlc3QpKVxuXHRcdFx0Y2FzZSBLV19Gb3JEbzpcblx0XHRcdFx0cmV0dXJuIHBhcnNlRm9yRG8ocmVzdClcblx0XHRcdGNhc2UgS1dfSWdub3JlOlxuXHRcdFx0XHRyZXR1cm4gcGFyc2VJZ25vcmUocmVzdClcblx0XHRcdGNhc2UgS1dfSWZEbzogY2FzZSBLV19Vbmxlc3NEbzoge1xuXHRcdFx0XHRjb25zdCBbYmVmb3JlLCBibG9ja10gPSBiZWZvcmVBbmRCbG9jayhyZXN0KVxuXHRcdFx0XHRyZXR1cm4gbmV3IENvbmRpdGlvbmFsRG8odG9rZW5zLmxvYyxcblx0XHRcdFx0XHRwYXJzZUV4cHIoYmVmb3JlKSxcblx0XHRcdFx0XHRwYXJzZUJsb2NrRG8oYmxvY2spLFxuXHRcdFx0XHRcdGhlYWQua2luZCA9PT0gS1dfVW5sZXNzRG8pXG5cdFx0XHR9XG5cdFx0XHRjYXNlIEtXX09iakFzc2lnbjpcblx0XHRcdFx0cmV0dXJuIG5ldyBCYWdFbnRyeSh0b2tlbnMubG9jLCBwYXJzZUV4cHIocmVzdCkpXG5cdFx0XHRjYXNlIEtXX1Bhc3M6XG5cdFx0XHRcdG5vUmVzdCgpXG5cdFx0XHRcdHJldHVybiBbXVxuXHRcdFx0Y2FzZSBLV19SZWdpb246XG5cdFx0XHRcdHJldHVybiBwYXJzZUxpbmVzRnJvbUJsb2NrKHRva2Vucylcblx0XHRcdGNhc2UgS1dfU3VwZXJEbzpcblx0XHRcdFx0cmV0dXJuIG5ldyBTdXBlckNhbGxEbyh0b2tlbnMubG9jLCBwYXJzZUV4cHJQYXJ0cyhyZXN0KSlcblx0XHRcdGNhc2UgS1dfU3dpdGNoRG86XG5cdFx0XHRcdHJldHVybiBwYXJzZVN3aXRjaChmYWxzZSwgZmFsc2UsIHJlc3QpXG5cdFx0XHRjYXNlIEtXX1Rocm93OlxuXHRcdFx0XHRyZXR1cm4gbmV3IFRocm93KHRva2Vucy5sb2MsIG9wSWYoIXJlc3QuaXNFbXB0eSgpLCAoKSA9PiBwYXJzZUV4cHIocmVzdCkpKVxuXHRcdFx0Y2FzZSBLV19OYW1lOlxuXHRcdFx0XHRpZiAoaXNLZXl3b3JkKEtXX09iakFzc2lnbiwgcmVzdC5oZWFkKCkpKSB7XG5cdFx0XHRcdFx0Y29uc3QgciA9IHJlc3QudGFpbCgpXG5cdFx0XHRcdFx0Y29uc3QgdmFsID0gci5pc0VtcHR5KCkgPyBuZXcgU3BlY2lhbFZhbCh0b2tlbnMubG9jLCBTVl9OYW1lKSA6IHBhcnNlRXhwcihyKVxuXHRcdFx0XHRcdHJldHVybiBPYmpFbnRyeUNvbXB1dGVkLm5hbWUodG9rZW5zLmxvYywgdmFsKVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGVsc2UgZmFsbHRocm91Z2hcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdC8vIGZhbGwgdGhyb3VnaFxuXHRcdH1cblxuXHRyZXR1cm4gaWZFbHNlKHRva2Vucy5vcFNwbGl0T25jZVdoZXJlKGlzTGluZVNwbGl0S2V5d29yZCksXG5cdFx0KHtiZWZvcmUsIGF0LCBhZnRlcn0pID0+IHBhcnNlQXNzaWduTGlrZShiZWZvcmUsIGF0LmtpbmQsIGFmdGVyLCB0b2tlbnMubG9jKSxcblx0XHQoKSA9PiBwYXJzZUV4cHIodG9rZW5zKSlcbn1cblxuZXhwb3J0IGNvbnN0IHBhcnNlTGluZU9yTGluZXMgPSB0b2tlbnMgPT4ge1xuXHRjb25zdCBfID0gcGFyc2VMaW5lKHRva2Vucylcblx0cmV0dXJuIF8gaW5zdGFuY2VvZiBBcnJheSA/IF8gOiBbX11cbn1cblxuY29uc3Rcblx0aXNMaW5lU3BsaXRLZXl3b3JkID0gdG9rZW4gPT4ge1xuXHRcdGlmICh0b2tlbiBpbnN0YW5jZW9mIEtleXdvcmQpXG5cdFx0XHRzd2l0Y2ggKHRva2VuLmtpbmQpIHtcblx0XHRcdFx0Y2FzZSBLV19Bc3NpZ246IGNhc2UgS1dfQXNzaWduTXV0YWJsZTogY2FzZSBLV19Mb2NhbE11dGF0ZTpcblx0XHRcdFx0Y2FzZSBLV19NYXBFbnRyeTogY2FzZSBLV19PYmpBc3NpZ246IGNhc2UgS1dfWWllbGQ6IGNhc2UgS1dfWWllbGRUbzpcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHJldHVybiBmYWxzZVxuXHRcdFx0fVxuXHRcdGVsc2Vcblx0XHRcdHJldHVybiBmYWxzZVxuXHR9LFxuXG5cdHBhcnNlQXNzaWduTGlrZSA9IChiZWZvcmUsIGtpbmQsIGFmdGVyLCBsb2MpID0+IHtcblx0XHRpZiAoa2luZCA9PT0gS1dfTWFwRW50cnkpXG5cdFx0XHRyZXR1cm4gbmV3IE1hcEVudHJ5KGxvYywgcGFyc2VFeHByKGJlZm9yZSksIHBhcnNlRXhwcihhZnRlcikpXG5cblx0XHQvL1RPRE86IFRoaXMgY29kZSBpcyBraW5kIG9mIHVnbHkuXG5cdFx0Ly9JdCBwYXJzZXMgYHgueSA9IHpgIGFuZCB0aGUgbGlrZS5cblx0XHRpZiAoYmVmb3JlLnNpemUoKSA9PT0gMSkge1xuXHRcdFx0Y29uc3QgdG9rZW4gPSBiZWZvcmUuaGVhZCgpXG5cdFx0XHRpZiAodG9rZW4gaW5zdGFuY2VvZiBEb3ROYW1lKVxuXHRcdFx0XHRyZXR1cm4gcGFyc2VNZW1iZXJTZXQoTG9jYWxBY2Nlc3MudGhpcyh0b2tlbi5sb2MpLCB0b2tlbi5uYW1lLCBraW5kLCBhZnRlciwgbG9jKVxuXHRcdFx0aWYgKGlzR3JvdXAoR19TcGFjZSwgdG9rZW4pKSB7XG5cdFx0XHRcdGNvbnN0IHNwYWNlZCA9IFNsaWNlLmdyb3VwKHRva2VuKVxuXHRcdFx0XHRjb25zdCBkb3QgPSBzcGFjZWQubGFzdCgpXG5cdFx0XHRcdGlmIChkb3QgaW5zdGFuY2VvZiBEb3ROYW1lKSB7XG5cdFx0XHRcdFx0Y29udGV4dC5jaGVjayhkb3QubkRvdHMgPT09IDEsIGRvdC5sb2MsICdNdXN0IGhhdmUgb25seSAxIGAuYC4nKVxuXHRcdFx0XHRcdHJldHVybiBwYXJzZU1lbWJlclNldChwYXJzZVNwYWNlZChzcGFjZWQucnRhaWwoKSksIGRvdC5uYW1lLCBraW5kLCBhZnRlciwgbG9jKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpc0dyb3VwKEdfUXVvdGUsIHRva2VuKSlcblx0XHRcdFx0cmV0dXJuIG5ldyBPYmpFbnRyeUNvbXB1dGVkKGxvYywgcGFyc2VRdW90ZShTbGljZS5ncm91cCh0b2tlbikpLCBwYXJzZUV4cHIoYWZ0ZXIpKVxuXHRcdH1cblxuXG5cdFx0cmV0dXJuIGtpbmQgPT09IEtXX0xvY2FsTXV0YXRlID9cblx0XHRcdHBhcnNlTG9jYWxNdXRhdGUoYmVmb3JlLCBhZnRlciwgbG9jKSA6XG5cdFx0XHRwYXJzZUFzc2lnbihiZWZvcmUsIGtpbmQsIGFmdGVyLCBsb2MpXG5cdH0sXG5cblx0cGFyc2VNZW1iZXJTZXQgPSAob2JqZWN0LCBuYW1lLCBraW5kLCBhZnRlciwgbG9jKSA9PlxuXHRcdG5ldyBNZW1iZXJTZXQobG9jLCBvYmplY3QsIG5hbWUsIG1lbWJlclNldEtpbmQoa2luZCksIHBhcnNlRXhwcihhZnRlcikpLFxuXHRtZW1iZXJTZXRLaW5kID0ga2V5d29yZEtpbmQgPT4ge1xuXHRcdHN3aXRjaCAoa2V5d29yZEtpbmQpIHtcblx0XHRcdGNhc2UgS1dfQXNzaWduOiByZXR1cm4gTVNfTmV3XG5cdFx0XHRjYXNlIEtXX0Fzc2lnbk11dGFibGU6IHJldHVybiBNU19OZXdNdXRhYmxlXG5cdFx0XHRjYXNlIEtXX0xvY2FsTXV0YXRlOiByZXR1cm4gTVNfTXV0YXRlXG5cdFx0XHQvL1RPRE86IGJldHRlciBlcnJvclxuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKClcblx0XHR9XG5cdH0sXG5cblx0cGFyc2VMb2NhbE11dGF0ZSA9IChsb2NhbHNUb2tlbnMsIHZhbHVlVG9rZW5zLCBsb2MpID0+IHtcblx0XHRjb25zdCBsb2NhbHMgPSBwYXJzZUxvY2FsRGVjbGFyZXNKdXN0TmFtZXMobG9jYWxzVG9rZW5zKVxuXHRcdGNvbnRleHQuY2hlY2sobG9jYWxzLmxlbmd0aCA9PT0gMSwgbG9jLCAnVE9ETzogTG9jYWxEZXN0cnVjdHVyZU11dGF0ZScpXG5cdFx0Y29uc3QgbmFtZSA9IGxvY2Fsc1swXS5uYW1lXG5cdFx0Y29uc3QgdmFsdWUgPSBwYXJzZUV4cHIodmFsdWVUb2tlbnMpXG5cdFx0cmV0dXJuIG5ldyBMb2NhbE11dGF0ZShsb2MsIG5hbWUsIHZhbHVlKVxuXHR9LFxuXG5cdHBhcnNlQXNzaWduID0gKGxvY2Fsc1Rva2Vucywga2luZCwgdmFsdWVUb2tlbnMsIGxvYykgPT4ge1xuXHRcdGNvbnN0IGxvY2FscyA9IHBhcnNlTG9jYWxEZWNsYXJlcyhsb2NhbHNUb2tlbnMpXG5cdFx0Y29uc3QgdmFsdWUgPSBwYXJzZUFzc2lnblZhbHVlKGtpbmQsIHZhbHVlVG9rZW5zKVxuXG5cdFx0Y29uc3QgaXNZaWVsZCA9IGtpbmQgPT09IEtXX1lpZWxkIHx8IGtpbmQgPT09IEtXX1lpZWxkVG9cblx0XHRpZiAoaXNFbXB0eShsb2NhbHMpKSB7XG5cdFx0XHRjb250ZXh0LmNoZWNrKGlzWWllbGQsIGxvY2Fsc1Rva2Vucy5sb2MsICdBc3NpZ25tZW50IHRvIG5vdGhpbmcnKVxuXHRcdFx0cmV0dXJuIHZhbHVlXG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChpc1lpZWxkKVxuXHRcdFx0XHRmb3IgKGNvbnN0IF8gb2YgbG9jYWxzKVxuXHRcdFx0XHRcdGNvbnRleHQuY2hlY2soIV8uaXNMYXp5KCksIF8ubG9jLCAnQ2FuIG5vdCB5aWVsZCB0byBsYXp5IHZhcmlhYmxlLicpXG5cblx0XHRcdGNvbnN0IGlzT2JqQXNzaWduID0ga2luZCA9PT0gS1dfT2JqQXNzaWduXG5cblx0XHRcdGlmIChraW5kID09PSBLV19Bc3NpZ25NdXRhYmxlKVxuXHRcdFx0XHRmb3IgKGxldCBfIG9mIGxvY2Fscykge1xuXHRcdFx0XHRcdGNvbnRleHQuY2hlY2soIV8uaXNMYXp5KCksIF8ubG9jLCAnTGF6eSBsb2NhbCBjYW4gbm90IGJlIG11dGFibGUuJylcblx0XHRcdFx0XHRfLmtpbmQgPSBMRF9NdXRhYmxlXG5cdFx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgd3JhcCA9IF8gPT4gaXNPYmpBc3NpZ24gPyBuZXcgT2JqRW50cnlBc3NpZ24obG9jLCBfKSA6IF9cblxuXHRcdFx0aWYgKGxvY2Fscy5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0Y29uc3QgYXNzaWduZWUgPSBsb2NhbHNbMF1cblx0XHRcdFx0Y29uc3QgYXNzaWduID0gbmV3IEFzc2lnblNpbmdsZShsb2MsIGFzc2lnbmVlLCB2YWx1ZSlcblx0XHRcdFx0cmV0dXJuIHdyYXAoYXNzaWduKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3Qga2luZCA9IGxvY2Fsc1swXS5raW5kXG5cdFx0XHRcdGZvciAoY29uc3QgXyBvZiBsb2NhbHMpXG5cdFx0XHRcdFx0Y29udGV4dC5jaGVjayhfLmtpbmQgPT09IGtpbmQsIF8ubG9jLFxuXHRcdFx0XHRcdFx0J0FsbCBsb2NhbHMgb2YgZGVzdHJ1Y3R1cmluZyBhc3NpZ25tZW50IG11c3QgYmUgb2YgdGhlIHNhbWUga2luZC4nKVxuXHRcdFx0XHRyZXR1cm4gd3JhcChuZXcgQXNzaWduRGVzdHJ1Y3R1cmUobG9jLCBsb2NhbHMsIHZhbHVlLCBraW5kKSlcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cGFyc2VBc3NpZ25WYWx1ZSA9IChraW5kLCB2YWx1ZVRva2VucykgPT4ge1xuXHRcdGNvbnN0IHZhbHVlID0gcGFyc2VFeHByKHZhbHVlVG9rZW5zKVxuXHRcdHN3aXRjaCAoa2luZCkge1xuXHRcdFx0Y2FzZSBLV19ZaWVsZDpcblx0XHRcdFx0cmV0dXJuIG5ldyBZaWVsZCh2YWx1ZS5sb2MsIHZhbHVlKVxuXHRcdFx0Y2FzZSBLV19ZaWVsZFRvOlxuXHRcdFx0XHRyZXR1cm4gbmV3IFlpZWxkVG8odmFsdWUubG9jLCB2YWx1ZSlcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdH1cblx0fSxcblxuXHRwYXJzZUFzc2VydCA9IChuZWdhdGUsIHRva2VucykgPT4ge1xuXHRcdGNoZWNrTm9uRW1wdHkodG9rZW5zLCAoKSA9PiBgRXhwZWN0ZWQgc29tZXRoaW5nIGFmdGVyICR7a2V5d29yZE5hbWUoS1dfQXNzZXJ0KX0uYClcblxuXHRcdGNvbnN0IFtjb25kVG9rZW5zLCBvcFRocm93bl0gPVxuXHRcdFx0aWZFbHNlKHRva2Vucy5vcFNwbGl0T25jZVdoZXJlKF8gPT4gaXNLZXl3b3JkKEtXX1Rocm93LCBfKSksXG5cdFx0XHRcdCh7YmVmb3JlLCBhZnRlcn0pID0+IFtiZWZvcmUsIHBhcnNlRXhwcihhZnRlcildLFxuXHRcdFx0XHQoKSA9PiBbdG9rZW5zLCBudWxsXSlcblxuXHRcdGNvbnN0IHBhcnRzID0gcGFyc2VFeHByUGFydHMoY29uZFRva2Vucylcblx0XHRjb25zdCBjb25kID0gcGFydHMubGVuZ3RoID09PSAxID8gcGFydHNbMF0gOiBuZXcgQ2FsbChjb25kVG9rZW5zLmxvYywgcGFydHNbMF0sIHRhaWwocGFydHMpKVxuXHRcdHJldHVybiBuZXcgQXNzZXJ0KHRva2Vucy5sb2MsIG5lZ2F0ZSwgY29uZCwgb3BUaHJvd24pXG5cdH0sXG5cblx0cGFyc2VJZ25vcmUgPSB0b2tlbnMgPT4ge1xuXHRcdGNvbnN0IGlnbm9yZWQgPSB0b2tlbnMubWFwKF8gPT4ge1xuXHRcdFx0aWYgKGlzS2V5d29yZChLV19Gb2N1cywgXykpXG5cdFx0XHRcdHJldHVybiAnXydcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRjb250ZXh0LmNoZWNrKF8gaW5zdGFuY2VvZiBOYW1lLCBfLmxvYywgKCkgPT4gYEV4cGVjdGVkIGxvY2FsIG5hbWUsIG5vdCAke199LmApXG5cdFx0XHRcdHJldHVybiBfLm5hbWVcblx0XHRcdH1cblx0XHR9KVxuXHRcdHJldHVybiBuZXcgSWdub3JlKHRva2Vucy5sb2MsIGlnbm9yZWQpXG5cdH0iXSwic291cmNlUm9vdCI6Ii9zcmMifQ==
