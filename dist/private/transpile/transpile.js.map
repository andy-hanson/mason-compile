{"version":3,"sources":["private/transpile/transpile.js","private/transpile/transpile.ts"],"names":[],"mappings":"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","file":"private/transpile/transpile.js","sourcesContent":["(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", 'esast/lib/ast', 'esast-create-util/lib/util', 'op/Op', '../MsAst', '../MsAst', '../util', './ast-constants', './context', './transpileAssert', './transpileBlock', './transpileCase', './transpileClass', './transpileExcept', './transpileFor', './transpileFun', './transpileModule', './transpileQuotePlain', './transpileSpecial', './transpileSwitch', './transpileTrait', './util'], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    var ast_1 = require('esast/lib/ast');\n    var util_1 = require('esast-create-util/lib/util');\n    var Op_1 = require('op/Op');\n    var MsAst_1 = require('../MsAst');\n    var MsAstTypes = require('../MsAst');\n    var util_2 = require('../util');\n    var ast_constants_1 = require('./ast-constants');\n    var context_1 = require('./context');\n    var transpileAssert_1 = require('./transpileAssert');\n    var transpileBlock_1 = require('./transpileBlock');\n    var transpileCase_1 = require('./transpileCase');\n    var transpileClass_1 = require('./transpileClass');\n    var transpileExcept_1 = require('./transpileExcept');\n    var transpileFor_1 = require('./transpileFor');\n    var transpileFun_1 = require('./transpileFun');\n    var transpileModule_1 = require('./transpileModule');\n    var transpileQuotePlain_1 = require('./transpileQuotePlain');\n    var transpileSpecial_1 = require('./transpileSpecial');\n    var transpileSwitch_1 = require('./transpileSwitch');\n    var transpileTrait_1 = require('./transpileTrait');\n    var util_3 = require('./util');\n    function transpile(moduleExpression, verifyResults) {\n        context_1.setup(verifyResults);\n        const res = util_3.t0(moduleExpression);\n        context_1.tearDown();\n        return res;\n    }\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = transpile;\n    util_2.implementMany(MsAstTypes, 'transpile', {\n        Assert: transpileAssert_1.default,\n        AssignSingle(valWrap) {\n            const val = valWrap === undefined ? util_3.t0(this.value) : valWrap(util_3.t0(this.value));\n            return new ast_1.VariableDeclaration('let', [util_3.makeDeclarator(this.assignee, val, false)]);\n        },\n        AssignDestructure() {\n            return new ast_1.VariableDeclaration('let', util_3.makeDestructureDeclarators(this.assignees, this.kind === 1, util_3.t0(this.value), false));\n        },\n        Await() {\n            return new ast_1.YieldExpression(util_3.t0(this.value), false);\n        },\n        BagEntry() {\n            return util_3.msCall(this.isMany ? 'addMany' : 'add', ast_constants_1.IdBuilt, util_3.t0(this.value));\n        },\n        BagSimple() {\n            return new ast_1.ArrayExpression(this.parts.map(util_3.t0));\n        },\n        Block: transpileBlock_1.default,\n        BlockWrap() {\n            return util_3.blockWrap(util_3.t0(this.block));\n        },\n        Break: transpileFor_1.transpileBreak,\n        Call() {\n            return new ast_1.CallExpression(util_3.t0(this.called), this.args.map(util_3.t0));\n        },\n        Case: transpileCase_1.default,\n        CasePart: transpileCase_1.transpileCasePart,\n        Catch: transpileExcept_1.transpileCatch,\n        Class: transpileClass_1.default,\n        Cond() {\n            return new ast_1.ConditionalExpression(util_3.t0(this.test), util_3.t0(this.ifTrue), util_3.t0(this.ifFalse));\n        },\n        Conditional() {\n            const test = util_3.t0(this.test);\n            if (context_1.verifyResults.isStatement(this))\n                return new ast_1.IfStatement(this.isUnless ? new ast_1.UnaryExpression('!', test) : test, util_3.t0(this.result));\n            else {\n                const result = util_3.msCall('some', util_3.blockWrapIfBlock(this.result));\n                const none = util_3.msMember('None');\n                const [then, _else] = this.isUnless ? [none, result] : [result, none];\n                return new ast_1.ConditionalExpression(test, then, _else);\n            }\n        },\n        Constructor: transpileClass_1.transpileConstructor,\n        Del() {\n            return util_3.msCall('del', util_3.t0(this.subbed), ...this.args.map(util_3.t0));\n        },\n        Except: transpileExcept_1.default,\n        For: transpileFor_1.transpileFor,\n        ForAsync: transpileFor_1.transpileForAsync,\n        ForBag: transpileFor_1.transpileForBag,\n        Fun: transpileFun_1.default,\n        GetterFun() {\n            return util_3.focusFun(util_3.memberStringOrVal(ast_constants_1.IdFocus, this.name));\n        },\n        Ignore() {\n            return [];\n        },\n        InstanceOf() {\n            return util_3.msCall('hasInstance', util_3.t0(this.type), util_3.t0(this.instance));\n        },\n        Lazy() {\n            return util_3.lazyWrap(util_3.t0(this.value));\n        },\n        NumberLiteral() {\n            const value = Number(this.value);\n            const lit = new ast_1.LiteralNumber(Math.abs(value));\n            const isPositive = value >= 0 && 1 / value !== -Infinity;\n            return isPositive ? lit : new ast_1.UnaryExpression('-', lit);\n        },\n        LocalAccess() {\n            if (this.name === 'this')\n                return ast_constants_1.IdLexicalThis;\n            else {\n                const ld = context_1.verifyResults.localDeclareForAccess(this);\n                return ld === undefined ? util_1.identifier(this.name) : util_3.accessLocalDeclare(ld);\n            }\n        },\n        LocalDeclare() {\n            return new ast_1.Identifier(util_3.idForDeclareCached(this).name);\n        },\n        LocalMutate() {\n            return new ast_1.ExpressionStatement(new ast_1.AssignmentExpression('=', util_1.identifier(this.name), util_3.t0(this.value)));\n        },\n        Logic() {\n            return util_2.tail(this.args).reduce((expr, arg) => new ast_1.LogicalExpression(this.kind === 0 ? '&&' : '||', expr, util_3.t0(arg)), util_3.t0(this.args[0]));\n        },\n        MapEntry() {\n            return new ast_1.ExpressionStatement(util_3.msCall('setSub', ast_constants_1.IdBuilt, util_3.t0(this.key), util_3.t0(this.val)));\n        },\n        Member() {\n            return util_3.memberStringOrVal(util_3.t0(this.object), this.name);\n        },\n        MemberFun() {\n            const name = util_3.transpileName(this.name);\n            return Op_1.caseOp(this.opObject, _ => util_3.msCall('methodBound', util_3.t0(_), name), () => util_3.msCall('methodUnbound', name));\n        },\n        MemberSet() {\n            const obj = util_3.t0(this.object);\n            const val = util_3.maybeWrapInCheckInstance(util_3.t0(this.value), this.opType, this.name);\n            return new ast_1.ExpressionStatement((() => {\n                switch (this.kind) {\n                    case 0:\n                        return util_3.msCall('newProperty', obj, util_3.transpileName(this.name), val);\n                    case 1:\n                        return new ast_1.AssignmentExpression('=', util_3.memberStringOrVal(obj, this.name), val);\n                    default:\n                        throw new Error();\n                }\n            })());\n        },\n        Method() {\n            const name = new ast_1.LiteralString(context_1.verifyResults.name(this));\n            const args = this.fun.opRestArg === null ?\n                new ast_1.ArrayExpression(this.fun.args.map((arg) => {\n                    const name = new ast_1.LiteralString(arg.name);\n                    return Op_1.caseOp(arg.opType, _ => new ast_1.ArrayExpression([name, util_3.t0(_)]), () => name);\n                })) :\n                ast_constants_1.LitUndefined;\n            const impl = this.fun instanceof MsAst_1.Fun ? [util_3.t0(this.fun)] : [];\n            return util_3.msCall('method', name, args, ...impl);\n        },\n        Module: transpileModule_1.default,\n        MsRegExp() {\n            return this.parts.length === 0 ?\n                new ast_1.LiteralRegExp(new RegExp('', this.flags)) :\n                this.parts.length === 1 && typeof this.parts[0] === 'string' ?\n                    new ast_1.LiteralRegExp(new RegExp(this.parts[0].replace('\\n', '\\\\n'), this.flags)) :\n                    util_3.msCall('regexp', new ast_1.ArrayExpression(this.parts.map(util_3.transpileName)), new ast_1.LiteralString(this.flags));\n        },\n        New() {\n            return new ast_1.NewExpression(util_3.t0(this.type), this.args.map(util_3.t0));\n        },\n        Not() {\n            return new ast_1.UnaryExpression('!', util_3.t0(this.arg));\n        },\n        ObjEntryAssign() {\n            if (this.assign instanceof MsAst_1.AssignSingle && !this.assign.assignee.isLazy) {\n                const name = this.assign.assignee.name;\n                return util_3.t1(this.assign, (val) => context_1.verifyResults.isObjEntryExport(this) ?\n                    transpileModule_1.exportNamedOrDefault(val, name) :\n                    new ast_1.ExpressionStatement(new ast_1.AssignmentExpression('=', util_1.member(ast_constants_1.IdBuilt, name), val)));\n            }\n            else {\n                const assigns = this.assign.allAssignees().map((_) => util_3.msCall('setLazy', ast_constants_1.IdBuilt, new ast_1.LiteralString(_.name), util_3.idForDeclareCached(_)));\n                return util_2.cat(util_3.t0(this.assign), assigns);\n            }\n        },\n        ObjEntryPlain() {\n            const val = util_3.t0(this.value);\n            return context_1.verifyResults.isObjEntryExport(this) ?\n                transpileModule_1.exportNamedOrDefault(val, this.name) :\n                new ast_1.AssignmentExpression('=', util_3.memberStringOrVal(ast_constants_1.IdBuilt, this.name), val);\n        },\n        ObjSimple() {\n            return new ast_1.ObjectExpression(this.pairs.map((pair) => new ast_1.PropertyPlain(util_1.propertyIdOrLiteral(pair.key), util_3.t0(pair.value))));\n        },\n        Pass() {\n            return new ast_1.ExpressionStatement(util_3.t0(this.ignored));\n        },\n        Pipe() {\n            return this.pipes.reduce((expr, pipe) => util_3.callFocusFun(util_3.t0(pipe), expr), util_3.t0(this.startValue));\n        },\n        QuotePlain: transpileQuotePlain_1.default,\n        QuoteSimple() {\n            return new ast_1.LiteralString(this.value);\n        },\n        QuoteTaggedTemplate() {\n            return new ast_1.TaggedTemplateExpression(util_3.t0(this.tag), util_3.t0(this.quote));\n        },\n        Range() {\n            const end = Op_1.caseOp(this.end, util_3.t0, () => GlobalInfinity);\n            return util_3.msCall('range', util_3.t0(this.start), end, new ast_1.LiteralBoolean(this.isExclusive));\n        },\n        SetSub() {\n            const getKind = () => {\n                switch (this.kind) {\n                    case 0:\n                        return 'init';\n                    case 1:\n                        return 'mutate';\n                    default:\n                        throw new Error();\n                }\n            };\n            const kind = getKind();\n            return new ast_1.ExpressionStatement(util_3.msCall('setSub', util_3.t0(this.object), this.subbeds.length === 1 ? util_3.t0(this.subbeds[0]) : this.subbeds.map(util_3.t0), util_3.maybeWrapInCheckInstance(util_3.t0(this.value), this.opType, 'value'), new ast_1.LiteralString(kind)));\n        },\n        SimpleFun() {\n            return util_3.focusFun(util_3.t0(this.value));\n        },\n        SpecialDo: transpileSpecial_1.transpileSpecialDo,\n        SpecialVal: transpileSpecial_1.transpileSpecialVal,\n        Spread() {\n            return new ast_1.SpreadElement(util_3.t0(this.spreaded));\n        },\n        Sub() {\n            return util_3.msCall('sub', util_3.t0(this.subbed), ...this.args.map(util_3.t0));\n        },\n        SuperCall() {\n            const args = this.args.map(util_3.t0);\n            const method = context_1.verifyResults.superCallToMethod.get(this);\n            if (method instanceof MsAst_1.Constructor) {\n                const call = new ast_1.CallExpression(ast_constants_1.IdSuper, args);\n                const memberSets = transpileClass_1.constructorSetMembers(method);\n                return util_2.cat(call, memberSets, ast_constants_1.SetLexicalThis);\n            }\n            else\n                return new ast_1.CallExpression(util_3.memberStringOrVal(ast_constants_1.IdSuper, method.symbol), args);\n        },\n        SuperMember() {\n            return util_3.memberStringOrVal(ast_constants_1.IdSuper, this.name);\n        },\n        Switch: transpileSwitch_1.default,\n        SwitchPart: transpileSwitch_1.transpileSwitchPart,\n        Throw() {\n            return Op_1.caseOp(this.opThrown, _ => util_3.doThrow(_), () => new ast_1.ThrowStatement(new ast_1.NewExpression(ast_constants_1.GlobalError, [LitStrThrow])));\n        },\n        Trait: transpileTrait_1.default,\n        TraitDo: transpileTrait_1.transpileTraitDo,\n        With() {\n            const idDeclare = util_3.idForDeclareCached(this.declare);\n            const val = util_3.t0(this.value);\n            const lead = util_3.plainLet(idDeclare, val);\n            return context_1.verifyResults.isStatement(this) ?\n                util_3.t1(this.block, lead) :\n                util_3.blockWrap(util_3.t3(this.block, lead, null, new ast_1.ReturnStatement(idDeclare)));\n        },\n        Yield() {\n            return new ast_1.YieldExpression(Op_1.opMap(this.opValue, util_3.t0), false);\n        },\n        YieldTo() {\n            return new ast_1.YieldExpression(util_3.t0(this.value), true);\n        }\n    });\n    const GlobalInfinity = new ast_1.Identifier('Infinity');\n    const LitStrThrow = new ast_1.LiteralString('An error occurred.');\n});\n","import Node, {ArrayExpression, AssignmentExpression, CallExpression, ConditionalExpression, Expression, ExpressionStatement,\n\tIdentifier, IfStatement, LiteralBoolean, LiteralNumber, LiteralRegExp, LiteralString, LogicalExpression, NewExpression, ObjectExpression, Program, PropertyPlain,\n\tReturnStatement, SpreadElement, Statement, TaggedTemplateExpression, ThrowStatement, UnaryExpression,\n\tVariableDeclaration, YieldExpression} from 'esast/lib/ast'\nimport {identifier, member, propertyIdOrLiteral} from 'esast-create-util/lib/util'\nimport Op, {caseOp, opMap} from 'op/Op'\nimport MsAst, {AssignSingle, Constructor, Val, Fun, Logics, LocalDeclare, LocalDeclares, Module, ObjPair, Setters} from '../MsAst'\nimport * as MsAstTypes from '../MsAst'\nimport {cat, implementMany, tail} from '../util'\nimport VerifyResults from '../VerifyResults'\nimport {IdBuilt, IdFocus, IdLexicalThis, IdSuper, GlobalError, LitUndefined, SetLexicalThis\n\t} from './ast-constants'\nimport {setup, tearDown, verifyResults} from './context'\nimport transpileAssert from './transpileAssert'\nimport transpileBlock from './transpileBlock'\nimport transpileCase, {transpileCasePart} from './transpileCase'\nimport transpileClass, {constructorSetMembers, transpileConstructor} from './transpileClass'\nimport transpileExcept, {transpileCatch} from './transpileExcept'\nimport {transpileBreak, transpileFor, transpileForAsync, transpileForBag} from './transpileFor'\nimport transpileFun from './transpileFun'\nimport transpileModule, {exportNamedOrDefault} from './transpileModule'\nimport transpileQuotePlain from './transpileQuotePlain'\nimport {transpileSpecialDo, transpileSpecialVal} from './transpileSpecial'\nimport transpileSwitch, {transpileSwitchPart} from './transpileSwitch'\nimport transpileTrait, {transpileTraitDo} from './transpileTrait'\nimport {accessLocalDeclare, blockWrap, blockWrapIfBlock, callFocusFun, doThrow, focusFun,\n\tidForDeclareCached, lazyWrap, makeDeclarator, makeDestructureDeclarators,\n\tmaybeWrapInCheckInstance, memberStringOrVal, msCall, msMember, plainLet, t0, t1, t3,\n\ttranspileName} from './util'\n\n/** Transform a [[MsAst]] into an esast. **/\nexport default function transpile(moduleExpression: Module, verifyResults: VerifyResults): Program {\n\tsetup(verifyResults)\n\tconst res = <any> t0(moduleExpression)\n\ttearDown()\n\treturn res\n}\n\nimplementMany(MsAstTypes, 'transpile', {\n\tAssert: transpileAssert,\n\n\tAssignSingle(valWrap: (_: Expression) => Expression): VariableDeclaration {\n\t\tconst val = valWrap === undefined ? t0(this.value) : valWrap(t0(this.value))\n\t\treturn new VariableDeclaration('let', [makeDeclarator(this.assignee, val, false)])\n\t},\n\n\t// TODO:ES6 Just use native destructuring assign\n\tAssignDestructure(): VariableDeclaration {\n\t\treturn new VariableDeclaration(\n\t\t\t'let',\n\t\t\tmakeDestructureDeclarators(\n\t\t\t\tthis.assignees,\n\t\t\t\tthis.kind === LocalDeclares.Lazy,\n\t\t\t\tt0(this.value),\n\t\t\t\tfalse))\n\t},\n\n\tAwait(): Expression {\n\t\treturn new YieldExpression(t0(this.value), false)\n\t},\n\n\tBagEntry(): Expression {\n\t\treturn msCall(this.isMany ? 'addMany' : 'add', IdBuilt, t0(this.value))\n\t},\n\n\tBagSimple(): Expression {\n\t\treturn new ArrayExpression(this.parts.map(t0))\n\t},\n\n\tBlock: transpileBlock,\n\n\tBlockWrap(): Expression {\n\t\treturn blockWrap(t0(this.block))\n\t},\n\n\tBreak: transpileBreak,\n\n\tCall(): Expression {\n\t\treturn new CallExpression(t0(this.called), this.args.map(t0))\n\t},\n\n\tCase: transpileCase,\n\tCasePart: transpileCasePart,\n\tCatch: transpileCatch,\n\tClass: transpileClass,\n\n\tCond(): Expression {\n\t\treturn new ConditionalExpression(t0(this.test), t0(this.ifTrue), t0(this.ifFalse))\n\t},\n\n\tConditional(): Expression | Statement {\n\t\tconst test = t0(this.test)\n\t\tif (verifyResults.isStatement(this))\n\t\t\treturn new IfStatement(\n\t\t\t\tthis.isUnless ? new UnaryExpression('!', test) : test, t0(this.result))\n\t\telse {\n\t\t\tconst result = msCall('some', blockWrapIfBlock(this.result))\n\t\t\tconst none = msMember('None')\n\t\t\tconst [then, _else] = this.isUnless ? [none, result] : [result, none]\n\t\t\treturn new ConditionalExpression(test, then, _else)\n\t\t}\n\t},\n\n\tConstructor: transpileConstructor,\n\n\tDel(): Expression {\n\t\treturn msCall('del', t0(this.subbed), ...this.args.map(t0))\n\t},\n\n\tExcept: transpileExcept,\n\tFor: transpileFor,\n\tForAsync: transpileForAsync,\n\tForBag: transpileForBag,\n\tFun: transpileFun,\n\n\tGetterFun(): Expression {\n\t\t// _ => _.foo\n\t\treturn focusFun(memberStringOrVal(IdFocus, this.name))\n\t},\n\n\tIgnore(): Array<Statement> {\n\t\treturn []\n\t},\n\n\tInstanceOf(): Expression {\n\t\t// TODO:ES6 new BinaryExpression('instanceof', t0(this.instance), t0(this.type))\n\t\treturn msCall('hasInstance', t0(this.type), t0(this.instance))\n\t},\n\n\tLazy(): Expression {\n\t\treturn lazyWrap(t0(this.value))\n\t},\n\n\tNumberLiteral(): Expression {\n\t\t// Negative numbers are not part of ES spec.\n\t\t// http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.3\n\t\tconst value = Number(this.value)\n\t\tconst lit = new LiteralNumber(Math.abs(value))\n\t\tconst isPositive = value >= 0 && 1 / value !== -Infinity\n\t\treturn isPositive ? lit : new UnaryExpression('-', lit)\n\t},\n\n\tLocalAccess(): Expression {\n\t\tif (this.name === 'this')\n\t\t\treturn IdLexicalThis\n\t\telse {\n\t\t\tconst ld = verifyResults.localDeclareForAccess(this)\n\t\t\t// If ld missing, this is a builtin, and builtins are never lazy\n\t\t\treturn ld === undefined ? identifier(this.name) : accessLocalDeclare(ld)\n\t\t}\n\t},\n\n\tLocalDeclare(): Expression {\n\t\treturn new Identifier(idForDeclareCached(this).name)\n\t},\n\n\tLocalMutate(): Statement {\n\t\treturn new ExpressionStatement(\n\t\t\tnew AssignmentExpression('=', identifier(this.name), t0(this.value)))\n\t},\n\n\tLogic(): Expression {\n\t\treturn tail(this.args).reduce<Expression>(\n\t\t\t(expr: Expression, arg: Val) =>\n\t\t\t\tnew LogicalExpression(this.kind === Logics.And ? '&&' : '||', expr, t0(arg)),\n\t\t\t<Expression> t0(this.args[0]))\n\t},\n\n\tMapEntry(): Statement {\n\t\treturn new ExpressionStatement(\n\t\t\tmsCall('setSub', IdBuilt, t0(this.key), t0(this.val)))\n\t},\n\n\tMember(): Expression {\n\t\treturn memberStringOrVal(t0(this.object), this.name)\n\t},\n\n\tMemberFun(): Expression {\n\t\tconst name = transpileName(this.name)\n\t\treturn caseOp(this.opObject,\n\t\t\t_ => msCall('methodBound', t0(_), name),\n\t\t\t() => msCall('methodUnbound', name))\n\t},\n\n\tMemberSet(): Statement {\n\t\tconst obj = t0(this.object)\n\t\tconst val = maybeWrapInCheckInstance(t0(this.value), this.opType, this.name)\n\t\treturn new ExpressionStatement((() => {\n\t\t\tswitch (this.kind) {\n\t\t\t\tcase Setters.Init:\n\t\t\t\t\treturn msCall('newProperty', obj, transpileName(this.name), val)\n\t\t\t\tcase Setters.Mutate:\n\t\t\t\t\treturn new AssignmentExpression('=', memberStringOrVal(obj, this.name), val)\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error()\n\t\t\t}\n\t\t})())\n\t},\n\n\tMethod(): Expression {\n\t\tconst name = new LiteralString(verifyResults.name(this))\n\t\tconst args = this.fun.opRestArg === null ?\n\t\t\tnew ArrayExpression(this.fun.args.map((arg: LocalDeclare) => {\n\t\t\t\tconst name = new LiteralString(arg.name)\n\t\t\t\treturn caseOp<Val, Expression>(arg.opType,\n\t\t\t\t\t_ => new ArrayExpression([name, t0(_)]),\n\t\t\t\t\t() => name)\n\t\t\t})) :\n\t\t\tLitUndefined\n\t\tconst impl = this.fun instanceof Fun ? [t0(this.fun)] : []\n\t\treturn msCall('method', name, args, ...impl)\n\t},\n\n\tModule: transpileModule,\n\n\tMsRegExp(): Expression {\n\t\treturn this.parts.length === 0 ?\n\t\t\tnew LiteralRegExp(new RegExp('', this.flags)) :\n\t\t\tthis.parts.length === 1 && typeof this.parts[0] === 'string' ?\n\t\t\tnew LiteralRegExp(new RegExp(this.parts[0].replace('\\n', '\\\\n'), this.flags)) :\n\t\t\tmsCall('regexp',\n\t\t\t\tnew ArrayExpression(this.parts.map(transpileName)), new LiteralString(this.flags))\n\t},\n\n\tNew(): Expression {\n\t\treturn new NewExpression(t0(this.type), this.args.map(t0))\n\t},\n\n\tNot(): Expression {\n\t\treturn new UnaryExpression('!', t0(this.arg))\n\t},\n\n\tObjEntryAssign(): Statement | Array<Statement> {\n\t\tif (this.assign instanceof AssignSingle && !this.assign.assignee.isLazy) {\n\t\t\tconst name = this.assign.assignee.name\n\t\t\treturn t1(this.assign, (val: Expression): Statement =>\n\t\t\t\tverifyResults.isObjEntryExport(this) ?\n\t\t\t\t\texportNamedOrDefault(val, name) :\n\t\t\t\t\tnew ExpressionStatement(new AssignmentExpression('=', member(IdBuilt, name), val)))\n\t\t} else {\n\t\t\tconst assigns = this.assign.allAssignees().map((_: LocalDeclare): Expression =>\n\t\t\t\tmsCall('setLazy', IdBuilt, new LiteralString(_.name), idForDeclareCached(_)))\n\t\t\treturn cat(<any> t0(this.assign), assigns)\n\t\t}\n\t},\n\n\tObjEntryPlain(): Statement {\n\t\tconst val = t0(this.value)\n\t\treturn verifyResults.isObjEntryExport(this) ?\n\t\t\t// We've verified that for module export, this.name must be a string.\n\t\t\texportNamedOrDefault(val, this.name) :\n\t\t\tnew AssignmentExpression('=', memberStringOrVal(IdBuilt, this.name), val)\n\t},\n\n\tObjSimple(): Expression {\n\t\treturn new ObjectExpression(this.pairs.map((pair: ObjPair) =>\n\t\t\tnew PropertyPlain(propertyIdOrLiteral(pair.key), t0(pair.value))))\n\t},\n\n\tPass(): Statement {\n\t\treturn new ExpressionStatement(t0(this.ignored))\n\t},\n\n\tPipe(): Expression {\n\t\treturn this.pipes.reduce(\n\t\t\t(expr: Expression, pipe: Val) => callFocusFun(t0(pipe), expr),\n\t\t\tt0(this.startValue))\n\t},\n\n\tQuotePlain: transpileQuotePlain,\n\n\tQuoteSimple(): Expression {\n\t\treturn new LiteralString(this.value)\n\t},\n\n\tQuoteTaggedTemplate(): Expression {\n\t\treturn new TaggedTemplateExpression(t0(this.tag), t0(this.quote))\n\t},\n\n\tRange(): Expression {\n\t\tconst end = caseOp(this.end, t0, () => GlobalInfinity)\n\t\treturn msCall('range', t0(this.start), end, new LiteralBoolean(this.isExclusive))\n\t},\n\n\tSetSub(): Statement {\n\t\tconst getKind = () => {\n\t\t\tswitch (this.kind) {\n\t\t\t\tcase Setters.Init:\n\t\t\t\t\treturn 'init'\n\t\t\t\tcase Setters.Mutate:\n\t\t\t\t\treturn 'mutate'\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error()\n\t\t\t}\n\t\t}\n\t\tconst kind = getKind()\n\t\treturn new ExpressionStatement(msCall(\n\t\t\t'setSub',\n\t\t\tt0(this.object),\n\t\t\tthis.subbeds.length === 1 ? t0(this.subbeds[0]) : this.subbeds.map(t0),\n\t\t\tmaybeWrapInCheckInstance(t0(this.value), this.opType, 'value'),\n\t\t\tnew LiteralString(kind)))\n\t},\n\n\tSimpleFun(): Expression {\n\t\treturn focusFun(t0(this.value))\n\t},\n\n\tSpecialDo: transpileSpecialDo,\n\tSpecialVal: transpileSpecialVal,\n\n\tSpread(): SpreadElement {\n\t\treturn new SpreadElement(t0(this.spreaded))\n\t},\n\n\tSub(): Expression {\n\t\treturn msCall('sub', t0(this.subbed), ...this.args.map(t0))\n\t},\n\n\tSuperCall(): Expression | Array<Statement> {\n\t\tconst args = this.args.map(t0)\n\t\tconst method = verifyResults.superCallToMethod.get(this)\n\n\t\tif (method instanceof Constructor) {\n\t\t\t// super must appear as a statement, so OK to decalre `this`\n\t\t\tconst call = new CallExpression(IdSuper, args)\n\t\t\tconst memberSets = constructorSetMembers(method)\n\t\t\treturn cat(call, memberSets, SetLexicalThis)\n\t\t} else\n\t\t\treturn new CallExpression(memberStringOrVal(IdSuper, method.symbol), args)\n\t},\n\n\tSuperMember(): Expression {\n\t\treturn memberStringOrVal(IdSuper, this.name)\n\t},\n\n\tSwitch: transpileSwitch,\n\tSwitchPart: transpileSwitchPart,\n\n\tThrow(): Statement {\n\t\treturn caseOp(this.opThrown,\n\t\t\t_ => doThrow(_),\n\t\t\t() => new ThrowStatement(new NewExpression(GlobalError, [LitStrThrow])))\n\t},\n\n\tTrait: transpileTrait,\n\tTraitDo: transpileTraitDo,\n\n\tWith(): Expression {\n\t\tconst idDeclare = idForDeclareCached(this.declare)\n\t\tconst val = t0(this.value)\n\t\tconst lead = plainLet(idDeclare, val)\n\t\treturn verifyResults.isStatement(this) ?\n\t\t\tt1(this.block, lead) :\n\t\t\tblockWrap(t3(this.block, lead, null, new ReturnStatement(idDeclare)))\n\t},\n\n\tYield(): Expression {\n\t\treturn new YieldExpression(opMap(this.opValue, t0), false)\n\t},\n\n\tYieldTo(): Expression {\n\t\treturn new YieldExpression(t0(this.value), true)\n\t}\n})\n\nconst GlobalInfinity = new Identifier('Infinity')\nconst LitStrThrow = new LiteralString('An error occurred.')\n"],"sourceRoot":"/source/"}